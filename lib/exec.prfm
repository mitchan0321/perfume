# exec external process

defun exec (args: args) {
    args ::= $args map {| i | "" . $i};
    command ::= $args >>;

    d ::= dict [fork-exec $command $args];

    pid := $d,pid;

    out := $d,left;
    OUT ::= new File;
    $OUT set! $out mode: o;
    $OUT set-newline <t>;
    $OUT set-nobuffer;

    in := $d,right;
    IN ::= new File;
    $IN set! $in mode: i;
    $IN set-newline <nil>;
    $IN set-nobuffer;
    if {true? CO-MODE} then: {$IN set-noblock t};

    err := $d,error;
    ERR ::= new File;
    $ERR set! $err mode: i;
    $ERR set-newline <nil>;
    $ERR set-nobuffer;
    if {true? CO-MODE} then: {$ERR set-noblock t};

    if {true? PipeObject} then: {
	$PipeObject set-term-hook [fun () {$IN close; $OUT close; $ERR close}];
    };

    status := 255;
    try {
	poll ::= new PollingManager;
	$poll set-exit-condition-block {
	    and [$stdin eof?] [$IN eof?] [$ERR eof?];
	};
	$poll set-wait-block {
	    (in out exp) ::= select ([$stdin fd?] [$IN fd?] [$ERR fd?]) () () 100;
	    if {$in null?} <nil> <t>;
	};
	$poll add-event-queue (
	    {
		$stdin ready?
	    } {
		$OUT puts [$stdin gets]
	    }
	);
	$poll add-event-queue (
	    {
		$IN ready?
	    } {
		$stdout puts [$IN gets]
	    }
	);
	$poll add-event-queue (
	    {
		$ERR ready?
	    } {
		$stderr puts [$ERR gets]
	    }
	);
	$poll event-loop;
    }
    
    fin: {
	$OUT close;
	$IN  close;
	$ERR close;
	status ::= wait $pid;
	if {$status = 255} then: {
	    throw ErrExecProgram "Can\'t execute program."
	};
    };

    return $status;
};
