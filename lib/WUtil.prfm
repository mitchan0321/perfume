class WUtil;

WUtil method init () {
    init-config;
    init-color-DB;
    init-command-DB;

    # Ommit exit command.
    d ::= dict-func;
    f ::= $d get exit;
    $d unset exit;
    $d set _exit $f;
    defun exit () {$MainWindow exit-event-loop};
};

WUtil method color-pair (fg bg) {
    if {sets? ColorPair} else: {
	sets ColorPair [dict];
	$ColorPair set count 0;
    };
    if {sets? ColorName} else: {
	sets ColorName [dict];
	$ColorName set BLACK   0;
	$ColorName set RED     1;
	$ColorName set GREEN   2;
	$ColorName set YELLOW  3;
	$ColorName set BLUE    4;
	$ColorName set MAGENTA 5;
	$ColorName set CYAN    6;
	$ColorName set WHITE   7;
    };

    if {$ColorName set? $fg} else: {throw ErrNoSuchColorName "No such foreground color name."};
    if {$ColorName set? $bg} else: {throw ErrNoSuchColorName "No such background color name."};    

    if {$ColorPair set? ($ColorName,$fg $ColorName,$bg)}
    then: {
	return [$ColorPair get ($ColorName,$fg $ColorName,$bg)];
    }
    else: {
	p ::= $ColorPair get count;
	p ::= $p + 1;
	curs-add-color $p $ColorName,$fg $ColorName,$bg;
	$ColorPair set ($ColorName,$fg $ColorName,$bg) $p;
	$ColorPair set $p ($ColorName,$fg $ColorName,$bg);
	$ColorPair set count $p;
	return $p;
    };
};

WUtil method get-bgcolor (name) {
    n ::= $ColorDB get $name;
    $n ?? {throw ErrNoSuchColor ["WUtil::get-bgcolor: No such color DB name, " . $name]};
    try {
	(fg bg) ::= $ColorPair get $n;
    }
    catch: {throw ErrNoSuchColor ["WUtil::get-bgcolor: No color pair no, " . $n]};
    return $bg;
};

WUtil method get-fgcolor (name) {
    n ::= $ColorDB get $name;
    $n ?? {throw ErrNoSuchColor ["WUtil::get-fgcolor: No such color DB name, " . $name]};
    try {
	(fg bg) ::= $ColorPair get $n;
    }
    catch: {throw ErrNoSuchColor ["WUtil::get-fgcolor: No color pair no, " . $n]};
    return $fg;
};

defun init-config () {
    if {defvar? PMACS_INIT}
    else: {
	$LIB_PATH each do: {| i |
	    if {file exists? [$i . "/pmacs.conf"]} {
		load [$i . "/pmacs.conf"];
		break;
	    };
	};
	defvar PMACS_INIT <t>;
    };
};

defun init-color-DB () {
    if [defvar? ColorDB] else: {
	defvar ColorDB [dict];
    };

    $LIB_PATH each do: {| i |
	if {file exists? [$i . "/color-defs.prfm"]} {
	   load [$i . "/color-defs.prfm"];
	   break;
	};
    };
};

defun init-command-DB () {
    if {defvar? EditorCommand}
    else: {
	defvar EditorCommand [dict];
    };

    $LIB_PATH each do: {| i |
	if {file exists? [$i . "/EditorCommandDefs.prfm"]} {
	    load [$i . "/EditorCommandDefs.prfm"];
	    break;
	};
    };
};

defun defcommand (name block) {
    $EditorCommand set $name $block;
};

defun get-command (name) {
    $EditorCommand get $name;
};

defun set-window-color-default (curs name) {
    curs-set-bgcolor $curs [$ColorDB get $name];
    curs-set-color   $curs [$ColorDB get $name];
};

defun line-input (curs disp-line disp-col input-len cur-index cur-val key-in) {
    curs-print $curs ["%-" . $input-len "v" : fmt ""] $DISPLAY_ENCODING $disp-line $disp-col;
    curs-render-line $curs $disp-line 0 $disp-col $cur-val $DEFAULT_TAB_WIDTH $DISPLAY_ENCODING;
    v ::= vector($InputValue);
    new-x := $cur-index;
    cond
    {string? $key-in} {
	curs-x ::= curs-index-to-pos $cur-val [$cur-val len] $DEFAULT_TAB_WIDTH;
	if {$curs-x < $input-len} {
	    (new-y new-x) ::= $v insert-string-at $key-in 0 $cur-index;
	};
    }
    {eq? $key-in KEY_RIGHT} {
	new-x ::= $cur-index + 1;
	if {$new-x > [$v get 0 : len]} {
	    new-x := [$v get 0 : len];
	};
    }
    {eq? $key-in KEY_LEFT} {
	new-x ::= $cur-index - 1;
	if {$new-x < 0} {new-x := 0};
    }
    {or [eq? $key-in KEY_BACKSPACE] [eq? $key-in CTRL_H]} {
	(new-y new-x char) ::= $v backdelete-character-at 0 $cur-index;
    }
    {eq? $key-in KEY_DC} {
	(new-y new-x char) ::= $v delete-character-at 0 $cur-index;
    }
    ;

    return ($key-in $new-x [if {[$v len] = 0} "" {$v get 0}]);
};

defun show-message (msg) {
    if $MainWindow {
	[$MainWindow get-minibuffer-window] ?? {throw ErrNoMiniBuffer "No MiniBuffer for debugging."};
	$MainWindow display-window-message "MiniBuffer" $msg;
	$MainWindow get-minibuffer-window : refresh;
    };
};

defun path-adjust (path) {
    l ::= $path split sep: "/";
    r := ();
    $l each do: {| i |
	cond
	    {$i = ".."} {if {[$r len] > 1} {$r ->>}; break;}
	    {$i = "."}  {break;}
	    <t>         {$r <<- $i}
	;
    };
    return [$r join sep: "/"];
};

##
## define Vector method for EditBuffer operations.
##
Vector method insert-string-at (str line at) {
    l ::= $str split sep: "\r";
    times ::= $l len;
    self ::= self;
    i := 1;
    $l each do: {| elem |
	if {$line < [$self len]} {
	    s ::= $self get $line;
	    if {$at > [$s len]} {at := [$s len]};
	    s1 ::= $s sub 0 $at;
	    s2 ::= $s sub $at;
	    $self set $line [$s1 . $elem $s2];
	    $at ++ [$elem len];
	} {
	    $self append! $elem;
	    at ::= $elem len;
	};
	if {$i = $times} {break};
	$self append! "";
	[$self len : - 2] each to: $line do: {
	    | j |
	    if {$line = $j} {
		s1 ::= $self get $j : sub 0 $at;
		s2 ::= $self get $j : sub $at;
		$self set [$j + 1] $s2;
		$self set $j $s1;
	    } {
		$self set [$j + 1] [$self get $j];
	    };
	};
	$i ++;
	$line ++;
	at := 0;
    };
    return ($line $at);
};

Vector method delete-character-at (line at) {
    self ::= self;
    if {$line >= [$self len]} {
	if {[$self len] = 0} {return (0 0 "")};
	return ([$self len] 0 "");
    };
    s ::= $self get $line;
    len ::= $s len;
    if {and [[$self len] = 1] [$len = 0]} {
	$self resize 0;
	return (0 0 "\r");
    };
    if {$at >= $len} {
	if {[$line + 1] = [$self len]} {
	    return ($line $len "");
	};
	$self set $line [$self,$line . [$self get [$line + 1]]];
	if {$line = [$self len : - 2]} {
	    $self resize [$self len : - 1];
	    return ($line $len "\r");
	};
	[$line + 1] each to: [$self len : - 2] do: {| i |
	    $self set $i [$self get [$i + 1]];
	};
	$self resize [$self len : - 1];
	return ($line $len "\r");
    };
    s1 ::= $s sub 0 $at;
    c ::= $s sub $at [$at + 1];
    s2 ::= $s sub [$at + 1];
    $self set $line [$s1 . $s2];
    return ($line $at $c);
};

Vector method backdelete-character-at (line at) {
    self ::= self;
    if {$at = 0} {
	if {$line = 0} {
	    return (0 0 "");
	};
	line ::= $line - 1;
	at ::= [$self get $line] len;
	return [delete-character-at $line $at];
    };
    at ::= $at - 1;
    return [delete-character-at $line $at];    
};

Vector method append-string (str) {
    [self] append! $str;
    return ([[self] len] 0 $str);
};

String method repeat (times) {
    result := "";
    self ::= self;
    1 each to: $times do: {
	$result append! $self;
    };
    return $result;
};
