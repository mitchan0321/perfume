class TaskManager;

TaskManager method init () {
    if {sets? TaskList} {
        $TaskList each do: {| i |
            try {$i release} catch: {};
        };
    };
    sets TaskList ();
    sets LastDispatch [time-of-day];
    
    sets Task_stdout [new EditStream];
    $Task_stdout open "*Console*";

    sets Task_stdin [new Stream];
    $Task_stdin set-limit 1024;

    sets SysReq [new Stream];
    sets WaitHook [dict ()];
};

TaskManager method add (task name) {
    if {$task instance? Task} else: {
        throw ErrBadType "Not a Task object.";
    };
    if {$TaskList find $task} {
        throw ErrDuplicateTask "Already registerd task.";
    };
    n := 0;
    name ::= "" . $name;
    sname := $name;
    tlist ::= $TaskList map {| i | $i get-name};
    while {$tlist find $sname} do: {
        n ::= $n + 1;
        sname ::= $name . ":" $n;
    };
    $TaskList <<- $task;
    $task set-name $sname;
    in ::= new Stream;
    $in set-comode;
    $in set-tag STDIN;
    (__in __out __err) ::= $task get-stdio;
    call $task (set-stdio 
                [$__in ??? <nil> $in] 
                [$__out ??? <nil> $Task_stdout] 
                [$__err ??? <nil> $Task_stdout]
    );
    return $sname;
};

TaskManager method get (name) {
    $TaskList each do: {| i |
        if {[$i get-name] = $name} {
            return $i;
        };
    };
    return <nil>;
};

TaskManager method get-task-list () {
    return $TaskList;
};

TaskManager method get-task (name) {
    $TaskList each do: {| t |
        if {$t get-name : = $name} {
            return $t;
        };
    };
    return <nil>;
};

TaskManager method dispatch () {
    now ::= time-of-day :msec;
    tick ::= $now - $LastDispatch;
    sets LastDispatch $now;
    
    #
    # search most min sleep time task (all list element linear scan)
    #
    min-wait := 1;
    min-task := <nil>;
    $TaskList each do: {| t |
        if {$t tickable?} {
            wait ::= $t time-elapsed $tick;
            
            if {$wait <= 0} {
                if {$wait < $min-wait} {
                    min-wait := $wait;
                    min-task := $t;     # run task candidate
                };
            };
        };
    };
    
    #
    # run most min sleep task
    # if task was executed, then return <t>
    #
    result := <nil>;
    $SysReq clear;

    if $min-task {
        ### set task dispatched
        result := <t>;

        ### save non task env's current working directory
        cwd ::= pwd;
        
        ### dispatch to min task
        $Task_stdin close;
        $min-task run;
        $Task_stdin clear-eof;
        
        ### restore non task env's current working directory
        cd $cwd;

        #
        # Apply system call request
        #
        $SysReq close;
        try {
            ### apply request system call from tasn at this tick.
            apply-syscalls;

        } catch: {| e |
            ### $Task_stdout puts "";
            $Task_stdout puts [">>>Error at apply-syscalls: " . $e];
        };

        if {$min-task exit?} {
            #
            # proces terminate
            #
            ### $Task_stdout puts "";
            $Task_stdout puts [">>>Task [" . [$min-task get-name] "] end, status= " [$min-task get-exit-status]];

            ### remove from task list TaskManager instance.
            idx ::= $TaskList find $min-task;
            if $idx {
                $TaskList delete! $idx
            };
            
            ### remove wait hook.
            delete-wait-hook [$min-task get-name];
            
            ### remove parents child list and add to parents child status.
            p ::= $min-task get-parent;
            if $p {
                $p remove-child $min-task;
                $p add-child-exit-status ($min-task [$min-task get-exit-status]);
            };
        };
    };
    
    try {
        ### check and force to activate waiting task.
        force-wait-task;

    } catch: {| e |
        $Task_stdout puts [">>>Error at force-wait-task: <" .  $e,0 "># " $e,1];
    };
    
    return $result;
};

TaskManager method enqueue (msg) {
    $SysReq puts $msg;
};

TaskManager method apply-syscalls () {
    while {r ::= $SysReq gets;} do: {
        case $r,0
        APPLY_EDITOR {
            (syscall body task) := $r;
            try {
                sts ::= begin :rebase local: [dict-local] {$body eval};
                $task add-request-stat (RESULT $sts);
            } catch: {| e |
                if {$task exit?} {
                    $Task_stdout puts [">>>Task [" . [$task get-name] "] terminate proc error: <" $e,0 "># " $e,1];
                } {
                    $task add-request-stat (ERROR $e);
                };
            };
        }
        NEW_TASK {
            (syscall name body args task) := $r;
            try {
                t ::= new Task;
                $t set-parent $task;
                (i o e) ::= $task get-stdio;
                $t set-stdin $i;
                $t set-stdout $o;
                $t set-stderr $e;
                $task add-child $t;
                $task add-request-stat (TASK $t);
                call $t [(proc $name $body) concat $args];
            } catch: {| e |
                $task add-request-stat (ERROR $e);
                $task terminate;
                $task set-exit;
            };
        }
        default: {
            $Task_stdout puts [">>>Bad SysReq(UNKNOWN): " . $fun ", " $body];
            $task add-request-stat (ERROR ["Bad SysReq(UNKNOWN): " . $fun ", " $body]);
        };
    };
};

TaskManager method force-wait-task () {
    $WaitHook keys : each do: {| name |
        try {
            (task target checker-block) ::= $WaitHook get $name;
            if {! [eq? [$task get-state] W]} {
                continue;
            };
            if {yield $checker-block} {
                ### task state W -> S
                $task set-sleep;
            };
        }
        catch: {| e |
            delete-wait-hook $name;
            $Task_stdout puts [">>>Bad SysReq at wait: " . $e ", " $name];
        };
    };
};

TaskManager method add-wait-hook (task-name wait-object) {
    $WaitHook set $task-name $wait-object;
};

TaskManager method delete-wait-hook (task-name) {
    $WaitHook unset $task-name;
};

TaskManager method tell-wait-hook (task-name) {
    [o ::= $WaitHook get $task-name] ?? {return ""};
    if {$o,1 instance? Task} {return [$o,1 get-name]};
    if {string? $o,1} {return $o,1};
    return "???";
};

TaskManager method send-to-task (msg) {
    $Task_stdin puts $msg;
};

TaskManager method recv-from-stdin () {
    return [$Task_stdin gets];
};

TaskManager method stdin-ready? () {
    return [$Task_stdin ready?];
};

TaskManager method panic (msg) {
    $Task_stdout puts "";
    $Task_stdout puts [">>>Panic: " . $msg];
};

TaskManager method output-console (msg) {
    $Task_stdout puts $msg;
};

