class TaskManager;

TaskManager method init () {
    if {sets? TaskList} {
        $TaskList each do: {| i |
            try {$i release} catch: {};
        };
    };
    sets TaskList ();
    sets LastDispatch [time-of-day];
    
    sets Task_stdout [new EditStream];
    $Task_stdout open "*Console*";
    
    sets SysReq [new Stream];
    sets WaitHook [dict ()];
};

TaskManager method add (task name) {
    if {$task instance? Task} else: {
        throw ErrBadType "Not a Task object.";
    };
    if {$TaskList find $task} {
        throw ErrDuplicateTask "Already registerd task.";
    };
    n := 1;
    name ::= "" . $name;
    sname := $name;
    tlist ::= $TaskList map {| i | $i get-name};
    while {$tlist find $sname} do: {
        n ::= $n + 1;
        sname ::= $name . ":" $n;
    };
    $TaskList <<- $task;
    $task set-name $sname;
    in ::= new Stream;
    $task set-stdio $in $Task_stdout $Task_stdout;
    return $sname;
};

TaskManager method get (name) {
    $TaskList each do: {| i |
        if {[$i get-name] = $name} {
            return $i;
        };
    };
    return <nil>;
};

TaskManager method get-task-list () {
    return $TaskList;
};

TaskManager method get-task (name) {
    $TaskList each do: {| t |
        if {$t get-name : = $name} {
            return $t;
        };
    };
    return <nil>;
};

TaskManager method dispatch () {
    now ::= time-of-day :msec;
    tick ::= $now - $LastDispatch;
    sets LastDispatch $now;
    
    #
    # search most min sleep time task (all list element linear scan)
    #
    min-wait := 1;
    min-task := <nil>;
    $TaskList each do: {| t |
        if {$t tickable?} {
            wait ::= $t time-elapsed $tick;
            
            if {$wait <= 0} {
                if {$wait < $min-wait} {
                    min-wait := $wait;
                    min-task := $t;     # run task candidate
                };
            };
        };
    };
    
    #
    # run most min sleep task
    # if task was executed, then return <t>
    #
    result := <nil>;
    $SysReq clear;
    if $min-task {

        ### dispatch to min task
        $min-task run;

        if {$min-task exit?} {
            #
            # proces terminate
            #
            $Task_stdout puts "";
            $Task_stdout puts ["Task [" . [$min-task get-name] "] end, status= " [$min-task get-exit-status]];

            ### remove from task list TaskManager instance.
            idx ::= $TaskList find $min-task;
            if $idx {
                $TaskList delete! $idx
            };
            
            ### remove wait hook.
            delete-wait-hook [$min-task get-name];
            
            ### remove parents child list and add to parents child status.
            p ::= $min-task get-parent;
            if $p {
                $p remove-child $min-task;
                $p add-child-exit-status ($min-task [$min-task get-exit-status]);
            };
        };
        result := <t>;
        $SysReq close;
        try {
            ### apply request system call from tasn at this tick.
            apply-syscalls;

        } catch: {| e |
            $Task_stdout puts "";
            $Task_stdout puts ["Error at apply-syscalls: " . $e];
        };
    };
    
    try {
        ### check and force to activate waiting task.
        force-wait-task;

    } catch: {| e |
        $Task_stdout puts ["Error at force-wait-task: " . $e];
    };
    
    return $result;
};

TaskManager method enqueue (msg) {
    $SysReq puts $msg;
};

TaskManager method apply-syscalls () {
    while {! [$SysReq eof?]} do: {
        r ::= $SysReq gets;
        case $r,0
        APPLY_EDITOR {
            (syscall body task) := $r;
            try {
                $task add-request-stat (RESULT [
                    begin :rebase local: [dict-local] {$body eval};
                ]);
            } catch: {| e |
                $task add-request-stat (ERROR $e);
            };
        }
        NEW_TASK {
            (syscall name body args task) := $r;
            try {
                t ::= new Task;
                $t set-parent $task;
                $task add-child $t;
                $task add-request-stat (TASK $t);
                call $t [(proc $name $body) concat $args];
            } catch: {| e |
                $task add-request-stat (ERROR $e);
            };
        }
        default: {
            $Task_stdout puts ["Bad SysReq(UNKNOWN): " . $fun ", " $body];
            $task add-request-stat (ERROR ["Bad SysReq(UNKNOWN): " . $fun ", " $body]);
        };
    };
};

TaskManager method force-wait-task () {
    $WaitHook keys : each do: {| name |
        try {
            (task target checker-block) ::= $WaitHook get $name;
            if {! [eq? [$task get-state] W]} {
                continue;
            };
            if {yield $checker-block} {
                ### task state W -> S
                $task set-sleep;
            };
        }
        catch: {| e |
            delete-wait-hook $name;
            $Task_stdout puts ["Bad SysReq at wait: " . $e ", " $name];
        };
    };
};

TaskManager method add-wait-hook (task-name wait-object) {
    $WaitHook set $task-name $wait-object;
};

TaskManager method delete-wait-hook (task-name) {
    $WaitHook unset $task-name;
};

TaskManager method panic (msg) {
    $Task_stdout puts "";
    $Task_stdout puts $msg;
};

