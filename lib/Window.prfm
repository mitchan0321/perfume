load-class :force CombiWindow;
load-class :force MiniWindow;

class Window;

Window method init (curs) {
    sets RootWin $curs;
    init-constructor;
};

Window method init-constructor () {
    sets WindowList ();
    $WindowList method string () {
	s := "";
	[self] each do: {| i |
	    $s append! [$i string];
	    $s append! "(";
	    $s append! [$i get-buffer : get-buffer-name];
	    $s append! ")";
	    $s append! " ";
	};
	return $s;
    };
    (y x) ::= curs-get-screen-size $RootWin;
    sets CursWin [curs-create-window $RootWin 0 0 [$y - 1] $x];
    sets CursWinMini <nil>;
    sets CreateWindowHook <nil>;
    sets BufferBinding [dict];
};

Window method get-curs () {
    return $CursWin;
};

Window method get-curs-mini () {
    return $CursWinMini;
};

Window method create-minibuffer-window () {
    (y x) ::= curs-get-screen-size $RootWin;
    sets CursWinMini [curs-create-window $RootWin [$y - 1] 0 1 $x];

    (l c) ::= curs-get-screen-size $CursWinMini;
    win ::= new MiniWindow init: ([self] 0 0 $l $c);

    sets MiniWindow $win;
    $MiniWindow set-window-name "MiniBuffer";
    $MiniWindow activate;
};

Window method create-full-window () {
    sets WindowList ();
    (l c) ::= curs-get-screen-size $CursWin;
    win ::= new CombiWindow init: ([self] 0 0 $l $c);
    $win set-window-name "Window#1";
    $WindowList <<- $win;
    $WindowList car : activate;
};

Window method create-split-vertical-window (div: ndivs) {
    sets WindowList ();
    if {set? ndivs} else: {set ndivs 2};
    if {$ndivs < 2} then: {set ndivs 2};
    if {$ndivs > $MAX_WINDOW_DIVS} then: {set ndivs $MAX_WINDOW_DIVS};
    
    (l c) ::= curs-get-screen-size $CursWin;
    c-orig := $c;
    c ::= $c / $ndivs;
    w := 0;
    1 each to: $ndivs do: {| win-ord |
	if {$win-ord != $ndivs}
	then: {
	    win ::= new CombiWindow init: ([self] 0 $w $l $c);
	}
	else: {
	    win ::= new CombiWindow init: ([self] 0 $w $l [$c-orig - [$c * [$ndivs - 1]]]);
	};
	$win set-window-name ["Window#" . $win-ord];
	$WindowList <<- $win;
	
	w ::= $w + $c;
    };
    $WindowList car : activate;
    $WindowList cdr : each do: {| i | $i diactivate};
};

Window method create-split-horizontal-window (div: ndivs) {
    sets WindowList ();
    if {set? ndivs} else: {set ndivs 2};
    if {$ndivs < 2} then: {set ndivs 2};
    if {$ndivs > $MAX_WINDOW_DIVS} then: {set ndivs $MAX_WINDOW_DIVS};
    
    (l c) ::= curs-get-screen-size $CursWin;
    l-orig := $l;
    l ::= $l / $ndivs;
    w := 0;
    1 each to: $ndivs do: {| win-ord |
	if {$win-ord != $ndivs}
	then: {
	    win ::= new CombiWindow init: ([self] $w 0 $l $c);
	}
	else: {
	    win ::= new CombiWindow init: ([self] $w 0 [$l-orig - [$l * [$ndivs - 1]]] $c);
	};
	$win set-window-name ["Window#" . $win-ord];
	$WindowList <<- $win;
	
	w ::= $w + $l;
    };
    $WindowList car : activate;
    $WindowList cdr : each do: {| i | $i diactivate};
};

Window method create-split-cross-window () {
    sets WindowList ();
    (l c) ::= curs-get-screen-size $CursWin;
    y0 := 0;
    y1 ::= $l / 2;
    x0 := 0;
    x1 ::= $c / 2;

    win ::= new CombiWindow init: ([self] 0 0 $y1 $x1);
    $win set-window-name "Window#1";
    $WindowList <<- $win;

    win ::= new CombiWindow init: ([self] 0 $x1 $y1 [$c - $x1]);
    $win set-window-name "Window#2";
    $WindowList <<- $win;

    win ::= new CombiWindow init: ([self] $y1 0 [$l - $y1] $x1);
    $win set-window-name "Window#3";
    $WindowList <<- $win;
    
    win ::= new CombiWindow init: ([self] $y1 $x1 [$l - $y1] [$c - $x1]);
    $win set-window-name "Window#4";
    $WindowList <<- $win;

    $WindowList car : activate;
    $WindowList cdr : each do: {| i | $i diactivate};
};

Window method refresh () {
    $MiniWindow refresh;
    try {$WindowList cdr : each do: {| w | $w refresh}} catch: {};
    get-current-window : apply {set-cursor; refresh};
};

Window method display-window-message (win msg) {
    $WindowList . $MiniWindow : each do: {| i |
	if {[$i get-window-name] = $win} {
	    $i display $msg;
	    return;
	};
    };
    ##### throw ErrNoSuchWindow ["No such window name '" . $win "'"];
};

Window method clear-window (win) {
    $WindowList . $MiniWindow : each do: {| i |
	if {[$i get-window-name] = $win} {
	    $i clear;
	    return;
	};
    };
};

Window method get-minibuffer-window () {
    return $MiniWindow;
};

Window method get-current-window () {
    return [$WindowList car];
};

Window method roll-current-window () {
    win ::= $WindowList >>;
    $WindowList <<- $win;
    $WindowList car : activate;
    try {$WindowList cdr : each do: {| i | $i diactivate}} catch: {};
    return [$WindowList car];
};

Window method roll-to-window (window-name) {
    n ::= $WindowList map {| i | $i get-window-name} : find $window-name;
    $n ?? {return};

    if {$n = 0} else: {
        1 each to: $n do: {
	    win ::= $WindowList >>;
	    $WindowList <<- $win;
	};
    };
    $WindowList car : activate;
    try {$WindowList cdr : each do: {| i | $i diactivate}} catch: {};
    return [$WindowList car];
};

Window method roll-buffer () {
    win := $WindowList,0;

    buff ::= BufferManager get-next-buffer [$win get-buffer];
    win-name ::= $win get-window-name;
    bind-buffer $win-name $buff;
};

Window method bind-buffer (window-name buffer) {
    window := <nil>;
    $WindowList each do: {| i |
	if {[$i get-window-name] = $window-name} {
	    window := $i;
	    break;
	};
    };
    $window ?? {return};

    # Save window buffer geometory
    orig-buff ::= $window get-buffer;
    if $orig-buff {
	BufferManager set-buffer-geom $window-name [$orig-buff get-buffer-name];
	# $window,CursorLine $window,CursorColumn;
    };

    # Restore window buffer geometory
    $buffer ?? {return};

    $window set-buffer $buffer;
    geom ::= BufferManager get-buffer-geom $window-name [$buffer get-buffer-name];
    BufferManager set-buffer-geom $window-name [$buffer get-buffer-name];
};

Window method render-all () {
    $WindowList each do: {| i |
	$i render;
    };
};

Window method render (window-name) {
    window := <nil>;
    $WindowList each do: {| i |
	if {[$i get-window-name] = $window-name} {
	    window := $i;
	    break;
	};
    };
    $window ?? {return};
    
    $window render;
};

Window method add-create-window-hook (hook) {
    sets CreateWindowHook $hook;
};

Window method resize-window () {
    $MiniWindow destroy;
    sets MiniWindow <nil>;
    $WindowList each do: {| w |
        $BufferBinding set [$w get-window-name] [$w get-buffer];
	$w destroy;
    };
    roll-to ::= $WindowList car : get-window-name;
    sets WindowList ();
    curs-destroy-window $CursWin;

    (y x) ::= curs-get-screen-size $RootWin;
    sets CursWin [curs-create-window $RootWin 0 0 [$y - 1] $x];
    create-minibuffer-window;
    if {block? $CreateWindowHook} {
	$CreateWindowHook eval;
    } {
	create-full-window;
    };
    debug-message [$WindowList string];
    $WindowList each do: {| w |
	win ::= $w get-window-name;
	$win ?? {return};
	buff ::= $BufferBinding get $win;
	$buff ?? {return};
	bind-buffer $win $buff;
    };
    roll-to-window $roll-to;
};
