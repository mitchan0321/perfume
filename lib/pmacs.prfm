load-class :force BufferManager;
load-class :force BufferGeom;
load-class :force BufferBase;
load-class :force EditBuffer;
load-class :force ScratchBuffer;
load-class :force Window;
load-class :force WindowBase;
load-class :force WUtil;

defun pmacs (trace: t) {
    if {true? t} {
	f := `File ("./trace.pmacs" mode: o);
	trace 1 out: [$f fd?];
    };
    
    try {
	defvar MainWindow [new Window init: ([curs-init])];
	BufferManager init;
	WUtil init;
	$MainWindow create-minibuffer-window;

	$MainWindow create-full-window;
	$MainWindow add-create-window-hook {$MainWindow create-full-window};
	# $MainWindow create-split-cross-window;
	# $MainWindow add-create-window-hook  {$MainWindow create-split-cross-window};
	
	# $MainWindow create-split-vertical-window;
        # $MainWindow create-split-vertical-window div: 3;
	# $MainWindow create-split-horizontal-window;
	# $MainWindow create-split-horizontal-window div: 3;

        # $MainWindow display-window-message "MiniBuffer" "Hello";
	# $MainWindow display-window-message "Window#1" "Hello Window#1\nabcdeあいうえお";
	# $MainWindow display-window-message "Window#2" "Hello Window#2\nabcdeあいうえお";
	# $MainWindow display-window-message "Window#3" "Hello Window#3\nabcdeあいうえお";
	# $MainWindow display-window-message "Window#1" [$MainWindow get WindowList : string];

	# USE CASE: "file open"
	b ::= new EditBuffer;
	$b load-content "/home/mit-sato/perfume/eval.c";
	$MainWindow bind-buffer "Window#1" $b;

	b ::= new EditBuffer;
	$b load-content "/home/mit-sato/perfume/methods.c";
	# $MainWindow bind-buffer "Window#2" $b;

	b ::= new EditBuffer;
	$b load-content "/home/mit-sato/perfume/testfile";
	# $MainWindow bind-buffer "Window#3" $b;

	b ::= new EditBuffer;
	$b load-content "/home/mit-sato/eval.c";
	# $MainWindow bind-buffer "Window#4" $b;

	$MainWindow render-all;
	$MainWindow refresh;
	sleep 1000;

REM {
	1 each to: 10 do: {
		$MainWindow roll-current-window;
		$MainWindow render-all;
		$MainWindow refresh;
		sleep 500;
	};
};

        key := "";

	while {true} do: {
	    i ::= curs-keyin [$MainWindow get-current-window : get-curs] 100 $INPUT_ENCODING;
	    if {$i null?} {continue};
	    if {[$key len] > 80} {key := ""; };
	    $key append! ["" . [[integer? $i] ??? ["%02x" fmt $i] [result $i]] " "];
	    $MainWindow display-window-message "MiniBuffer" ["%-100v" fmt $key];
	    $MainWindow refresh;

	    $i each do: {| k |
		cond
		{eq? $k KEY_F1} {
		    $MainWindow roll-current-window;
		    $MainWindow apply {render-all; refresh};
		}
		{eq? $k KEY_NPAGE} {
		    $MainWindow get-current-window : page-down;
		    $MainWindow get-current-window : apply {render; set-cursor; refresh};
		}
		{eq? $k KEY_PPAGE} {
		    $MainWindow get-current-window : page-up;
		    $MainWindow get-current-window : apply {render; set-cursor; refresh};		    
		}
		{eq? $k KEY_DOWN} {
		    $MainWindow get-current-window : move-down;
		    $MainWindow get-current-window : apply {render; set-cursor; refresh};
		}
		{eq? $k KEY_UP} {
		    $MainWindow get-current-window : move-up;
		    $MainWindow get-current-window : apply {render; set-cursor; refresh};
		}
		{eq? $k KEY_RIGHT} {
		    $MainWindow get-current-window : move-right;
		    $MainWindow get-current-window : apply {render; set-cursor; refresh};
		}
		{eq? $k KEY_LEFT} {
		    $MainWindow get-current-window : move-left;
		    $MainWindow get-current-window : apply {render; set-cursor; refresh};
		}
		{eq? $k KEY_F12} {
		    $MainWindow roll-buffer;
		    $MainWindow get-current-window : apply {render; set-cursor; refresh};
		}
		{eq? $k KEY_RESIZE} {
		    $MainWindow resize-window;
		    $MainWindow apply {render-all; refresh};
		}
		{eq? $k KEY_F2} {
		    $MainWindow add-create-window-hook {$MainWindow create-full-window};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F3} {
		    $MainWindow add-create-window-hook {$MainWindow create-split-vertical-window};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F4} {
		    $MainWindow add-create-window-hook {$MainWindow create-split-vertical-window div: 3};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F5} {
		    $MainWindow add-create-window-hook {$MainWindow create-split-vertical-window div: 4};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F6} {
		    $MainWindow add-create-window-hook {$MainWindow create-split-horizontal-window};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F7} {
		    $MainWindow add-create-window-hook {$MainWindow create-split-horizontal-window div: 3};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F8} {
		    $MainWindow add-create-window-hook {$MainWindow create-split-horizontal-window div: 4};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F9} {
		    $MainWindow add-create-window-hook {$MainWindow create-split-cross-window};
		    $MainWindow apply {resize-window; render-all; refresh};
		}
		{eq? $k KEY_F11} {
		    w ::= $MainWindow get-current-window;
		    debug-message [BufferManager get-buffer-geom [$w get-window-name]
				    [$w get-buffer : get-buffer-name] : string];
		}
		;
	    };
	};

REM {
	$MainWindow roll-current-window;
	$MainWindow roll-current-window;
	$MainWindow bind-buffer
	    [$MainWindow get-current-window : get-window-name]
	    [BufferManager get-buffer "eval.c[2]"];
	
	$MainWindow render-all;
	$MainWindow refresh;
	sleep 500000;
};
	
    }
    fin: {
	curs-terminate;
    }
    catch: {| e |
	__error_info__ ::= "ERROR: <%v># %v\n\n%v" fmt [$e car] [$e cdr] $@stack-trace;
    }
    ;

    if {set? __error_info__} then: {println file: $stderr $__error_info__};
};

defun debug-message (msg) {
    if $MainWindow {
	[$MainWindow get-minibuffer-window] ?? {throw ErrNoMiniBuffer "No MiniBuffer for debugging."};
	$MainWindow display-window-message "MiniBuffer" ["DEBUG(Press any key): %-80v" fmt $msg];
	$MainWindow get-minibuffer-window : refresh;
	curs-keyin [$MainWindow get-minibuffer-window : get-curs] 0 $INPUT_ENCODING;
    };
};
