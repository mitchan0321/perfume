modules := (
    BufferManager
    BufferGeom
    BufferBase
    EditBuffer
    ScratchBuffer
    Window
    WindowBase
    CombiWindow
    MiniWindow
    WUtil
);

defun pmacs (trace: t) {
    if {true? t} {
	f := `File ("./trace.pmacs" mode: o);
	trace 1 out: [$f fd?];
    };

    fun (modules) {
	$modules each do: {| m |
	    try    {load-class :force $m}
	    catch: {| e | println ["Module load error at '" . $m "', error=" $e]};
	};
    } : $modules;

    defvar stdin_orig  $stdin;
    defvar stdout_orig $stdout;
    defvar stderr_orig $stderr;

    setvar stdin  [new Stream];
    setvar stdout [new Stream];
    setvar stderr [new Stream];
    $stdin set-nolimit;
    $stdin set-comode;
    $stdout set-limit 128;
    $stdout set-itemlimit 80;
    $stdout set-comode;
    $stderr set-limit 128;
    $stderr set-itemlimit 80;
    $stderr set-comode;
    
    try {
	WUtil init;
	BufferManager init;
	curs ::= curs-init;
	defvar MainWindow [new Window init: ($curs)];
	init-color-DB;
	$MainWindow create-minibuffer-window;
	$MainWindow create-full-window;
	$MainWindow add-create-window-hook {$MainWindow create-full-window};
	$MainWindow add-background {
	    | main window |
	    $window apply-command $main $window "" bottom-of-buffer;
	    ### $window apply-command $main $window "" start-region;
	    result ALL;
	};

	$MainWindow add-background job-id: "00-start-logo" {
            buff ::= new EditBuffer;
            path := <nil>;
       	    $LIB_PATH each do: {| i |
	        if {file exists? [$i . "/pmacs.logo"]} {
		    path ::= $i . "/pmacs.logo";
	            break;
	        };
	    };
	    if $path {
		(result err) ::= $buff load-content $path;
		if $result {
		    $MainWindow bind-buffer "Window#1" $buff;
		    $MainWindow apply {render-all; refresh};
		    key := ();
		    timeout := 10000;
		    while {$key null?} do: {
			key ::= curs-keyin [$MainWindow get-current-window : get-curs] $INPUT_TIMEOUT $INPUT_ENCODING;
			$timeout -- $INPUT_TIMEOUT;
			if {$timeout < 0} {break};
		    };
		    $MainWindow unbind-buffer;
		};
	    };
	};

        if {defvar? PINTERP_LOCAL} else: {
	    defvar PINTERP_LOCAL [dict];
        };
	$MainWindow add-background job-id: "PINTERP-WATCHDOG" {
	    c ::= coro {pinterp $MainWindow};
	    $c eval {defvar CO-MODE <t>};
	    $c eval {enable-itimer};
	    set-itimer $INTERP_ITIMER_INTERVAL;
	    
	    if {defvar? PINTERP} {
		setvar PINTERP $c;
	    } {
		defvar PINTERP $c;
	    };

	    body := {| main window |
		if {eq? [$PINTERP stat] DONE} {
		    try {$PINTERP release} catch: {};
		    c ::= coro {pinterp $MainWindow};
		    $c eval {defvar CO-MODE <t>};
		    $c eval {enable-itimer};
		    setvar PINTERP $c;
		};

	        buff := <nil>;
		if $window {
		    if {eq? CombiWindow [$window get @name]} {buff ::= $window get-buffer};
		};
		if $buff {
		    if {eq? ScratchBuffer [$buff get @name]} {
			if {$window method? display-evaluation} {
			    $window display-evaluation;
			};
		    };
		};

		$MainWindow add-background job-id: "PINTERP-WATCHDOG" $body;
	    };
	    yield $body $MainWindow <nil>;
	};

	$MainWindow render-all;
	$MainWindow refresh;
	$MainWindow key-event-loop;
    }
    fin: {
	curs-terminate;
	setvar stdin  $stdin_orig;
	setvar stdout $stdout_orig;
	setvar stderr $stderr_orig;
    }
    catch: {| e |
	__error_info__ ::= "ERROR: <%v># %v\n\n%v" fmt [$e car] [$e cdr] $@stack-trace;
    }
    ;

    if {set? __error_info__} then: {println file: $stderr $__error_info__};
};

defun debug-message (msg wait: msec) {
    if $MainWindow {
	[$MainWindow get-minibuffer-window] ?? {throw ErrNoMiniBuffer "No MiniBuffer for debugging."};
	$MainWindow display-window-message "MiniBuffer" ["DEBUG: %-80v" fmt $msg];
	$MainWindow get-minibuffer-window : refresh;
	if {set? msec} {sleep $msec};
    };
};
