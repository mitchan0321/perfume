modules := (
    BufferManager
    BufferGeom
    BufferBase
    EditBuffer
    ScratchBuffer
    Window
    WindowBase
    CombiWindow
    MiniWindow
    WUtil
);

defun pmacs (trace: t) {
    if {true? t} {
	f := `File ("./trace.pmacs" mode: o);
	trace 1 out: [$f fd?];
    };

    fun (modules) {
	$modules each do: {| m |
	    try    {load-class :force $m}
	    catch: {| e | println ["Module load error at '" . $m "', error=" $e]};
	};
    } : $modules;

    defvar stdin_orig  $stdin;
    defvar stdout_orig $stdout;
    defvar stderr_orig $stderr;

    setvar stdin  [new Stream];
    setvar stdout [new Stream];
    setvar stderr [new Stream];
    $stdin set-nolimit;
    $stdout set-nolimit;
    $stderr set-nolimit;
    
    try {
	defvar MainWindow [new Window init: ([curs-init])];
	BufferManager init;
	WUtil init;
	$MainWindow create-minibuffer-window;

	$MainWindow create-full-window;
	$MainWindow add-create-window-hook {$MainWindow create-full-window};
	$MainWindow add-background {
	    | main window |
	    $window apply-command $main $window "" bottom-of-buffer;
	    $window apply-command $main $window "" start-region;
	};

	$MainWindow render-all;
	$MainWindow refresh;
	$MainWindow key-event-loop;
    }
    fin: {
	curs-terminate;
	setvar stdin  $stdin_orig;
	setvar stdout $stdout_orig;
	setvar stderr $stderr_orig;
    }
    catch: {| e |
	__error_info__ ::= "ERROR: <%v># %v\n\n%v" fmt [$e car] [$e cdr] $@stack-trace;
    }
    ;

    if {set? __error_info__} then: {println file: $stderr $__error_info__};
};

defun debug-message (msg wait: msec) {
    if $MainWindow {
	[$MainWindow get-minibuffer-window] ?? {throw ErrNoMiniBuffer "No MiniBuffer for debugging."};
	$MainWindow display-window-message "MiniBuffer" ["DEBUG: %-80v" fmt $msg];
	$MainWindow get-minibuffer-window : refresh;
	if {set? msec} {sleep $msec};
    };
};
