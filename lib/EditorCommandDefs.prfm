###
### All Pmacs editor command definition.
###

defcommand roll-current-window {
    | main window |
    $main roll-current-window;
    result ALL;
};

defcommand roll-current-window-backward {
    | main window |
    $main roll-current-window-backward;
    result ALL;
};

defcommand full-window {
    | main window |
    name ::= $window get-window-name;
    $main create-full-window window-name: $name;
    result ALL;
};

defcommand split-vertical-window {
    | main window |
    name ::= $window get-window-name;
    $main create-split-vertical-window window-name: $name;
    result ALL;
};

defcommand split-vertical-window-3 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-vertical-window window-name: $name div: 3;
    result ALL;
};

defcommand split-vertical-window-4 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-vertical-window window-name: $name div: 4;
    result ALL;
};

defcommand split-horizontal-window {
    | main window |
    name ::= $window get-window-name;
    $main create-split-horizontal-window window-name: $name;
    result ALL;
};

defcommand split-horizontal-window-3 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-horizontal-window window-name: $name div: 3;
    result ALL;
};

defcommand split-horizontal-window-4 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-horizontal-window window-name: $name div: 4;
    result ALL;
};

defcommand split-cross-window {
    | main window |
    name ::= $window get-window-name;
    $main create-split-cross-window window-name: $name;
    result ALL;
};

defcommand next-buffer {
    | main window |
    $main next-buffer;
    result ALL;
};

defcommand previous-buffer {
    | main window |
    $main previous-buffer;
    result ALL;
};

defcommand next-buffer-anothor-window {
    | main window |
    $main roll-current-window;
    $main next-buffer;
    $main roll-current-window-backward;
    result ALL;
};

defcommand previous-buffer-anothor-window {
    | main window |
    $main roll-current-window;
    $main previous-buffer;
    $main roll-current-window-backward;
    result ALL;
};

defcommand next-page {
    | main window |
    $window page-down;
    result SELF;
};

defcommand previous-page {
    | main window |
    $window page-up;
    result SELF;
};

defcommand cursor-down {
    | main window |
    $window move-down;
    result SELF;
};

defcommand cursor-up {
    | main window |
    $window move-up;
    result SELF;
};

defcommand cursor-right {
    | main window |
    $window move-right;
    result SELF;
};

defcommand cursor-left {
    | main window |
    $window move-left;
    result SELF;
};

defcommand cursor-down-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-down;
    result SELF;
};

defcommand cursor-up-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-up;
    result SELF;
};

defcommand cursor-right-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-right;
    result SELF;
};

defcommand cursor-left-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-left;
    result SELF;
};

defcommand move-half-up {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-y ::= $geom,ViewLine + [$y / 2];
    if {$new-y > [[$buff get-buffer-length] - $y : + 1]} {
        new-y ::= [$buff get-buffer-length] - $y : + 1;
    };
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;
    
    result SELF;
};

defcommand move-half-down {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-y ::= $geom,ViewLine - [$y / 2];
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;
    
    result SELF;
};

defcommand move-half-right {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn + [$x / 4];
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand move-half-left {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn - [$x / 4];
    if {$new-x < 0} {
        new-x := 0
    };
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand cursor-top-of-line {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    $window set-freecursor <nil>;
    $geom set! ViewColumn 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;
    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;    

    result SELF;
};

defcommand cursor-end-of-line {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $cy;
    if $r {
        cx ::= $r len;
    } {
        cx := 0;
    };
    (line col) ::= $window get-cursor-index $buff $cy $cx;

    $window set-freecursor <nil>;
    $geom set! CursorColumn [$col - $geom,ViewColumn];
    $geom set! IndexColumn.SAVE $col;
    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    
    result SELF;
};

defcommand smooth-scroll-down {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    (y x) ::= $window get-screen-size;
    acc ::= 1 * $KEY_REPEAT_ACCEL;
    new-y ::= $geom,ViewLine + $acc;
    if {$new-y > [[$buff get-buffer-length] - $y : + 1]} {
        new-y ::= [$buff get-buffer-length] - $y : + 1;
    };
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;

    result SELF;
};

defcommand smooth-scroll-up {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    (y x) ::= $window get-screen-size;
    acc ::= 1 * $KEY_REPEAT_ACCEL;
    new-y ::= $geom,ViewLine - $acc;
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;

    result SELF;
};

defcommand smooth-scroll-right {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn + 4;
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand smooth-scroll-left {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn - 4;
    if {$new-x < 0} {
        new-x := 0;
    };
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand top-of-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <nil>;
    $geom set! ViewLine 0;
    $geom set! ViewColumn 0;
    $geom set! CursorLine 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;

    result SELF;
};

defcommand bottom-of-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;
    buff-len ::= $buff get-buffer-length;

    $window set-freecursor <nil>;
    $geom set! ViewLine 0;
    $geom set! ViewColumn 0;
    $geom set! CursorLine 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;
    if {$buff-len < $y} {
	$geom set! CursorLine $buff-len;
    } {
	$geom set! ViewLine [$buff-len - $y : + 1];
	$geom set! CursorLine [$y - 1];
    };
    
    result SELF;
};

defcommand fit-to-top {
    | main window |
    $window cursor-fit-to-top [$window get-geom];
    result SELF;
};

defcommand fit-to-bottom {
    | main window |
    $window cursor-fit-to-bottom [$window get-geom];
    result SELF;
};

defcommand move-screen-top {
    | main window |
    $window move-screen-top;
    result SELF;
};

defcommand move-screen-bottom {
    | main window |
    $window move-screen-bottom;
    result SELF;
};

defcommand next-page-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : page-down;
    $main roll-current-window-backward;
    result ALL;
};

defcommand previous-page-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : page-up;
    $main roll-current-window-backward;
    result ALL;
};

defcommand smooth-scroll-up-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : apply-command $main [$main get-current-window] "" smooth-scroll-up;
    $main roll-current-window-backward;
    result ALL;
};

defcommand smooth-scroll-down-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : apply-command $main [$main get-current-window] "" smooth-scroll-down;
    $main roll-current-window-backward;
    result ALL;
};

defcommand show-character-code {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    s ::= $buff get-buffer-line $cy;
    $s ?? {
	show-message "No character.";
	return SELF;
    };
    c ::= $s sub $cx [$cx + 1];
    if {$c != ""} {
	i ::= $c uexport : car;
	show-message ["Code: %v[u+%06x]" fmt $i $i];
    } {
	show-message "No character."
    };
    
    result SELF;
};

defcommand input-character-code {
    | main window |
    $main mini-input-start "" prompt: "Input character code: u+";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    try {
                i ::= ["0x" . $value] int;
            } catch: {
		show-message :bell "Bad hexadecimal.";
		return SELF;
            };
            if {or {$i < 0} {$i >= 0x200000}} {
		show-message :bell "Bad range unicode codepoint.";
		return SELF;
            };
	    $window insert-string ["" uimport! ($i)];
	};
    };
    result SELF;
};

defcommand insert-character {
    | main window key |
    $window insert-string $key;
    result ALL;
};

defcommand insert-tab {
    | main window |
    $window insert-string "\t";
    result ALL;
};

defcommand insert-return {
    | main window |
    $window insert-string "\r";
    result ALL;
};

defcommand insert-new-line {
    | main window |
    $window apply-command $main $window "" cursor-top-of-line;
    $window insert-string "\r";
    $window apply-command $main $window "" cursor-up;
    result ALL;
};

defcommand delete-character {
    | main window |
    $window delete-character;
    result ALL;
};

defcommand delete-word {
    | main window |
    if {! [$window get-region]} {
        $window apply-command $main $window "" start-region;
    };
    $window apply-command $main $window "" smart-move-forward;
    $window apply-command $main $window "" cut-region;
    result ALL;
};

defcommand delete-to-end-of-line {
    | main window |
    if {! [$window get-region]} {
        $window apply-command $main $window "" start-region;
    };
    $window apply-command $main $window "" cursor-end-of-line;
    $window apply-command $main $window "" cut-region;
    result ALL;
};

defcommand backdelete-character {
    | main window |
    $window backdelete-character;
    result ALL;
};

defcommand execute-command {
    | main window |
    $main mini-input-start "" prompt: "Perfume command: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    try {
	        result ::= $value eval;
	        show-message ["Command result: " . [$result string]];
            } catch: {| e |
		show-message :bell ["<" . [$e car ] "># " [$e cdr]];
	    };
	};
    };
    result ALL;
};

defcommand execute-editor-command {
    | main window |
    if {defvar? EditorCommandList} 
    then: {setvar EditorCommandList ()}
    else: {defvar EditorCommandList ()};

    $main mini-input-start "" prompt: "Editor command: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    $window apply-command $main $window "" $value; 
	};
	if {or {string? $in-key} {eq? $in-key CTRL_H} {eq? $in-key KEY_BACKSPACE} {eq? $in-key KEY_DC}} {
            try {
                setvar EditorCommandList [msort [$EditorCommand keys :string : filter {| i | $i =~ [$value rquote]}]];
            } catch: {
                setvar EditorCommandList ();
            };
	    $EditorCommandList ?? {setvar EditorCommandList ()};
	};
        if {eq? $in-key CTRL_I} {
	    i ::= $EditorCommandList find $value;
	    if $i {$i ++} {i := 0};
	    c ::= $EditorCommandList get $i;
	    $c ?? {c ::= $EditorCommandList get 0};
	    $c ?? {c := $value};
	    $main mini-input-value-override $c [$c len];
	};
	if {eq? $in-key CTRL_V} {
            str ::= $window get-copy-buffer;
            if {$str != ""} {
                $main mini-input-value-override $str [$str len];
            };
	};
    };
    result ALL;
};

defcommand trace-editor-command {
    | main window |
    if {defvar? EditorCommandList} 
    then: {setvar EditorCommandList ()}
    else: {defvar EditorCommandList ()};

    $main mini-input-start "" prompt: "Trace editor command: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
            f := `File("pmacs-command-trace.txt" mode: a);
            $f puts  "";
            $f puts  "***";
            $f puts  "***";
            $f puts ["*** Editor command: " . $value];
            err := <nil>;
	    try {
                trace {$window apply-command $main $window "" $value} out: [$f fd?];
            } catch: {| err |};
            if $err {
                $f puts ["ERROR: " $err];
            };
            $f puts  "***";
            $f puts  "";
            $f close;
            show-message ["Wrote tracefile to: " . [pwd] "/" "pmacs-command-trace.txt"];
	};
	if {or {string? $in-key} {eq? $in-key CTRL_H} {eq? $in-key KEY_BACKSPACE} {eq? $in-key KEY_DC}} {
            try {
                setvar EditorCommandList [msort [$EditorCommand keys :string : filter {| i | $i =~ [$value rquote]}]];
            } catch: {
                setvar EditorCommandList ();
            };
	    $EditorCommandList ?? {setvar EditorCommandList ()};
	};
        if {eq? $in-key CTRL_I} {
	    i ::= $EditorCommandList find $value;
	    if $i {$i ++} {i := 0};
	    c ::= $EditorCommandList get $i;
	    $c ?? {c ::= $EditorCommandList get 0};
	    $c ?? {c := $value};
	    $main mini-input-value-override $c [$c len];
	};
	if {eq? $in-key CTRL_V} {
            str ::= $window get-copy-buffer;
            if {$str != ""} {
                $main mini-input-value-override $str [$str len];
            };
	};
    };
    result ALL;
};

defcommand eval-region {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    $window mark;

    if [$window get-region] {
	### eval region
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $window get-region-string $sy $sx $ey $ex;
    } {
        ### eval this line
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $buff get-buffer-line $ey;
        str ::= $str ?? "";
 #       if {and {[$buff get-buffer-length : - 1] > $ey} {$str != ""}} {
 #           if {[$buff get-buffer-name] = "*Scratch*"} {
 #               $buff append-string $str;
 #           };
 #       };
    };

    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" cursor-down;

    $stdin puts $str;
    $window display-evaluation;
    
    result ALL;
};

defcommand kill-interp {
    | main window |
    if {defvar? PINTERP} {
	try {$PINTERP release} catch: {};
    };
    $stdin clear;
    $stdout clear;
    $stderr clear;
    $stderr puts "Interpriter killed.";
    result ALL;
};

defcommand send-eof {
    | main window |
    $stderr puts "Send eof.";
    $stdin close;
    result ALL;
};

defcommand refresh-screen {
    | main window |
    $main refresh-screen;
    result ALL;
};

defcommand flash {
    | main window |
    curs-flash;
    result ALL;
};

defcommand open-file {
    | main window |
    $main mini-input-start [get-current-buffer-dir $window : . "/"] prompt: "Open file: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	    BufferManager unregist-buffer "*Directory*";	
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    if {[$value len] = 0} {
		show-message :bell "No file name specified.";
                BufferManager unregist-buffer "*Directory*";
		return SELF;
	    };
            path ::= path-adjust [
		{[$value sub 0 1] = "/"} ???
		    $value
		    [get-current-buffer-dir $window : . "/" $value]
	    ];
	    buff ::= BufferManager get-buffer-by-path $path;
            if $buff {
		$MainWindow bind-buffer [$window get-window-name] $buff;
                BufferManager unregist-buffer "*Directory*";
		return SELF;
            };
            if {file dir? $path} {
                dired-open $main $window $path;
                return ALL;
            };
	    buff ::= new EditBuffer;
	    (result err) ::= $buff load-content $path;
	    $MainWindow bind-buffer [$window get-window-name] $buff;
	    $result ?? {show-message :bell ["Open Failed, path: " . $value " ("  $err ")"]};
	    BufferManager unregist-buffer "*Directory*";
	};
	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand view-file {
    | main window |
    $main mini-input-start [get-current-buffer-dir $window : . "/"] prompt: "View file: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	    BufferManager unregist-buffer "*Directory*";	
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    if {[$value len] = 0} {
		show-message :bell "No file name specified.";
                BufferManager unregist-buffer "*Directory*";
		return SELF;
	    };
            path ::= path-adjust [
		{[$value sub 0 1] = "/"} ???
		    $value
		    [get-current-buffer-dir $window : . "/" $value]
	    ];
	    buff ::= BufferManager get-buffer-by-path $path;
            if $buff {
                $buff set-protect;
		$MainWindow bind-buffer [$window get-window-name] $buff;
                BufferManager unregist-buffer "*Directory*";
		return SELF;
            };
            if {file dir? $path} {
                dired-open $main $window $path;
                return ALL;
            };
	    buff ::= new EditBuffer;
	    (result err) ::= $buff load-content $path;
            $buff set-protect;
	    $MainWindow bind-buffer [$window get-window-name] $buff;
	    $result ?? {show-message :bell ["Open Failed, path: " . $value " ("  $err ")"]};
	    BufferManager unregist-buffer "*Directory*";
	};
	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand read-file {
    | main window |
    $main mini-input-start [get-current-buffer-dir $window : . "/"] prompt: "Read file: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	    BufferManager unregist-buffer "*Directory*";	
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    if {[$value len] = 0} {
		show-message :bell "No file name specified.";
                BufferManager unregist-buffer "*Directory*";
		return SELF;
	    };
            path ::= path-adjust [
		{[$value sub 0 1] = "/"} ???
		    $value
		    [get-current-buffer-dir $window : . "/" $value]
	    ];
	    buff ::= $window get-buffer;
            geom ::= $window get-geom;
            $buff ?? {
                show-message :bell "No buffer.";
                result SELF;
            };
            f := <nil>;
            try {
                f ::= new File init: ($path mode: i);
                (line col) ::= $window get-source-index $buff $geom;
                $f each do: {| r |
                    $buff insert-string-at [$r . "\r"] $line 0;
                    $line ++;
                };
                $window cursor-move-to $geom $line 0;
            }
            catch: {| e |
                show-message :bell ["File read error, " . [$e cdr]];
                return SELF;
            }
            fin: {
                if $f {$f close};
                BufferManager unregist-buffer "*Directory*";
            };
	};
	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand save-buffer {
    | main window |
    __buff_in_clojure__ ::= $window get-buffer;
    path ::= $__buff_in_clojure__ get-path;

    if {or {nil? $path} {$path = ""}} {
	$main mini-input-start [get-current-buffer-dir $window : . "/"] prompt: "Save file name: ";
	$main add-mini-input-callback $window {| main window in-key value |
	    if {eq? $in-key KEY_ESC} {
		$main mini-input-end;
		show-message "Canceled.";
		BufferManager unregist-buffer "*Directory*";	
                return SELF;
	    };
	    if {eq? $in-key CTRL_I} {
                if {$value = ""} {
                    fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
                } {
                    fname ::= show-files-in-window $main $window $value;
                };
	        $window apply-command $main $window "" top-of-buffer;
		$main mini-input-value-override $fname [$fname len];
		return ALL;
	    };
	    if {eq? $in-key KEY_DOWN} {
		$window apply-command $main $window "" move-half-up;
		return SELF;
	    };
	    if {eq? $in-key KEY_UP} {
		$window apply-command $main $window "" move-half-down;
		return SELF;
	    };
	    if {eq? $in-key CTRL_M} {
		$main mini-input-end;
		path ::= path-adjust [
                    {[$value sub 0 1] = "/"} ???
                        $value
                        [get-current-buffer-dir $window : . "/" $value]
                ];

		if [file exists? $path] {
		    $main mini-input-start "" prompt: "File already exist, overwrite? [yes or ESC]: ";
		    $main add-mini-input-callback $window {| main window in-key value |
			if {eq? $in-key KEY_ESC} {
			    $main mini-input-end;
			    show-message "Canceled.";
			    BufferManager unregist-buffer "*Directory*";
			    return SELF;
			};
			if {and {eq? $in-key CTRL_M} {eq? $value "yes"}} {
			    $main mini-input-end;
			    (result err) ::= $__buff_in_clojure__ save-content path: $path;
			    if $result {
				show-message "Save Done.";
			    } {
				show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
			    };
			    BufferManager unregist-buffer "*Directory*";
			    $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
			    return SELF;
			};
		    };
		} {
		    $main mini-input-end;
		    (result err) ::= $__buff_in_clojure__ save-content path: $path;
		    if $result {
			show-message "Save Done.";
		    } {
			show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
		    };
		    BufferManager unregist-buffer "*Directory*";
		    $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;		    
		    return SELF;
		};
	    };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return SELF;
            };
	};
	return SELF
    };

    if [$__buff_in_clojure__ modified-by-another-process] {
        show-message "" :bell;
        $main mini-input-start "" prompt: ["Maybe this file modified by anothor process. Really save file? (" . $path ") [yes or ESC]: "];
        $main add-mini-input-callback $window {| main window in-key value |
            if {eq? $in-key KEY_ESC} {
                $main mini-input-end;
                show-message "Canceled.";
                BufferManager unregist-buffer "*Directory*";
                return SELF;
            };
            if {and {eq? $in-key CTRL_M} {eq? $value "yes"}} {
                $main mini-input-end;
                (result err) ::= $__buff_in_clojure__ save-content;
                if $result {
                    show-message "Save Done.";
                } {
                    show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
                };
                return SELF;
                BufferManager unregist-buffer "*Directory*";
            };
        };
        result SELF;
    } {
        $main mini-input-start "" prompt: ["Save file? (" . $path ") [y/n]: "];
        $main add-mini-input-callback $window {| main window in-key value |
            if {or {eq? $in-key KEY_ESC} {eq? $value "n"} {eq? $value "N"}} {
                $main mini-input-end;
                show-message "Canceled.";
                BufferManager unregist-buffer "*Directory*";
                return SELF;
            };
            if {or {$value = "y"} {$value = "Y"}} {
                $main mini-input-end;
                (result err) ::= $__buff_in_clojure__ save-content;
                if $result {
                    show-message "Save Done.";
                } {
                    show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
                };
                return SELF;
                BufferManager unregist-buffer "*Directory*";
            };
        };
        result SELF;
    };
};

defcommand save-buffer-as {
    | main window |
    __buff_in_clojure__ ::= $window get-buffer;
    path ::= $__buff_in_clojure__ get-path;

    $main mini-input-start [get-current-buffer-dir $window : . "/"] prompt: "Save file name: ";
    $main add-mini-input-callback $window {| main window in-key value |
	if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	    BufferManager unregist-buffer "*Directory*";	
            return SELF;
	};
	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    path ::= path-adjust [
                {[$value sub 0 1] = "/"} ???
		    $value
                    [get-current-buffer-dir $window : . "/" $value]
            ];

	    if [file exists? $path] {
	       $main mini-input-start "" prompt: "File already exist, overwrite? [yes or ESC]: ";
	       $main add-mini-input-callback $window {| main window in-key value |
		   if {eq? $in-key KEY_ESC} {
		       $main mini-input-end;
		       show-message "Canceled.";
		       BufferManager unregist-buffer "*Directory*";
		       return SELF;
		   };
		   if {and {eq? $in-key CTRL_M} {eq? $value "yes"}} {
		       $main mini-input-end;
		       (result err) ::= $__buff_in_clojure__ save-content path: $path;
		       if $result {
			   show-message "Save Done.";
		       } {
			   show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
		       };
		       BufferManager unregist-buffer "*Directory*";
		       $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
		       return SELF;
		   };
	       };
	    } {
		$main mini-input-end;
		(result err) ::= $__buff_in_clojure__ save-content path: $path;
		if $result {
		    show-message "Save Done.";
		    } {
		show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
		};
		BufferManager unregist-buffer "*Directory*";
		$MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
		return SELF;
	    };
	};
        if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand kill-buffer {
    | main window |
    buff ::= $window get-buffer;
    if [$buff modify?] {
	$main mini-input-start "" prompt: "This buffer is modified, really kill? [yes or ESC]: ";
	$main add-mini-input-callback $window {| main window in-key value |
	    if {eq? $in-key KEY_ESC} {
		$main mini-input-end;
		show-message "Canceled.";
		return ALL;
	    };
	    if {and {eq? $in-key CTRL_M} {eq? $value "yes"}} {
		$main mini-input-end;
		$main unbind-buffer;
		return ALL;
	    };
	};
	return ALL;
    };
    $main unbind-buffer;
    result ALL;
};

defcommand key-binding-list {
    | main window |
    mode ::= $window get-mode;
    BufferManager unregist-buffer "*Key Binding*";
    buff ::= new EditBuffer;
    $buff load-content "key binding" :init-only buffer-name: "*Key Binding*";
    $buff set-content [$DEFAULT_PWIKI_DIR . "/"];
    $buff clear-all;

    $buff append-string "<<< Key bindings >>>";
    $buff append-string ["Buffer mode: " . $mode];
    $buff append-string "";
    $buff append-string ["%-15v %28v %-v" fmt  "Key group"     "Key modifier"  "Command"];
    $buff append-string ["%-15v %28v %-v" fmt ["-" repeat 15] ["-" repeat 28] ["-" repeat 38]];
    d ::= $window get KeyBinding;
    desc ::= $window get KeyDesc;
    l := ();
    $d each do: {| k v |
	if {nil? $v} {continue};
        if [$desc set? $k] {
            s ::= $desc get $k;
            ls ::= $s split;
            grp ::= $ls get 0;
            modify ::= $ls get 1;
            $l << ["%-18v%26v [[%-v]]" fmt $grp $modify $v];
        } {
            $l << ["%-18v%26v [[%-v]]" fmt "***" $k $v];
        };
    };
    msort $l : each do: {| i |
	$buff append-string $i;
    };
    
    $buff append-string "";
    $buff append-string "<<< All editor commands >>>";
    msort [$EditorCommand keys :string] : each do: {| i |
        $buff append-string ["[[" . $i "]]"];
    };
    $buff no-modify;
    $buff set-protect;
    
    $main bind-buffer [$window get-window-name] $buff;
    $window set-mode "PWiki";

    result SELF;
};

defcommand buffer-list {
    | main window |
    BufferManager unregist-buffer "*Buffer List*";
    buff ::= new EditBuffer;
    $buff load-content "buffer list" :init-only buffer-name: "*Buffer List*";
    $main bind-buffer [$window get-window-name] $buff;
    $buff set-raise-low;
    $buff clear-all;

    $buff append-string "<<< Buffer list >>>";
    $buff append-string "  * If you want to select the buffer, move cursor to buffer line and press Enter key.";
    $buff append-string "";
    $buff append-string ["%1v%1v%1v %-26v %6v %-6v %-v" fmt "p" "m" "n" "Buffer name" "Length" "Mode" "Content path"];
    $buff append-string ["%1v%1v%1v %-26v %6v %-6v %-v" fmt "-" "-" "-" "-----------" "------" "----" "------------"];
    ### l ::= BufferManager get-buffer-list;
    l ::= BufferManager get-buffer-list-order-by-newer;
    $l each do: {| buff-name |
	display-buffer ::= BufferManager get-buffer $buff-name;
	$buff append-string [
	    "%1v%1v%1v %-26v %6d %-6v %-v" fmt
	    [[$display-buffer protect?] ??? "%" " "]
	    [[$display-buffer modify?]  ??? "*" " "]
	    [[$display-buffer newfile?] ??? "?" " "]
	    ["<" . $buff-name ">"]
	    [$display-buffer get-buffer-length]
            [$display-buffer get-buffer-mode]
	    [$display-buffer get-content]
	];
    };
    $buff no-modify;
    $buff set-protect;
    result SELF;
};

defcommand jump-to-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (line col) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $line;
    $r ?? {
	show-message :bell "No buffer name specified.";
	return SELF;
    };
    l ::= $r =~ '\<[^\>]+\>';
    if {nil? $l} {
	show-message :bell "No buffer name specified.";
	return SELF;
    };

    s ::= $l car : get 2;
    s ::= $s sub 1 [$s len : - 1];
    target-buff ::= BufferManager find-buffer $s;
    $target-buff ?? {
	show-message :bell "No buffer name specified.";
	return SELF;
    };
    $main bind-buffer [$window get-window-name] $target-buff;
    result SELF;
};

defcommand undo-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (new-y new-x) ::= $buff undo;
    if [$buff undo-empty?] {$buff no-modify};
    $new-y ?? {
        ###$buff no-modify;
	show-message :bell "Undo buffer is empty.";
	return SELF;
    };
    (line col) ::= $window get-cursor-index $buff $new-y $new-x;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand redo-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (new-y new-x) ::= $buff redo;
    $new-y ?? {
	show-message :bell "Redo buffer is empty.";
	return SELF;
    };
    (line col) ::= $window get-cursor-index $buff $new-y $new-x;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand start-region {
    | main window |
    buff ::= $window get-buffer;
    if [$window get-region] {
	show-message "End region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    $window start-region $cy $cx;
    show-message "Start region.";
    result SELF;
};

defcommand copy-region {
    | main window |
    buff ::= $window get-buffer;
    [$window get-region] ?? {
	show-message :bell "Not start region. Press Ctrl+[SPACE] to start region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    $window copy-region $sy $sx $ey $ex;
    show-message "Copied.";
    result SELF;
};

defcommand cut-region {
    | main window |
    buff ::= $window get-buffer;
    [$window get-region] ?? {
	show-message :bell "Not start region. Press Ctrl+[SPACE] to start region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    (line col) ::= $window cut-region $sy $sx $ey $ex;
    (line col) ::= $window get-cursor-index $buff $line $col;
    show-message "Cut.";
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand select-region-all {
    | main window |
    $window mark;
    if {$window get-region} {
        $window apply-command $main $window "" start-region;
    };
    $window apply-command $main $window "" top-of-buffer;
    $window apply-command $main $window "" start-region;
    $window apply-command $main $window "" bottom-of-buffer;
    result ALL;
};

defcommand select-region-paragraph {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    $window mark;
    $window apply-command $main $window "" cursor-top-of-line;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    r ::= $r ?? "";
    if {or {[$r at 0] = " "} {[$r at 0] = ""} {[$r at 0] = "\t"}} {
        $window apply-command $main $window "" move-previous-paragraph;
    };
    if {! [$window get-region]} {
        $window apply-command $main $window "" start-region;
    };
    $window apply-command $main $window "" move-next-paragraph;
    $window apply-command $main $window "" cursor-down;
    result SELF;
};

defcommand paste-buffer {
    | main window |
    buff ::= $window get-buffer;
    str ::= $window get-copy-buffer;
    if {$str = ""} {
	show-message :bell "Copy buffer is empty.";
	return SELF;
    };
    geom ::= $window get-geom;
    if [$window get-region] {
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        (line col) ::= $window delete-region $sy $sx $ey $ex;
    };
    (sy sx) ::= $window get-source-index $buff $geom;
    (cy cx) ::= $buff insert-string-at $str $sy $sx;
    show-message "Paste.";
    (line col) ::= $window get-cursor-index $buff $cy $cx;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand search-forward {
    | main window |
    return [search-sub $main $window <t>];
};

defcommand search-backward {
    | main window |
    return [search-sub $main $window <nil>];
};

defun search-prompt (dir mode) {
    $dir ??? ["Search " . $mode " [forward]: "] ["Search " . $mode " [backward]: "];
};

defun search-sub (main window dir) {
    __buff_in_clojure__ ::= $window get-buffer;

    str := "";
    if [$window get-region] {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        $window copy-region $sy $sx $ey $ex;
        str ::= $window get-copy-buffer;
        setvar SearchString $str;
    };

    $window start-search;
    $main mini-input-start $str prompt: [search-prompt $dir $SEARCH_MODE];
    $window reset-search;
    $window set-search-result [$__buff_in_clojure__ search $str];
    $window stay-search;
    if {$str != ""} {
        $main send-key-event (KEY_UP);
    };

    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    $window cancel-search $value;
	    show-message "Search canceled.";
	    return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    $window end-search $value;
	    show-message "Search complite.";
	    return SELF;	    
	};
	if {eq? $in-key KEY_DOWN} {
	    $window move-to-next-search;
	};
	if {eq? $in-key KEY_UP} {
	    $window move-to-previous-search;
	};
	if {eq? $in-key KEY_SF} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-down;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorLine [$geom,CursorLine - [$ey - $sy]];
	    $window stay-search;
	};
	if {eq? $in-key KEY_SR} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-up;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorLine [$geom,CursorLine - [$ey - $sy]];
	    $window stay-search;
	};
	if {eq? $in-key KEY_SRIGHT} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-right;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorColumn [$geom,CursorColumn - [$ex - $sx]];
	    $window stay-search;
	};
	if {eq? $in-key KEY_SLEFT} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-left;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorColumn [$geom,CursorColumn - [$ex - $sx]];
	    $window stay-search;
	};
	if {eq? $in-key CTRL_F} {
	    str ::= $window get-search-string;
	    if [$value = ""] {
                $main mini-input-value-override $str [$str len];
                $window set-search-result [$__buff_in_clojure__ search $str];
            } {
                $window set-search-result [$__buff_in_clojure__ search $value];
            };
	    $window stay-search;
            $main send-key-event (KEY_DOWN);
	};
	if {eq? $in-key CTRL_R} {
	    str ::= $window get-search-string;
	    if [$value = ""] {
                $main mini-input-value-override $str [$str len];
                $window set-search-result [$__buff_in_clojure__ search $str];
            } {
                $window set-search-result [$__buff_in_clojure__ search $value];
            };
	    $window stay-search;
            $main send-key-event (KEY_UP);
	};
	if {eq? $in-key CTRL_V} {
            str ::= $window get-copy-buffer;
            if {$str != ""} {
                $main mini-input-value-override $str [$str len];
                $window set-search-result [$__buff_in_clojure__ search $str];
                $window move-to-next-search;
            };
        };
        if {eq? $in-key CTRL_T} {
            case $SEARCH_MODE
            regex {setvar SEARCH_MODE text}
            text  {setvar SEARCH_MODE regex}
            ;;
            $MainWindow set-mini-input-prompt [search-prompt $dir $SEARCH_MODE];
      	    $window reset-search;
	    $window set-search-result [$__buff_in_clojure__ search $value];
	    $window stay-search;
            if $dir {
                $main send-key-event (KEY_DOWN);
            } {
                $main send-key-event (KEY_UP);
            };
        };
	if {or {eq? $in-key CTRL_H} {eq? $in-key KEY_DC}
	       {eq? $in-key KEY_BACKSPACE}} {
	    $window reset-search;
	    $window set-search-result [$__buff_in_clojure__ search $value];
	    $window move-to-next-search;
	};
	if {string? $in-key} {
	    $window reset-search;
	    $window set-search-result [$__buff_in_clojure__ search $value];
	    $window stay-search;
            if $dir {
                $main send-key-event (KEY_DOWN);
            } {
                $main send-key-event (KEY_UP);
            };
	};
    };
    return SELF;
};

defcommand search-next {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $window get-search-string;
    if {$str = ""} {
        show-message :bell "No set search string, execute 'search' command first.";
        return SELF;
    };
    $window mark;
    (y x) ::= case $SEARCH_MODE
        regex    {get-next-search      $ey $ex [$str rquote] $buff;}
        default: {get-next-search-text $ey $ex [$str rquote] $buff;}
    ;

    $window cursor-move-to-fit-center $geom $y $x;
    return SELF;
};

defcommand search-previous {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $window get-search-string;
    if {$str = ""} {
        show-message :bell "No set search string, execute 'search' command first.";
        return SELF;
    };
    $window mark;
    (y x) ::= case $SEARCH_MODE
        regex    {get-previous-search      $ey $ex [$str rquote] $buff;}
        default: {get-previous-search-text $ey $ex [$str rquote] $buff;}
    ;

    $window cursor-move-to-fit-center $geom $y $x;
    return SELF;
};

defun get-next-search (y x str buff) {
    r ::= $buff get-buffer-line $y;
    $r ?? {return ($y $x)};

    sl ::= $r =~ :all $str;
    if $sl {
        sl ::= $sl filter {| el | [$el get 0] > $x};
        if {$sl null?} else: {
            return ($y [$sl car : car]);
        };
    };
    
    result := <nil>;
    $buff buffer-select [$y + 1] [$buff get-buffer-length] {
        | src l |
        sl ::= $src =~ :all $str;
        if $sl {
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defun get-next-search-text (y x str buff) {
    r ::= $buff get-buffer-line $y;
    $r ?? {return ($y $x)};

    sl ::= $r =~ :all :text :nocase $str;
    if $sl {
        sl ::= $sl filter {| el | [$el get 0] > $x};
        if {$sl null?} else: {
            return ($y [$sl car : car]);
        };
    };
    
    result := <nil>;
    $buff buffer-select [$y + 1] [$buff get-buffer-length] {
        | src l |
        sl ::= $src =~ :all :text :nocase $str;
        if $sl {
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defun get-previous-search (y x str buff) {
    if {and {$y = 0} {$x = 0}} {return ($y $x)};
        
    r ::= $buff get-buffer-line $y;
    if $r {
        sl ::= $r =~ :all $str;
        if $sl {
            sl ::= $sl reverse;
            sl ::= $sl filter {| el | [$el get 0] < $x};
            if {$sl null?} else: {
                return ($y [$sl car : car]);
            };
        };
    };
    
    if {$y = 0} {return ($y $x)};
    result := <nil>;
    $buff buffer-select [$y - 1] 0 {
        | src l |
        sl ::= $src =~ :all $str;
        if $sl {
            sl ::= $sl reverse;
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defun get-previous-search-text (y x str buff) {
    if {and {$y = 0} {$x = 0}} {return ($y $x)};
        
    r ::= $buff get-buffer-line $y;
    if $r {
        sl ::= $r =~ :all :text :nocase $str;
        if $sl {
            sl ::= $sl reverse;
            sl ::= $sl filter {| el | [$el get 0] < $x};
            if {$sl null?} else: {
                return ($y [$sl car : car]);
            };
        };
    };
    
    if {$y = 0} {return ($y $x)};
    result := <nil>;
    $buff buffer-select [$y - 1] 0 {
        | src l |
        sl ::= $src =~ :all :text :nocase $str;
        if $sl {
            sl ::= $sl reverse;
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defcommand pwiki-next-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-next-search $ey $ex $PWIKI_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand pwiki-previous-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-previous-search $ey $ex $PWIKI_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand pwiki-click-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= cursor-on-search-regex $ey $ex $PWIKI_LINK $buff;
    $str ?? {
        $window apply-command $main $window "\r" insert-character;
        return ALL;
    };

    link ::= $str sub 2 [$str len : - 2];
    if {[$link at 0] = "&"} {
        ### if pwiki link form is [[&command]], execute command.
        command ::= $link sub 1;
        $window apply-command $main $window "" $command;
        return ALL;
    };
    path ::= $buff get-content;
    if {[$link at 0] = "/"} {
        dir := "";
    } {
        if $path {
            dir ::= get-dir $path;
        } {
            dir := $DEFAULT_PWIKI_DIR;
        };
    };
    
    new-path ::= [$dir = ""] ??? [$link . ".pwiki"] [path-adjust [$dir . "/" $link ".pwiki"]];
    next-buff ::= BufferManager get-buffer-by-path $new-path;
    $next-buff ?? {
        next-buff ::= new EditBuffer;
        create-directory-if-not-exists $new-path;
        (result err) ::= $next-buff load-content $new-path;
        $result ?? {
            show-message :bell ["Open Failed, path: " . $new-path " ("  $err ")"];
            return SELF;
        };
    };
    $main bind-buffer [$window get-window-name] $next-buff;
    $next-buff set-previous-buffer [$buff get-buffer-name];
    
    return ALL;
};

defun create-directory-if-not-exists (path) {
    l ::= $path split sep: "/";
    $l ->>;
    if {[$path at 0] = "/"} {$l >>};
    dir := "";
    $l each do: {| e |
        $dir append! "/";
        $dir append! $e;
        if {file dir? $dir} {continue};
        try {
            file mkdir $dir $DEFAULT_DIR_MODE;
        } catch: {| err |
            throw ErrFileAccess ["Can\'t create directory \'" . $dir "\'."];
        };
    };
};

defcommand pwiki-link-back {
    | main window |
    buff ::= $window get-buffer;
    prev-buff-name ::= $buff get-previous-buffer;
    if $prev-buff-name {
        prev-buff ::= BufferManager find-buffer $prev-buff-name;
        if $prev-buff {
            $main bind-buffer [$window get-window-name] $prev-buff;
        } {
            show-message :bell ["No found previous buffer, \'" . $prev-buff-name "\'."];
        };
    } {
        show-message :bell "No set previous buffer.";
    };
    result ALL;
};

defun cursor-on-search-regex (y x str buff) {
    r ::= $buff get-buffer-line $y;
    $r ?? {return <nil>};
    sl ::= $r =~ :all $str;
    $sl ?? {return <nil>};
    $sl each do: {| el |
        if {and {$x >= [$el get 0]} {$x < [$el get 1]}} {
            return [$el get 2];
        };
    };
    return <nil>;
};

defcommand replace-buffer {
    | main window |
    $main mini-input-start "" prompt: "Replace string: ";
    $main add-mini-input-callback $window {
        | main window in-key value |
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    froms := $value;
	    $main mini-input-start "" prompt: ["Replace string [" . $froms "] to: "];
	    $main add-mini-input-callback $window {
                | main window in-key value |
		if {eq? $in-key CTRL_M} {
		    $main mini-input-end;
                    count ::= [$window get-buffer] replace-buffer $froms $value;
                    show-message ["Replace [" . $froms "] to [" $value "] " $count " times completed."];
                    return ALL;
	        };
                if {eq? $in-key KEY_ESC} {
                    $main mini-input-end;
                    show-message "Replace canceled.";
                    return SELF;
                };
            };
        };
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
            show-message "Replace canceled.";
            return SELF;
        };
    };
    result SELF;
};

defcommand replace-region {
    | main window |
    [$window get-region] ?? {
        show-message "Please select a region first.";
        return SELF;
    };
    $main mini-input-start "" prompt: "Region replace string: ";
    $main add-mini-input-callback $window {
        | main window in-key value |
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    froms := $value;
	    $main mini-input-start "" prompt: ["Region replace string [" . $froms "] to: "];
	    $main add-mini-input-callback $window {
                | main window in-key value |
		if {eq? $in-key CTRL_M} {
		    $main mini-input-end;
                    if [$window get-region] {
                        buff ::= $window get-buffer;
                        geom ::= $window get-geom;
                        (sy sx) ::= $window end-region;
                        (ey ex) ::= $window get-source-index $buff $geom;
                    };
                    if {$sy > $ey} {(sy ey) := ($ey $sy)};
                    count ::= [$window get-buffer] replace-region $froms $value $sy $ey;
                    show-message ["Region replace [" . $froms "] to [" $value "] " $count " times completed in region (" $sy "," $ey ")."];
                    return ALL;
	        };
                if {eq? $in-key KEY_ESC} {
                    $main mini-input-end;
                    show-message "Region replace canceled.";
                    return SELF;
                };
            };
        };
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
            show-message "Region replace canceled.";
            return SELF;
        };
    };
    result SELF;
};

defcommand exit {
    | main window |
    l ::= BufferManager get-buffer-list : filter {| i | "*" != [$i at 0]};
    do_exit := <t>;
    $l each do: {| buff-name |
	buffer ::= BufferManager get-buffer $buff-name;
        if {$buffer modify?} {
	    do_exit := <nil>;
        };
    };
    if $do_exit {
        exit
    } {
        show-message :bell "CAUTION: Modified buffer is exists!! Try again after save the buffer or kill.";
    };
    
    result SELF;
};

defcommand smart-newline {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    (ey ex) ::= $window get-source-index $buff $geom;
    str-cur ::= $buff get-buffer-line $ey;
    if {and $str-cur {$ex >= [$str-cur len]}} {
        ### current line smart indent
        str-prev := "";
        if {$ey > 0} {
            str-prev ::= $buff get-buffer-line [$ey - 1];
        };
        cur-level ::= get-next-indent-count-backward $str-cur;
        if {$cur-level < 0} {
            prev-level ::= get-indent-level $str-prev;
            prev-indent ::= get-next-indent-count $str-prev;
            cur-level-count ::= $cur-level + $prev-indent;
            if [$cur-level-count < 0] {cur-level-count := -1};
            if {or {$cur-level-count < 0}
                   {and {$cur-level-count = 0} {$prev-indent > 0}}} {
                cur-indent ::= $prev-level + [$cur-level-count * $INDENT_WIDTH];
                cur-indent ::= [$cur-indent < 0] ??? 0 $cur-indent;
                new-str ::= [" " repeat $cur-indent] . [$str-cur clean];
                $buff line-update $new-str $ey;
                $geom set! IndexColumn.SAVE [$new-str len];
            };
        };
    };
    
    ### insert newline
    $window apply-command $main $window "\r" insert-character;
    
    ### next line smart indent
    (ey ex) ::= $window get-source-index $buff $geom;
    str-prev := "";
    if {$ey > 0} {
	str-prev ::= $buff get-buffer-line [$ey - 1];
    };
    cur-level ::= get-indent-level $str-prev;
    next-level-count ::= get-next-indent-count $str-prev;

    if {$cur-level > 0} {
        $window apply-command $main $window "" smart-indent;
    } {
        if {$next-level-count > 0} {
            $window apply-command $main $window "" smart-indent;
        };
    };
    
    result ALL;
};

defcommand smart-indent {
    | main window |

    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    str-prev := "";
    if {$ey > 0} {
	str-prev ::= $buff get-buffer-line [$ey - 1];
    };
    cur-level ::= get-indent-level $str-prev;
    next-level-count ::= get-next-indent-count $str-prev;
    next-level-count ::= [$next-level-count > 0] ??? 1 0;
    next-indent ::= $cur-level + [$next-level-count * $INDENT_WIDTH];
    next-level-count ::= get-next-indent-count-backward $str;
    if {$next-level-count < 0} {
        next-indent ::= $next-indent - $INDENT_WIDTH;
    };

    cur-pos ::= curs-index-to-pos $str $ex $DEFAULT_TAB_WIDTH;
    if {$cur-pos < $next-indent} {
	# smart indent
	new-str ::= [" " repeat $next-indent] . [$str clean];
        $buff line-update $new-str $ey;
        $geom set! IndexColumn.SAVE $next-indent;
    } {
	# insert indent
	in ::= $INDENT_WIDTH - [$cur-pos % $INDENT_WIDTH];
	$buff insert-string-at [" " repeat $in] $ey $ex;
        $geom set! IndexColumn.SAVE [$geom get IndexColumn.SAVE : + $in];
    };
    
    result ALL;
};

defun get-indent-level (str) {
    if {$str = ""} {return 0};

    str ::= $str . "x";
    0 each to: [$str len : - 1] do: {| i |
	c ::= $str at $i;
	if {! [or [$c = " "] [$c = "\t"]]} {break};
    };
    return [curs-index-to-pos $str $i $DEFAULT_TAB_WIDTH];
};

defun get-next-indent-count (str) {
    kakko-maru := 0; ### '(' ')' balance count
    kakko-nami := 0; ### '{' '}' balance count
    kakko-kaku := 0; ### '[' ']' balance count

    if {[[$str clean] at -1] = ":"} {return 1};
    
    [$str len : - 1] each to: 0 do: {| i |
	c ::= $str at $i;
	case $c
	  "(" {$kakko-maru ++}
	  "{" {$kakko-nami ++}
	  "[" {$kakko-kaku ++}
	  ")" {$kakko-maru --}
	  "}" {$kakko-nami --}
	  "]" {$kakko-kaku --}
	;
        if {or {$kakko-maru > 0} {$kakko-nami > 0} {$kakko-kaku > 0 }} {break};
    };

    i ::= $kakko-maru + $kakko-nami : + $kakko-kaku;
    return [cond
        {$i = 0} {break  0}
        {$i > 0} {break  1}
        {$i < 0} {break -1}
    ];
};

defun get-next-indent-count-backward (str) {
    kakko-maru := 0; ### '(' ')' balance count
    kakko-nami := 0; ### '{' '}' balance count
    kakko-kaku := 0; ### '[' ']' balance count
    
    0 each to: [$str len : - 1] do: {| i |
	c ::= $str at $i;
	case $c
	  "(" {$kakko-maru ++}
	  "{" {$kakko-nami ++}
	  "[" {$kakko-kaku ++}
	  ")" {$kakko-maru --}
	  "}" {$kakko-nami --}
	  "]" {$kakko-kaku --}
	;
        if {or {$kakko-maru < 0} {$kakko-nami < 0} {$kakko-kaku < 0 }} {break};
    };

    i ::= $kakko-maru + $kakko-nami : + $kakko-kaku;
    return [cond
        {$i = 0} {break  0}
        {$i > 0} {break  1}
        {$i < 0} {break -1}
    ];
};

defcommand smart-dedent {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    cur-level ::= get-indent-level $str;
    next-indent ::= [$cur-level / $INDENT_WIDTH] - 1 : * $INDENT_WIDTH;
    if {$next-indent < 0} {return ALL};
    new-str ::= [" " repeat $next-indent] . [$str clean];
    $buff line-update $new-str $ey;
    $geom set! IndexColumn.SAVE $next-indent;
    
    result ALL;
};

defcommand smart-move-forward {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    vec ::= $buff get-vector;
    $vec ?? {return SELF};

    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    cur-char ::= $str at $ex;
    if {or [$cur-char = ")"] [$cur-char = "]"] [$cur-char = "}"]} {
        show-message "Bracket directions are opposite.";
        $window cursor-move-to $geom $ey [$ex + 1];
        return SELF;
    };
    if {or [$cur-char = "("] [$cur-char = "["] [$cur-char = "{"]} {
        level-maru-kakko := 0;
        level-kaku-kakko := 0;
        level-nami-kakko := 0;
        case $cur-char
            "(" {fin-char := ")"; level-maru-kakko := 1}
            "[" {fin-char := "]"; level-kaku-kakko := 1}
            "{" {fin-char := "}"; level-nami-kakko := 1}
        ;
        fin := <nil>;
        dquote := <nil>;
        squote := <nil>;
        $vec each-forward-char $ey [$ex + 1] {| last-y last-x c |
            case $c
                "\"" {dquote ::= $dquote ??? <nil> <t>} ### " balanced for smart-move-*
                "\'" {squote ::= $squote ??? <nil> <t>} ### ' balanced for smart-move-*
            ;
            if {! [or $dquote $squote]} {
                case $c
                    "(" {$level-maru-kakko ++}
                    "[" {$level-kaku-kakko ++}
                    "{" {$level-nami-kakko ++}
                    ")" {
                        $level-maru-kakko --;
                        if {and [$fin-char = $c] [$level-maru-kakko = 0]} {fin := <t>};
                    }
                    "]" {
                        $level-kaku-kakko --;
                        if {and [$fin-char = $c] [$level-kaku-kakko = 0]} {fin := <t>};
                    }
                    "}" {
                        $level-nami-kakko --;
                        if {and [$fin-char = $c] [$level-nami-kakko = 0]} {fin := <t>};
                    }
                ;
            };
            if $fin {break};
        };
        if $fin {$window cursor-move-to $geom $last-y $last-x};
        if {or [$level-maru-kakko != 0] [$level-kaku-kakko != 0] [$level-nami-kakko != 0]} {
            show-message :bell ["Unbalanced brackets? " . "hint:"
                [if [$level-maru-kakko != 0] " '(' or ')', " ""]
                [if [$level-kaku-kakko != 0] " '[' or ']', " ""]
                [if [$level-nami-kakko != 0] " '{' or '}', " ""]
                " check their.";
            ];
        };
        return SELF;
    };
    
    ### otherwise
    ### move word forward
    $vec each-forward-char $ey $ex {| last-y last-x c |
        if {or 
            {$c alphanumeric?}
            {$c = "("} {$c = "["} {$c = "{"}
            {$c = ")"} {$c = "]"} {$c = "}"}
        } {break};
    };
    if {or 
        {$c = "("} {$c = "["} {$c = "{"}
        {$c = ")"} {$c = "]"} {$c = "}"}
    } {
        $window cursor-move-to $geom $last-y $last-x;
        return SELF;
    };
    
    $vec each-forward-char $last-y [$last-x + 1] {| last-y last-x c |
        if {! [$c alphanumeric?]} {break};
    };
    $window cursor-move-to $geom $last-y $last-x;

    result SELF;
};

defcommand smart-move-backward {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    vec ::= $buff get-vector;
    $vec ?? {return SELF};

    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    cur-char ::= $str at $ex;

    if {or [$cur-char = "("] [$cur-char = "["] [$cur-char = "{"]} {
        show-message "Bracket directions are opposite.";
        (ey ex) ::= $vec get-prev-pos $ey $ex;
        $window cursor-move-to $geom $ey $ex;
        return SELF;
    };
    if {or [$cur-char = ")"] [$cur-char = "]"] [$cur-char = "}"]} {
        level-maru-kakko := 0;
        level-kaku-kakko := 0;
        level-nami-kakko := 0;
        case $cur-char
            ")" {fin-char := "("; level-maru-kakko := 1}
            "]" {fin-char := "["; level-kaku-kakko := 1}
            "}" {fin-char := "{"; level-nami-kakko := 1}
        ;
        fin := <nil>;
        dquote := <nil>;
        squote := <nil>;
        (ey ex) ::= $vec get-prev-pos $ey $ex;
        $vec each-backward-char $ey $ex {| last-y last-x c |
            case $c
                "\"" {dquote ::= $dquote ??? <nil> <t>} ### " balanced for smart-move-*
                "\'" {squote ::= $squote ??? <nil> <t>} ### ' balanced for smart-move-*
            ;
            if {! [or $dquote $squote]} {
                case $c
                    ")" {$level-maru-kakko ++}
                    "]" {$level-kaku-kakko ++}
                    "}" {$level-nami-kakko ++}
                    "(" {
                        $level-maru-kakko --;
                        if {and [$fin-char = $c] [$level-maru-kakko = 0]} {fin := <t>};
                    }
                    "[" {
                        $level-kaku-kakko --;
                        if {and [$fin-char = $c] [$level-kaku-kakko = 0]} {fin := <t>};
                    }
                    "{" {
                        $level-nami-kakko --;
                        if {and [$fin-char = $c] [$level-nami-kakko = 0]} {fin := <t>};
                    }
                ;
            };
            if $fin {break};
        };
        if $fin {$window cursor-move-to $geom $last-y $last-x};
        if {or [$level-maru-kakko != 0] [$level-kaku-kakko != 0] [$level-nami-kakko != 0]} {
            show-message :bell ["Unbalanced brackets? " . "hint:"
                [if [$level-maru-kakko != 0] " '(' or ')', " ""]
                [if [$level-kaku-kakko != 0] " '[' or ']', " ""]
                [if [$level-nami-kakko != 0] " '{' or '}', " ""]
                " check their.";
            ];
        };
        return SELF;
    };
    
    ### otherwise
    ### move word backward
    (ey ex) ::= $vec get-prev-pos $ey $ex;
    $vec each-backward-char $ey $ex {| last-y last-x c |
        if {or 
            {$c alphanumeric?}
            {$c = "("} {$c = "["} {$c = "{"}
            {$c = ")"} {$c = "]"} {$c = "}"}
        } {break};
    };
    if {or 
        {$c = "("} {$c = "["} {$c = "{"}
        {$c = ")"} {$c = "]"} {$c = "}"}
    } {
        $window cursor-move-to $geom $last-y $last-x;
        return SELF;
    };
    
    (ey ex) ::= $vec get-prev-pos $last-y $last-x;
    $vec each-backward-char $ey $ex {| last-y last-x c |
        if {! [$c alphanumeric?]} {break};
    };
    if {! [and {$last-y = 0} {$last-x = 0}]} {
        (last-y last-x) ::= $vec get-next-pos $last-y $last-x;
    };
    if {$last-y < 0} {last-y := 0};
    if {$last-x < 0} {last-x := 0};
    $window cursor-move-to $geom $last-y $last-x;

    result SELF;
};

defcommand move-next-paragraph {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (line col) ::= $window get-cursor-index $buff $ey $ex;
    if {[$ey + 1] >= [$buff get-buffer-length]} {return SELF};
    find := <nil>;
    $buff buffer-select [$ey + 1] [$buff get-buffer-length : - 1] {
        | src l |
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        if {and [[$src len] > 0] [[$src at $p] != " "] [[$src at $p] != "\t"] [[$src at $p] != ""]} {
            find := <t>;
	    break;
	};
    };
    if $find {
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        $window cursor-move-to $geom $l $p;
    };
    result SELF;
};

defcommand move-previous-paragraph {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (line col) ::= $window get-cursor-index $buff $ey $ex;
    if {$ey < 1} {return SELF};
    find := <nil>;
    $buff buffer-select [$ey - 1] 0 {
        | src l |
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        if {and [[$src len] > 0] [[$src at $p] != " "] [[$src at $p] != "\t"] [[$src at $p] != ""]} {
            find := <t>;
	    break;
	};
    };
    if $find {
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        $window cursor-move-to $geom $l $p;
    };
    result SELF;
};

defcommand move-next-paragraph-fit-to-top {
    | main window |
    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" move-next-paragraph;
    $window apply-command $main $window "" fit-to-top;
    result SELF;
};

defcommand move-previous-paragraph-fit-to-top {
    | main window |
    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" move-previous-paragraph;
    $window apply-command $main $window "" fit-to-top;
    result SELF;
};

defcommand mark {
    | main window |
    $window mark;
    result SELF;
};

defcommand goto-mark {
    | main window |
    $window goto-mark;
    result SELF;
};

defcommand goto-unmark {
    | main window |
    $window unmark;
    result SELF;
};

defcommand grep {
    | main window |
    buff ::= $window get-buffer;
    dir ::= $buff get-content-dir;
    $main mini-input-start $dir prompt: "Directory: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
            $main mini-input-end;
            show-message "Canceled.";
            return SELF;
        };
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return SELF;
            };
            directory := $value;
            if {file dir? $directory} else: {
                show-message :bell ["Not directory: " . $directory];
                return SELF;
            };

            str := "";
            buff ::= $window get-buffer;
            geom ::= $window get-geom;
            if [$window get-region] {
                ### eval region
                (sy sx) ::= $window end-region;
                (ey ex) ::= $window get-source-index $buff $geom;
                str ::= $window get-region-string $sy $sx $ey $ex;
            };
            $main mini-input-start ["grep -rnHe '" . $str "' *"] prompt: "grep command line: " index: 12;
            $main add-mini-input-callback $window {| main window in-key value |
                if {eq? $in-key KEY_ESC} {
                    $main mini-input-end;
                    show-message "Canceled.";
                    return SELF;
                };
                if {eq? $in-key CTRL_M} {
                    $main mini-input-end;
                    if {[$value len] = 0} {
                        show-message :bell "No grep command line specified.";
                        return SELF;
                    };
                    cmd := $value;
                    
                    ###
                    ### do grep
                    ###
                    orig-dir ::= pwd;
                    cd $directory;
                    fout ::= new Stream;
                    $fout set-nolimit;
                    ferr ::= new Stream;
                    $ferr set-nolimit;
                    sts ::= {exec "/bin/sh" "-c" $cmd} redirect-out $fout $ferr;
                    $fout close;
                    $ferr close;
                    buff ::= new EditBuffer;
                    BufferManager unregist-buffer "*Grep*";
                    (result err) ::= $buff load-content  :init-only "grep buffer" buffer-name: "*Grep*";
                    $buff clear-all;
                    $buff append-string ["CWD:  " . $directory];
                    $buff append-string ["EXEC: " . $cmd];
                    $buff append-string "";
                    $fout each do: {| r |
                        $buff append-string $r;
                    };
                    $ferr each do: {| r |
                        $buff append-string ["ERR> " . $r];
                    };
                    $buff append-string "";
                    $buff append-string ["exit(" . $sts ")"];
                    
                    w1 ::= $main get-window-by-name "Window#1";
                    if $w1 else: {
                        $main create-split-vertical-window;
                    };
                    $main bind-buffer "Window#1" $buff;
                    window ::= $main get-window-by-name "Window#1";
                    geom ::= $window get-geom;
                    $geom set! ViewLine 0;
                    $geom set! ViewColumn 0;
                    $window cursor-move-to $geom 0 0;
                    cd $orig-dir;
                    return SELF;
                };
            };
            return SELF;
        };
	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand grep-next {
    | main window |
    grep-buff ::= BufferManager find-buffer "*Grep*";
    $grep-buff ?? {
        show-message :bell "No *Grep* buffer, execute 'grep' command first.";
        return ALL;
    };
    dir ::= chdir-cwd $grep-buff;
    
    w1 ::= $main get-window-by-name "Window#1";
    w2 ::= $main get-window-by-name "Window#2";
    if {and $w1 $w2} else: {
        $main create-split-vertical-window;
    };
    $main bind-buffer "Window#1" $grep-buff;
    grep-window ::= $main get-window-by-name "Window#1";
    grep-geom ::= $grep-window get-geom;
    (ey ex) ::= $grep-window get-source-index $grep-buff $grep-geom;
    str := <nil>;
    while {true} do: {
        $ey ++;
        str ::= $grep-buff get-buffer-line $ey;
        if {nil? $str} {
            break;
        };
        l ::= $str split sep: ":";
        f ::= $l >>;
        $f ?? {continue};
        n ::= $l >>;
        $n ?? {continue};

        if {and {$f != ""} {$n != ""} {$n numeric?}} {break};
    };
    if {$ey >= [$grep-buff get-buffer-length]} {ey ::= $grep-buff get-buffer-length : - 1};
    $window cursor-move-to-fit-center $grep-geom $ey 0;
    $window cursor-fit-to-top $grep-geom;
    $str ?? {
        show-message :bell "Bottom of *Grep* buffer.";
        return ALL;
    };

    ### show-message ["File: " . $f ", line: " $n];
    if {[$f at 0] = "/"} {
        show-file-at "Window#2" $f $n;
    } {
        show-file-at "Window#2" [$dir . $f] $n;
    };

    return ALL;
};

defcommand grep-previous {
    | main window |
    grep-buff ::= BufferManager find-buffer "*Grep*";
    $grep-buff ?? {
        show-message :bell "No *Grep* buffer, execute 'grep' command first.";
        return ALL;
    };
    dir ::= chdir-cwd $grep-buff;
    
    w1 ::= $main get-window-by-name "Window#1";
    w2 ::= $main get-window-by-name "Window#2";
    if {and $w1 $w2} else: {
        $main create-split-vertical-window;
    };
    $main bind-buffer "Window#1" $grep-buff;
    grep-window ::= $main get-window-by-name "Window#1";
    grep-geom ::= $grep-window get-geom;
    (ey ex) ::= $grep-window get-source-index $grep-buff $grep-geom;
    str := <nil>;
    while {true} do: {
        $ey --;
        str ::= $grep-buff get-buffer-line $ey;
        if {$ey < 0} {
            str := <nil>; 
            break;
        };
        if {nil? $str} {
            str := <nil>; 
            break;
        };
        l ::= $str split sep: ":";
        f ::= $l >>;
        $f ?? {continue};
        n ::= $l >>;
        $n ?? {continue};

        if {and {$f != ""} {$n != ""} {$n numeric?}} {break};
    };
    if {$ey < 0} {ey := 0};
    $window cursor-move-to-fit-center $grep-geom $ey 0;
    $window cursor-fit-to-top $grep-geom;
    $str ?? {
        show-message :bell "Top of *Grep* buffer.";
        return ALL;
    };

    ### show-message ["File: " . $f ", line: " $n];
    if {[$f at 0] = "/"} {
        show-file-at "Window#2" $f $n;
    } {
        show-file-at "Window#2" [$dir . $f] $n;
    };
    
    return ALL;
};

defun show-file-at (window-name path line) {
    buff ::= BufferManager get-buffer-by-path $path;
    $buff ?? {
        buff ::= new EditBuffer;
        (result err) ::= $buff load-content $path;
        $result ?? {
            show-message :bell ["Open Failed, path: " . $path " ("  $err ")"];
            return;
        };
    };
    $MainWindow bind-buffer $window-name $buff;
    $MainWindow roll-to-window $window-name;
    win ::= $MainWindow get-current-window;
    geom ::= $win get-geom;
    $win cursor-move-to-fit-center $geom [$line - 1] 0;
};

defun chdir-cwd (buff) {
    r ::= $buff get-buffer-line 0;
    if $r {
        l ::= $r split sep: ":";
        if {[$l len] < 2} {return "./"};
        if {[$l get 0] = "CWD"} {
            cwd ::= $l get 1;
            if $cwd {
                try {
                    result ::= $cwd clean;
                    if {[$result at -1] != "/"} {
                        $result append! "/";
                    };
                    return $result;
                } catch: {| e |
                    show-message :bell ["Bad CWD line: " . $r];
                };
            };
        };
    };
    return "./";
};

defcommand read-grep-file {
    | main window |
    $main mini-input-start [pwd : . "/"] prompt: "Read grep file: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
            $main mini-input-end;
            show-message "Canceled.";
            return SELF;
        };
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            if {[$value len] = 0} {
                show-message :bell "No grep file specified.";
                return SELF;
            };
            file := $value;
            if {file read? $file} else: {
                show-message :bell ["Not readable file: " . $file];
                return SELF;
            };
            ###
            ### do read grep file
            ###
            BufferManager unregist-buffer "*Grep*";
            buff ::= new EditBuffer;
            (result err) ::= $buff load-content $file buffer-name: "*Grep*";
            $result ?? {
                show-message :bell ["Open Failed, path: " . $file " ("  $err ")"];
                return SELF;
            };
            $main create-split-vertical-window;
            $main bind-buffer "Window#1" $buff;
            window ::= $main get-window-by-name "Window#1";
            geom ::= $window get-geom;
            $geom set! ViewLine 0;
            $geom set! ViewColumn 0;
            $window cursor-move-to $geom 0 0;
            return SELF;
        };

	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand cd {
    | main window |
    $main mini-input-start [pwd : . "/"] prompt: "Directory: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
            $main mini-input-end;
            show-message "Canceled.";
            return SELF;
        };
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return SELF;
            };
            directory := $value;
            cd $directory;
            show-message ["Current directory is: " . $directory];
            return SELF;
        };
	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand set-theme {
    | main window |
    $main mini-input-start "" prompt: "Theme: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            setvar THEME $value;
            init-color-DB;
            $window apply-command $main $window "" refresh-screen;
            return ALL;
        };
    };
    result ALL;
};

defcommand set-mode {
    | main window |
    $main mini-input-start "" prompt: "Mode: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            $window set-mode $value;
            $window apply-command $main $window "" refresh-screen;
            return ALL;
        };
    };
    result ALL;
};

defcommand goto {
    | main window |
    $main mini-input-start "" prompt: "Goto line: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            if [$value numeric?] else: {
                show-message "Enter line number.";
                return SELF;
            };
            $window mark;
            geom ::= $window get-geom;
            buff ::= $window get-buffer;
            line ::= $value int;
            if {$line > [$buff get-buffer-length]} {
                line ::= $buff get-buffer-length
            };
            $window cursor-move-to $geom $line 0;
            return ALL;
        };
        return SELF;
    };
    result SELF;
};

defcommand set-line-limit {
    | main window |
    $main mini-input-start "" prompt: [
        "Line length limit (current=" .
            [[true? INTERP_LIMIT_LEN] ??? $INTERP_LIMIT_LEN "none"] "): "
    ];
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            if {$value = ""} {
                show-message "Enter line length limit.";
                return SELF;
            };
            if [$value numeric?] else: {
                if {eq? "auto" $value} {
                    if {defvar? INTERP_LIMIT_LEN} {
                        setvar INTERP_LIMIT_LEN $value;
                    } {
                        defvar INTERP_LIMIT_LEN $value;
                    };
                } {
                    show-message "Enter line length limit.";
                };
                return SELF;
            };
            if {defvar? INTERP_LIMIT_LEN} {
                setvar INTERP_LIMIT_LEN [$value int];
            } {
                defvar INTERP_LIMIT_LEN [$value int];
            };
            return SELF;
        };
        return SELF;
    };
    result SELF;
};

defcommand set-protect {
    | main window |
    buff ::= $window get-buffer;
    $buff set-protect;
    show-message "Buffer is protected.";
    result ALL;
};

defcommand set-noprotect {
    | main window |
    buff ::= $window get-buffer;
    $buff no-protect;
    show-message "Buffer is unprotected.";
    result ALL;
};

defcommand man {
    | main window |
    str := "";
    if [$window get-region] {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $window get-region-string $sy $sx $ey $ex;
    };
    
    $main mini-input-start $str prompt: "Man topic: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return SELF;
	};
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            if {$value = ""} {
                show-message :bell "Enter man topic name.";
                return ALL;
            };
            exec-man $main $window $value;
            return ALL;
        };
    };
    return ALL;
};

defun exec-man (main window value) {
    buff-name ::= "Man=" . $value;
    man-buff ::= BufferManager find-buffer $buff-name;
    if $man-buff else: {
        os ::= new Stream;
        $os set-nolimit;
        oe ::= new Stream;
        $oe set-nolimit;
        sts ::= {exec "/bin/sh" "-c" [$MAN_PREFIX . $value]} redirect-out $os $oe;
        $os close;
        $oe close;
        
        man-buff ::= new EditBuffer;
        (result err) ::= $man-buff load-content
            :init-only
            ["man " . $value]
            buffer-name: $buff-name
        ;
        $man-buff clear-all;
        $man-buff set-content [$DEFAULT_PWIKI_DIR . "/"];
        
        $os each do: {| r |
            $man-buff append-string [curs-col $r];
        };
        $man-buff set-protect;
        $man-buff no-modify;
    };
    $main bind-buffer [$window get-window-name] $man-buff;
    geom ::= $window get-geom;
    $window cursor-move-to $geom 0 0;
};

defcommand man-click-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= cursor-on-search-regex $ey $ex $MAN_LINK $buff;
    $str ?? {
        show-message :bell "No man topic.";
        return ALL;
    };

    buff ::= $window get-buffer;
    buff-name ::= $buff get-buffer-name;
    
    topic ::= $str split sep: "(" : get 0 : lower;
    section ::= $str split sep: "(" : get 1 : at 0;
    show-message ["Man topic: " . $section " " $topic];
    exec-man $main $window [$section . " " $topic];

    next-buff ::= $window get-buffer;
    $next-buff set-previous-buffer $buff-name;

    return ALL;
};

defcommand man-link-back {
    | main window |
    buff ::= $window get-buffer;
    prev-buff-name ::= $buff get-previous-buffer;
    if $prev-buff-name {
        prev-buff ::= BufferManager find-buffer $prev-buff-name;
        if $prev-buff {
            $main bind-buffer [$window get-window-name] $prev-buff;
        } {
            show-message :bell ["No found previous buffer, \'" . $prev-buff-name "\'."];
        };
    } {
        show-message :bell "No set previous buffer.";
    };
    result ALL;
};

defcommand man-next-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-next-search $ey $ex $MAN_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand man-previous-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-previous-search $ey $ex $MAN_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand compile {
    | main window |
    $main mini-input-start [pwd : . "/"] prompt: "Directory: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
            $main mini-input-end;
            show-message "Canceled.";
            return SELF;
        };
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return SELF;
            };
            directory := $value;
            if {file dir? $directory} else: {
                show-message :bell ["Not directory: " . $directory];
                return SELF;
            };

            $main mini-input-start "make -f Makefile " prompt: "Compile: " index: 17;
            $main add-mini-input-callback $window {| main window in-key value |
                if {eq? $in-key KEY_ESC} {
                    $main mini-input-end;
                    show-message "Canceled.";
                    return SELF;
                };
                if {eq? $in-key CTRL_M} {
                    $main mini-input-end;
                    if {[$value len] = 0} {
                        show-message :bell "No compile command specified.";
                        return SELF;
                    };
                    cmd := $value;
                    
                    ###
                    ### do compile
                    ###
                    cd $directory;
                    fout ::= new Stream;
                    sts ::= {exec "/bin/sh" "-c" $cmd} redirect-out $fout $fout;
                    $fout close;
                    buff ::= new EditBuffer;
                    BufferManager unregist-buffer "*Grep*";
                    (result err) ::= $buff load-content  :init-only "grep buffer" buffer-name: "*Grep*";
                    $buff clear-all;
                    $buff append-string ["CWD:  " . $directory];
                    $buff append-string ["EXEC: " . $cmd];
                    $buff append-string "";
                    $fout each do: {| r |
                        $buff append-string $r;
                    };
                    $buff append-string "";
                    $buff append-string ["exit(" . $sts ")"];
                    
                    w1 ::= $main get-window-by-name "Window#1";
                    if $w1 else: {
                        $main create-split-vertical-window;
                    };
                    $main bind-buffer "Window#1" $buff;
                    window ::= $main get-window-by-name "Window#1";
                    geom ::= $window get-geom;
                    $geom set! ViewLine 0;
                    $geom set! ViewColumn 0;
                    $window cursor-move-to $geom 0 0;
                    return SELF;
                };
            };
            return SELF;
        };
	if {eq? $in-key CTRL_I} {
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key "/"} {
            if {[$value at -2] = "/"} {
		$main mini-input-value-override "/" 1;
            };
	    return SELF;
	};
    };
    result SELF;
};

defcommand help {
    | main window |
    help-path ::= $DEFAULT_PWIKI_DIR . "/00start.pwiki";
    buff ::= BufferManager get-buffer-by-path $help-path;
    $buff ?? {
        buff ::= new EditBuffer;
        create-directory-if-not-exists $help-path;
        (result err) ::= $buff load-content $help-path;
        $result ?? {
            show-message :bell ["Open Failed, path: " . $help-path " ("  $err ")"];
            return SELF;
        };
    };
    $main bind-buffer [$window get-window-name] $buff;
    
    return ALL;
};

defun get-shell () {
    if [and [file exec? $DEFAULT_SHELL] [! [file dir? $DEFAULT_SHELL]]] {
        return $DEFAULT_SHELL;
    };
    return $EMERGENCY_SHELL;
};

defcommand shell {
    | main window |
    $main suspend [get-shell];
    result ALL;
};

defcommand git-pull {
    | main window |
    $main suspend [get-shell] "-c" "git pull; echo '--- Press enter key to continue ---'; read";
    result ALL;
};

defcommand git-commit {
    | main window |
    $main suspend [get-shell] "-c" "git commit .; echo '--- Press enter key to continue ---'; read";
    result ALL;
};

defcommand git-push {
    | main window |
    $main suspend [get-shell] "-c" "git push; echo '--- Press enter key to continue ---'; read";
    result ALL;
};

defcommand show-font {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    curs-print [$main get-minibuffer-window : get-curs] $str $DISPLAY_ENCODING 0 0;
    result SELF;
};

defcommand show-keycode {
    | main window |
    show-message "Input key: ";
    i := ();
    while {$i null?} do: {
        (rtime i) ::= curs-keyin [$window get-curs] 1000 $INPUT_ENCODING blink: $BLINK;
    };
    m ::= "" . $i;
    k ::= $main get-keymap $i;
    if $k {
        $m append! " -> ";
        $m append! $k;
    } {
        k := $i;
    };
    $m append! " -> ";
    $m append! [$window get-keybind [$k car]];
    
    show-message $m;
    result SELF;
};

defcommand mini-move-message {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    if {and $str {[$str len] > 0}} {
        (y x) ::= $window get-screen-size;
        message ::= [" " repeat $x] . $str;
        body := {
            set message [$message sub 1];
            if {[$message len] > 0} {
                show-message $message;
                $main add-background $body after: 100;
            } {
                show-message "Done.";
            };
            return ALL;
        };
        $main add-background $body after: 100;
    };
    result SELF;
};

defcommand window-split-ratio-reset {
    | main window |
    setvar VERTICAL_DIV_RATIO 1.0;
    setvar HORIZONTAL_DIV_RATIO 1.0;
    $main refresh-screen;
    result ALL;
};

defcommand window-grow-right {
    | main window |
    if {$VERTICAL_DIV_RATIO > $DIV_RATIO_MIN} {
        setvar VERTICAL_DIV_RATIO [$VERTICAL_DIV_RATIO - $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand window-grow-left {
    | main window |
    if {$VERTICAL_DIV_RATIO < $DIV_RATIO_MAX} {
        setvar VERTICAL_DIV_RATIO [$VERTICAL_DIV_RATIO + $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand window-grow-lower {
    | main window |
    if {$HORIZONTAL_DIV_RATIO > $DIV_RATIO_MIN} {
        setvar HORIZONTAL_DIV_RATIO [$HORIZONTAL_DIV_RATIO - $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand window-grow-upper {
    | main window |
    if {$HORIZONTAL_DIV_RATIO < $DIV_RATIO_MAX} {
        setvar HORIZONTAL_DIV_RATIO [$HORIZONTAL_DIV_RATIO + $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand dired {
    | main window |
    dired-open $main $window [pwd];
    return ALL;
};

defun dired-open (main window dir) {
    buff ::= BufferManager get-buffer-by-path $dir;
    if $buff {
        $main bind-buffer [$window get-window-name] $buff;
        return $buff;
    };
    buff ::= new DiredBuffer;
    $buff load-content $dir;
    $main bind-buffer [$window get-window-name] $buff;
    return $buff;
};

defcommand dired-open {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    if $r {
        l ::= $r split sep: "|";
        if {[$l len] >= 2} {
            name ::= $l get 1;
            path ::= $buff get-path;
            if {$path = "/"} {
                path ::= path-adjust ["/" . $name];
            } {
                path ::= path-adjust [$path . "/" $name];
            };
            if {file dir? $path} {
                new-buff ::= dired-open $main $window $path;
                $new-buff set-previous-buffer [$buff get-buffer-name];
            } {
                if {file read? $path} {
                    buff ::= BufferManager get-buffer-by-path $path;
                    if $buff {
                        $main bind-buffer [$window get-window-name] $buff;
                        return SELF;
                    };
                    buff ::= new EditBuffer;
                    (result err) ::= $buff load-content $path;
                    $main bind-buffer [$window get-window-name] $buff;
                    $result ?? {show-message :bell ["Open Failed, path: " . $value " ("  $err ")"]};
                } {
                    show-message :bell "File not readable.";
                };
            };
        };
    };
    return ALL;
};

defcommand dired-link-back {
    | main window |
    buff ::= $window get-buffer;
    prev-buff-name ::= $buff get-previous-buffer;
    if $prev-buff-name {
        prev-buff ::= BufferManager find-buffer $prev-buff-name;
        if $prev-buff {
            $main bind-buffer [$window get-window-name] $prev-buff;
        } {
            show-message :bell ["No found previous buffer, \'" . $prev-buff-name "\'."];
        };
    } {
        show-message :bell "No set previous buffer.";
    };
    result ALL;
};

defcommand dired-cursor-up {
    | main window |
    $window move-up;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    if $r {
        l ::= $r split sep: "|";
        if {[$l len] >= 2} {
            $geom set! IndexColumn.SAVE [[$l get 0 : len] + 1];
            $window set-freecursor <nil>;
        };
    };
    return ALL;
};

defcommand dired-cursor-down {
    | main window |
    $window move-down;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    if $r {
        l ::= $r split sep: "|";
        if {[$l len] >= 2} {
            $geom set! IndexColumn.SAVE [[$l get 0 : len] + 1];
            $window set-freecursor <nil>;
        };
    };
    return ALL;
};

defcommand dired-sort-by-name-ascending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "n";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-name-descending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "N";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-time-ascending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "t";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-time-descending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "T";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-size-ascending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "s";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-size-descending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "S";
    $buff update;
    return ALL;
};

defcommand dired-filter {
    | main window |
    buff ::= $window get-buffer;
    $main mini-input-start [$buff get-filter : string] prompt: "Filter: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
            return ALL;
        };
        if {eq? $in-key CTRL_M} {
            $main mini-input-end;
            $buff set-filter [$value rquote];
            $buff update;
            return ALL;
        };
    };
    return ALL;
};

defcommand guru-guru {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    message := "-";
    i := 0;
    (y x) ::= $main get-screen-size;
    body := {
        set message [
            case $message
            "-"  "/"
            "/"  "|"
            "|"  "\\"
            "\\" "-"
            ;;
        ];
        show-message [[$message . " "] repeat [$x / 2]];
        $i ++;
        if {$i < 100} {
            $main add-background $body after: 100;
        };
        return ALL;
    };
    $main add-background $body after: 100;
    result SELF;
};

defcommand guru-wave {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    c := "-";
    i := 0;
    (y x) ::= $main get-screen-size;
    body := {
        set c [
            case $c
            "-"   "\\"
            "\\"  "|"
            "|"   "/"
            "/"   "-"
            ;;
        ];
        message := "";
        c1 := $c;
        1 each to: [$x / 2] do: {
            set c1 [
                case $c1
                "-"   "\\"
                "\\"  "|"
                "|"   "/"
                "/"   "-"
                ;;
            ];
            $message append! $c1 " ";
        };
        show-message $message;
        $i ++;
        if {$i < 100} {
            $main add-background $body after: 100;
        };
        return ALL;
    };
    $main add-background $body after: 100;
    result SELF;
};

defcommand guru-animal {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    c := "";
    i := 0;
    (y x) ::= $main get-screen-size;
    body := {
        set c [
            case $c
            ""  ""
            ""  ""
            ""  ""
            ""  ""
            ;;
        ];
        message := "";
        c1 := $c;
        1 each to: [$x / 2] do: {
            set c1 [
                case $c1
                ""  ""
                ""  ""
                ""  ""
                ""  ""
                ;;
            ];
            $message append! $c1 " ";
        };
        show-message $message;
        $i ++;
        if {$i < 100} {
            $main add-background $body after: 100;
        };
        return ALL;
    };
    $main add-background $body after: 100;
    result SELF;
};

defcommand test {
    | main window |
    w;
    println "";
    stack-trace : split sep: "\n" : each do: {| i | $stdout puts $i};
    println ["interp stat: " . [$PINTERP stat]];
    println ["interp busy: " . [$MainWindow is-interp-busy]];
    println "";
    println ["stdin stat:  " . [$stdin stat]];
    println ["stdout stat: " . [$stdout stat]];
    println ["stderr stat: " . [$stderr stat]];
    println "";
    slist;

    result ALL;
};

defcommand test2 {
    | main window |

    f ::= fun (l) {
        if [$l null?] else: {
            c ::= $l >>;
            show-message $c;
            $main add-background {
                $f $l;
                result ALL;
            } after: 500;
        };

    };
    $f ["abcdefghijklmnopqrstuvwxyz" split sep: ""];
    result ALL;
};

######
###### REMARK, Spare for new editor command making.
######
REM {

defcommand {
    | main window |
};

defcommand miniwindow-input-sample {
    | main window |
    $main mini-input-start "" prompt: "test prompt: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    debug-message ["input data: " . $value];
	};
    };
    result ALL;
};

##
## Nested callback sample.
## $value was save to path variable in 1st callback, because $value is override by 2nd callback.
##
defcommand nest-test {
    | main window |
    $main mini-input-start "" prompt: "test [y(es)/n(o)]";
    $main add-mini-input-callback $window {| main window in-key value |
	if {eq? $in-key "y"} {
	    $main mini-input-end;
	    path := $value;
	    $main mini-input-start "" prompt: "test 2 [o(k)/n(g)]";
	    $main add-mini-input-callback $window {| main window in-key value |
		if {eq? $in-key "o"} {
		    $main mini-input-end;
		    debug-message ["path value is: " . $path ", value is: " $value];
		};
	    };
	};
    };
};

defcommand test {
    | main window |
    # debug-message ["info local: " . [info local]] wait: 3000;
    $main mini-input-start "" prompt: "test prompt: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    debug-message ["closure: " . [info closure]];
	};
        if {eq? $in-key CTRL_I} {
	    fname ::= show-files-in-window $main $window $value;
	};
    };
    result ALL;
};

######
}; ### END REMARK
######
