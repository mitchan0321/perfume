defcommand roll-current-window
{   | main window |
    $main roll-current-window;
    result ALL;
};

defcommand full-window
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-full-window window-name: $name};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand split-vertical-window
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-split-vertical-window window-name: $name};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand split-vertical-window-3
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-split-vertical-window window-name: $name div: 3};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand split-vertical-window-4
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-split-vertical-window window-name: $name div: 4};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand split-horizontal-window
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-split-horizontal-window window-name: $name};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand split-horizontal-window-3
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-split-horizontal-window window-name: $name div: 3};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand split-horizontal-window-4
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-split-horizontal-window window-name: $name div: 4};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand split-cross-window
{   | main window |
    name ::= $window get-window-name;
    $main add-create-window-hook {$main create-split-cross-window window-name: $name};
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand next-buffer
{   | main window |
    $main next-buffer;
    result ALL;
};

defcommand previous-buffer
{   | main window |
    $main previous-buffer;
    result ALL;
};

defcommand next-page
{   | main window |
    $window page-down;
    result SELF;
};

defcommand previous-page
{   | main window |
    $window page-up;
    result SELF;
};

defcommand cursor-down
{   | main window |
    $window move-down;
    result SELF;
};

defcommand cursor-up
{   | main window |
    $window move-up;
    result SELF;
};

defcommand cursor-right
{   | main window |
    $window move-right;
    result SELF;
};

defcommand cursor-left
{   | main window |
    $window move-left;
    result SELF;
};

defcommand move-half-up
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-y ::= $geom,ViewLine + [$y / 2];
    if {$new-y > [[$buff get-buffer-length] - $y : + 1]} {new-y ::= [$buff get-buffer-length] - $y : + 1};
    if {$new-y < 0} {new-y := 0};
    $geom set! ViewLine $new-y;
    
    result SELF;
};

defcommand move-half-down
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-y ::= $geom,ViewLine - [$y / 2];
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;
    
    result SELF;
};

defcommand move-half-right
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn + [$x / 4];
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand move-half-left
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn - [$x / 4];
    if {$new-x < 0} {new-x := 0};
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand cursor-top-of-line
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    $window set-freecursor <nil>;
    $geom set! ViewColumn 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;
    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;    

    result SELF;
};

defcommand cursor-end-of-line
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    cx ::= $buff get-buffer-line $cy : len;
    (line col) ::= $window get-cursor-index $buff $cy $cx;

    $window set-freecursor <nil>;
    $geom set! CursorColumn [$col - $geom,ViewColumn];
    $geom set! IndexColumn.SAVE $col;
    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    
    result SELF;
};

defcommand smooth-scroll-down
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    (y x) ::= $window get-screen-size;
    new-y ::= $geom,ViewLine + 2;
    if {$new-y > [[$buff get-buffer-length] - $y : + 1]} {new-y ::= [$buff get-buffer-length] - $y : + 1};
    if {$new-y < 0} {new-y := 0};
    $geom set! ViewLine $new-y;

    result SELF;
};

defcommand smooth-scroll-up
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    (y x) ::= $window get-screen-size;
    new-y ::= $geom,ViewLine - 2;
    if {$new-y < 0} {new-y := 0};
    $geom set! ViewLine $new-y;

    result SELF;
};

defcommand smooth-scroll-right
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn + 2;
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand smooth-scroll-left
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn - 2;
    if {$new-x < 0} {new-x := 0};
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand top-of-buffer
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <nil>;
    $geom set! ViewLine 0;
    $geom set! ViewColumn 0;
    $geom set! CursorLine 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;

    result SELF;
};

defcommand bottom-of-buffer
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;
    buff-len ::= $buff get-buffer-length;

    $window set-freecursor <nil>;
    $geom set! ViewLine 0;
    $geom set! ViewColumn 0;
    $geom set! CursorLine 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;
    if {$buff-len < $y} {
	$geom set! CursorLine $buff-len;
    } {
	$geom set! ViewLine [$buff-len - $y : + 1];
	$geom set! CursorLine [$y - 1];
    };
    
    result SELF;
};

defcommand show-character-code
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    s ::= $buff get-buffer-line $cy;
    $s ?? {
	show-message "No character.";
	return SELF;
    };
    c ::= $s sub $cx [$cx + 1];
    if {$c != ""} {
	i ::= $c uexport : car;
	show-message ["Code: %v[u+%06x]" fmt $i $i];
    } {
	show-message "No character."
    };
    
    result SELF;
};

defcommand input-character-code
{   | main window |
    $main mini-input-start "" prompt: "Input character code: u+";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    try {i ::= ["0x" . $value] int} catch: {
		show-message "Bad hexadecimal.";
		return SELF;
	    };
	    $window insert-string ["" uimport! ($i)];
	};
    };
    result SELF;
};

defcommand insert-character
{   | main window key |
    $window insert-string $key;
    result ALL;
};

defcommand insert-tab
{   | main window |
    $window insert-string "\t";
    result ALL;
};

defcommand insert-return
{   | main window |
    $window insert-string "\r";
    result ALL;
};

defcommand delete-character
{   | main window |
    $window delete-character;
    result ALL;
};

defcommand backdelete-character
{   | main window |
    $window backdelete-character;
    result ALL;
};

defcommand execute-command
{   | main window |
    $main mini-input-start "" prompt: "Command: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    try {
	        result ::= $value eval;
	        show-message ["Command result: " . [$result string]];
            } catch: {| e |
		show-message ["<" . [$e car ] "># " [$e cdr]];
	    };
	};
    };
    result ALL;
};

defcommand execute-editor-command
{   | main window |
    if {defvar? EditorCommandList} 
    then: {setvar EditorCommandList ()}
    else: {defvar EditorCommandList ()};

    $main mini-input-start "" prompt: "Editor command: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    $window apply-command $main $window "" $value; 
	};
	if {or {string? $in-key} {eq? $in-key CTRL_H} {eq? $in-key KEY_DC}} {
	    setvar EditorCommandList [msort [$EditorCommand keys :string : filter {| i | $i =~ [$value rquote]}]];
	    $EditorCommandList ?? {setvar EditorCommandList ()};
	};
        if {eq? $in-key CTRL_I} {
	    i ::= $EditorCommandList find $value;
	    if $i {$i ++} {i := 0};
	    c ::= $EditorCommandList get $i;
	    $c ?? {c ::= $EditorCommandList get 0};
	    $c ?? {c := ""};
	    $main mini-input-value-override $c [$c len];
	};
    };
    result ALL;
};

defcommand eval-region
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    if [$window get-region] {
	### eval region
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $window get-region-string $sy $sx $ey $ex;
    } {
        ### eval this line
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $buff get-buffer-line $ey;
    };

    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" cursor-down;

    $stdin puts $str;
    $window display-evaluation;
    
    result ALL;
};

defcommand kill-interp
{   | main window |
    if {defvar? PINTERP} {
	try {$PINTERP release} catch: {};
    };
    $stdin clear;
    $stdout clear;
    $stderr clear;
    $stderr puts "Interpriter killed.";
    result ALL;
};

defcommand send-eof
{   | main window |
    $stderr puts "Send eof.";
    $stdin close;
    result ALL;
};

defcommand refresh-screen
{   | main window |
    $main wipe-window;
    $main send-key-event (KEY_RESIZE);
    result ALL;
};

defcommand flash
{   | main window |
    curs-flash;
    result ALL;
};

defcommand open-file
{   | main window |
    $main mini-input-start [pwd : . "/"] prompt: "Open file: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	    BufferManager unregist-buffer "*Directory*";	
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    if {[$value len] = 0} {
		show-message "No file name specified.";
		return SELF;
	    };
            path ::= path-adjust [
		{[$value sub 0 1] = "/"} ???
		    $value
		    [pwd : . "/" $value]
	    ];
	    buff ::= BufferManager get-buffer-by-path $path;
            if $buff {
		$MainWindow bind-buffer [$window get-window-name] $buff;
		return SELF;
            };
	    buff ::= new EditBuffer;
	    (result err) ::= $buff load-content $path;
	    $MainWindow bind-buffer [$window get-window-name] $buff;
	    $result ?? {show-message ["Open Failed, path: " . $value " ("  $err ")"]};
	    BufferManager unregist-buffer "*Directory*";
	};
	if {eq? $in-key CTRL_I} {
	    fname ::= show-files-in-window $main $window $value;
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
    };
    result SELF;
};

defcommand save-buffer
{   | main window |
    __buff_in_clojure__ ::= $window get-buffer;
    path ::= $__buff_in_clojure__ get-path;

    if {or {nil? $path} {$path = ""}} {
	$main mini-input-start [pwd : . "/"] prompt: "Save file name: ";
	$main add-mini-input-callback $window {| main window in-key value |
	    if {eq? $in-key KEY_ESC} {
		$main mini-input-end;
		show-message "Canceled.";
		BufferManager unregist-buffer "*Directory*";	
	    };
	    if {eq? $in-key CTRL_I} {
		fname ::= show-files-in-window $main $window $value;
	        $window apply-command $main $window "" top-of-buffer;
		$main mini-input-value-override $fname [$fname len];
		return ALL;
	    };
	    if {eq? $in-key KEY_DOWN} {
		$window apply-command $main $window "" move-half-up;
		return SELF;
	    };
	    if {eq? $in-key KEY_UP} {
		$window apply-command $main $window "" move-half-down;
		return SELF;
	    };
	    if {eq? $in-key CTRL_M} {
		$main mini-input-end;
		path ::= path-adjust [{[$value sub 0 1] = "/"} ???
		    $value
		    [pwd : . "/" $value]];

		if [file exists? $path] {
		    $main mini-input-start "" prompt: "File already exist, overwrite? [yes or ESC]: ";
		    $main add-mini-input-callback $window {| main window in-key value |
			if {eq? $in-key KEY_ESC} {
			    $main mini-input-end;
			    show-message "Canceled.";
			    BufferManager unregist-buffer "*Directory*";
			    return SELF;
			};
			if {and {eq? $in-key CTRL_M} {eq? $value "yes"}} {
			    $main mini-input-end;
			    (result err) ::= $__buff_in_clojure__ save-content path: $path;
			    if $result {
				show-message "Save Done.";
			    } {
				show-message ["Save Failed, path: " . $path " (" $err ")"];
			    };
			    BufferManager unregist-buffer "*Directory*";
			    $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
			    return SELF;
			};
		    };
		} {
		    $main mini-input-end;
		    (result err) ::= $__buff_in_clojure__ save-content path: $path;
		    if $result {
			show-message "Save Done.";
		    } {
			show-message ["Save Failed, path: " . $path " (" $err ")"];
		    };
		    BufferManager unregist-buffer "*Directory*";
		    $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;		    
		    return SELF;
		};
	    };
	};
	return SELF
    };

    $main mini-input-start "" prompt: ["Save file? (" . $path ") [y/n]: "];
    $main add-mini-input-callback $window {| main window in-key value |
	    if {or {eq? $in-key KEY_ESC} {eq? $value "n"} {eq? $value "N"}} {
	    $main mini-input-end;
	    show-message "Canceled.";
	    BufferManager unregist-buffer "*Directory*";	
	};
        if {or {$value = "y"} {$value = "Y"}} {
	    $main mini-input-end;
	    (result err) ::= $__buff_in_clojure__ save-content;
	    if $result {
		show-message "Save Done.";
	    } {
		show-message ["Save Failed, path: " . $path " (" $err ")"];
	    };
	    return SELF;
	    BufferManager unregist-buffer "*Directory*";	
	};
    };
    result SELF;
};

defcommand save-buffer-as
{   | main window |
    __buff_in_clojure__ ::= $window get-buffer;
    path ::= $__buff_in_clojure__ get-path;

    $main mini-input-start [pwd : . "/"] prompt: "Save file name: ";
    $main add-mini-input-callback $window {| main window in-key value |
	if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    show-message "Canceled.";
	    BufferManager unregist-buffer "*Directory*";	
	};
	if {eq? $in-key CTRL_I} {
	    fname ::= show-files-in-window $main $window $value;
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	};
	if {eq? $in-key KEY_DOWN} {
	    $window apply-command $main $window "" move-half-up;
	    return SELF;
	};
	if {eq? $in-key KEY_UP} {
	    $window apply-command $main $window "" move-half-down;
	    return SELF;
	};
	if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    path ::= path-adjust [{[$value sub 0 1] = "/"} ???
		$value
		[pwd : . "/" $value]];

	    if [file exists? $path] {
	       $main mini-input-start "" prompt: "File already exist, overwrite? [yes or ESC]: ";
	       $main add-mini-input-callback $window {| main window in-key value |
		   if {eq? $in-key KEY_ESC} {
		       $main mini-input-end;
		       show-message "Canceled.";
		       BufferManager unregist-buffer "*Directory*";
		       return SELF;
		   };
		   if {and {eq? $in-key CTRL_M} {eq? $value "yes"}} {
		       $main mini-input-end;
		       (result err) ::= $__buff_in_clojure__ save-content path: $path;
		       if $result {
			   show-message "Save Done.";
		       } {
			   show-message ["Save Failed, path: " . $path " (" $err ")"];
		       };
		       BufferManager unregist-buffer "*Directory*";
		       $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
		       return SELF;
		   };
	       };
	    } {
		$main mini-input-end;
		(result err) ::= $__buff_in_clojure__ save-content path: $path;
		if $result {
		    show-message "Save Done.";
		    } {
		show-message ["Save Failed, path: " . $path " (" $err ")"];
		};
		BufferManager unregist-buffer "*Directory*";
		$MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
		return SELF;
	    };
	};
    };
    result SELF;
};

defcommand kill-buffer
{   | main window |
    buff ::= $window get-buffer;
    if [$buff modify?] {
	$main mini-input-start "" prompt: "This buffer is modified, realy kill? [yes or ESC]: ";
	$main add-mini-input-callback $window {| main window in-key value |
	    if {eq? $in-key KEY_ESC} {
		$main mini-input-end;
		show-message "Canceled.";
		return ALL;
	    };
	    if {and {eq? $in-key CTRL_M} {eq? $value "yes"}} {
		$main mini-input-end;
		$main unbind-buffer;
		return ALL;
	    };
	};
	return ALL;
    };
    $main unbind-buffer;
    result ALL;
};

defcommand key-binding-list
{   | main window |
    BufferManager unregist-buffer "*Key Binding*";
    buff ::= new EditBuffer;
    $buff load-content "key binding" :init-only buffer-name: "*Key Binding*";
    $buff clear-all;

    $buff append-string ["%-15v\t%-v" fmt "Key" "Command"];
    $buff append-string ["%-15v\t%-v" fmt "---" "-------"];
    d ::= $window get KeyBinding;
    l := ();
    $d each do: {| k v |
	if {nil? $v} {continue};
	$l << ["%-15v\t%-v" fmt $k $v];
    };
    msort $l : each do: {| i |
	$buff append-string $i;
    };
    $buff no-modify;
    
    $main bind-buffer [$window get-window-name] $buff;
    result SELF;
};

defcommand buffer-list
{   | main window |
    BufferManager unregist-buffer "*Buffer List*";
    buff ::= new EditBuffer;
    $buff load-content "buffer list" :init-only buffer-name: "*Buffer List*";
    $buff clear-all;

    $buff append-string "<<< Hint >>>";
    $buff append-string "  If you want to select the buffer, move cursor to buffer line and press Enter key.";
    $buff append-string "";
    $buff append-string ["%1v%-3v %-26v %6v %-v" fmt "m" "n" "Buffer Name" "Length" "File Path"];
    $buff append-string ["%1v%-3v %-26v %6v %-v" fmt "-" "-" "-----------" "------" "---------"];
    l ::= BufferManager get-buffer-list;
    $l each do: {| buff-name |
	display-buffer ::= BufferManager get-buffer $buff-name;
	$buff append-string [
	    "%1v%-3v %-26v %6d %-v" fmt
	    [[$display-buffer modify?] ??? "*" " "]
	    [[$display-buffer newfile?] ??? "?" "   "]
	    ["<" . $buff-name ">"]
	    [$display-buffer get-buffer-length]
	    [$display-buffer get-path]
	];
    };
    $buff no-modify;
    
    $main bind-buffer [$window get-window-name] $buff;
    result SELF;
};

defcommand jump-to-buffer
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (line col) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $line;
    $r ?? {
	show-message "No buffer name specified.";
	return SELF;
    };
    l ::= $r =~ '\<[^\>]+\>';
    if {nil? $l} {
	show-message "No buffer name specified.";
	return SELF;
    };

    s ::= $l car : get 2;
    s ::= $s sub 1 [$s len : - 1];
    target-buff ::= BufferManager get-buffer $s;
    $target-buff ?? {
	show-message "No buffer name specified.";
	return SELF;
    };
    $main bind-buffer [$window get-window-name] $target-buff;
    result SELF;
};

defcommand undo-buffer
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (new-y new-x) ::= $buff undo;
    $new-y ?? {
	show-message "Undo buffer is empty.";
	return SELF;
    };
    (line col) ::= $window get-cursor-index $buff $new-y $new-x;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand redo-buffer
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (new-y new-x) ::= $buff redo;
    $new-y ?? {
	show-message "Redo buffer is empty.";
	return SELF;
    };
    (line col) ::= $window get-cursor-index $buff $new-y $new-x;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand start-region
{   | main window |
    buff ::= $window get-buffer;
    if [$window get-region] {
	show-message "End region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    $window start-region $cy $cx;
    show-message "Start region.";
    result SELF;
};

defcommand copy-region
{   | main window |
    buff ::= $window get-buffer;
    [$window get-region] ?? {
	show-message "Not start region. Press CTRL-SP to start region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    $window copy-region $sy $sx $ey $ex;
    show-message "Copied.";
    result SELF;
};

defcommand cut-region
{   | main window |
    buff ::= $window get-buffer;
    [$window get-region] ?? {
	show-message "Not start region. Press CTRL-SP to start region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    (line col) ::= $window cut-region $sy $sx $ey $ex;
    (line col) ::= $window get-cursor-index $buff $line $col;
    show-message "Cut.";
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand paste-buffer
{   | main window |
    buff ::= $window get-buffer;
    str ::= $window get-copy-buffer;
    if {$str = ""} {
	show-message "Copy buffer is empty.";
	return SELF;
    };
    geom ::= $window get-geom;
    (sy sx) ::= $window get-source-index $buff $geom;
    (cy cx) ::= $buff insert-string-at $str $sy $sx;
    show-message "Paste.";
    (line col) ::= $window get-cursor-index $buff $cy $cx;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand search
{   | main window |
    __buff_in_clojure__ ::= $window get-buffer;

    str := "";
    if [$window get-region] {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        $window copy-region $sy $sx $ey $ex;
        str ::= $window get-copy-buffer;
        setvar SearchString $str;
    };

    $window start-search;
    $main mini-input-start $str prompt: "Search: ";
    $window reset-search;
    $window set-search-result [$__buff_in_clojure__ search $str];
    $window stay-search;
    if {$str != ""} {
        $main send-key-event (KEY_UP);
    };

    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    $window cancel-search $value;
	    show-message "Search canceled.";
	    return SELF;
	};
        if {eq? $in-key CTRL_M} {
	    $main mini-input-end;
	    $window end-search $value;
	    show-message "Search complite.";
	    return SELF;	    
	};
	if {eq? $in-key KEY_DOWN} {
	    $window move-to-next-search;
	};
	if {eq? $in-key KEY_UP} {
	    $window move-to-previous-search;
	};
	if {eq? $in-key KEY_SF} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-down;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorLine [$geom,CursorLine - [$ey - $sy]];
	    $window stay-search;
	};
	if {eq? $in-key KEY_SR} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-up;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorLine [$geom,CursorLine - [$ey - $sy]];
	    $window stay-search;
	};
	if {eq? $in-key KEY_SRIGHT} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-right;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorColumn [$geom,CursorColumn - [$ex - $sx]];
	    $window stay-search;
	};
	if {eq? $in-key KEY_SLEFT} {
	    buff ::= $window get-buffer;
	    geom ::= $window get-geom;
	    (sy sx) ::= $window get-source-index $buff $geom;
	    $window apply-command $main $window "" smooth-scroll-left;
	    (ey ex) ::= $window get-source-index $buff $geom;
	    $geom set! CursorColumn [$geom,CursorColumn - [$ex - $sx]];
	    $window stay-search;
	};
	if {or {eq? $in-key CTRL_V} {eq? $in-key CTRL_F}} {
	    str ::= $window get-search-string;
	    $main mini-input-value-override $str [$str len];
	    $window set-search-result [$__buff_in_clojure__ search $str];
	    $window move-to-next-search;
	};
	if {or {eq? $in-key CTRL_H} {eq? $in-key KEY_DC}
	       {eq? $in-key KEY_BACKSPACE}} {
	    $window reset-search;
	    $window set-search-result [$__buff_in_clojure__ search $value];
	    $window move-to-next-search;
	};
	if {string? $in-key} {
	    $window reset-search;
	    $window set-search-result [$__buff_in_clojure__ search $value];
	    $window stay-search;
	};
    };
    result SELF;
};

defcommand exit
{   | main window |
    l ::= BufferManager get-buffer-list : filter {| i | "*" != [$i at 0]};
    do_exit := <t>;
    $l each do: {| buff-name |
	buffer ::= BufferManager get-buffer $buff-name;
        if {$buffer modify?} {
	    do_exit := <nil>;
        };
    };
    if $do_exit {exit};
    show-message "CAUTION: Modified buffer is exists!! Try again after save the buffer or kill.";
    result SELF;
};

defcommand smart-newline
{   | main window |
    $window apply-command $main $window "\r" insert-character;
    
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str-prev := "";
    if {$ey > 0} {
	str-prev ::= $buff get-buffer-line [$ey - 1];
    };
    cur-level ::= get-indent-level $str-prev;
    next-level-count ::= get-next-indent-count $str-prev;

    if {$cur-level > 0} {
        $window apply-command $main $window "" smart-indent;
    } {
        if {$next-level-count > 0} {
            $window apply-command $main $window "" smart-indent;
        };
    };
    
    result ALL;
};

defcommand smart-indent
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    str-prev := "";
    if {$ey > 0} {
	str-prev ::= $buff get-buffer-line [$ey - 1];
    };
    cur-level ::= get-indent-level $str-prev;
    next-level-count ::= get-next-indent-count $str-prev;
    next-level-count ::= [$next-level-count > 0] ??? 1 0;
    next-indent ::= $cur-level + [$next-level-count * $INDENT_WIDTH];
    next-level-count ::= get-next-indent-count $str;
    if {$next-level-count < 0} {
        next-indent ::= $next-indent - $INDENT_WIDTH;
    };
    cur-pos ::= curs-index-to-pos $str $ex $DEFAULT_TAB_WIDTH;

    if {$cur-pos < $next-indent} {
	# smart indent
	new-str ::= [" " repeat $next-indent] . [$str clean];
	$buff cut-region $ey 0 $ey [$str len];
	$buff insert-string-at $new-str $ey 0;
        $geom set! IndexColumn.SAVE $next-indent;
    } {
	# insert indent
	in ::= $INDENT_WIDTH - [$cur-pos % $INDENT_WIDTH];
	$buff insert-string-at [" " repeat $in] $ey $ex;
        $geom set! IndexColumn.SAVE [$geom get IndexColumn.SAVE : + $in];
    };
    
    result ALL;
};

defun get-indent-level (str) {
    if {$str = ""} {return 0};

    str ::= $str . "x";
    0 each to: [$str len : - 1] do: {| i |
	c ::= $str at $i;
	if {! [or [$c = " "] [$c = "\t"]]} {break};
    };
    return [curs-index-to-pos $str $i $DEFAULT_TAB_WIDTH];
};

defun get-next-indent-count (str) {
    kakko-maru := 0; ### ( ) balance count
    kakko-nami := 0; ### { } balance count
    kakko-kaku := 0; ### [ ] balance count
    
    [$str len : - 1] each to: 0 do: {| i |
	c ::= $str at $i;
	case $c
	  "(" {$kakko-maru ++}
	  "{" {$kakko-nami ++}
	  "[" {$kakko-kaku ++}
	  ")" {$kakko-maru --}
	  "}" {$kakko-nami --}
	  "]" {$kakko-kaku --}
	;
    };
    return [$kakko-maru + $kakko-nami : + $kakko-kaku];
};

defcommand smart-dedent
{   | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    str-prev := "";
    if {$ey > 0} {
	str-prev ::= $buff get-buffer-line [$ey - 1];
    };
    cur-level ::= get-indent-level $str-prev;
    next-indent ::= $cur-level - $INDENT_WIDTH;
    next-level-count ::= get-next-indent-count $str-prev;
    if {$next-level-count > 0} {
        next-indent ::= $next-indent + $INDENT_WIDTH;
    };
    next-level-count ::= get-next-indent-count $str;
    if {$next-level-count < 0} {
        next-indent ::= $next-indent - $INDENT_WIDTH;
    };
    if {$next-indent < 0} {next-indent := 0};
    
    new-str ::= [" " repeat $next-indent] . [$str clean];
    $buff cut-region $ey 0 $ey [$str len];
    $buff insert-string-at $new-str $ey 0;
    $geom set! IndexColumn.SAVE [$new-str len];
    
    result ALL;
};

defcommand test
{   | main window |
    w;
    println "";
    stack-trace : split sep: "\n" : each do: {| i | $stdout puts $i};
    println ["interp stat: " . [$PINTERP stat]];
    println ["interp busy: " . [$MainWindow is-interp-busy]];
    println "";
    println ["stdin stat:  " . [$stdin stat]];
    println ["stdout stat: " . [$stdout stat]];
    println ["stderr stat: " . [$stderr stat]];
    println "";
    slist;

    result ALL;
};

######
###### REMARK, Spare for new editor command making.
######
REM {

defcommand 
{   | main window |
};

defcommand miniwindow-input-sample
{   | main window |
    $main mini-input-start "" prompt: "test prompt: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    debug-message ["input data: " . $value];
	};
    };
    result ALL;
};

##
## Nested callback sample.
## $value was save to path variable in 1st callback, because $value is override by 2nd callback.
##
defcommand nest-test
{   | main window |
    $main mini-input-start "" prompt: "test [y(es)/n(o)]";
    $main add-mini-input-callback $window {| main window in-key value |
	if {eq? $in-key "y"} {
	    $main mini-input-end;
	    path := $value;
	    $main mini-input-start "" prompt: "test 2 [o(k)/n(g)]";
	    $main add-mini-input-callback $window {| main window in-key value |
		if {eq? $in-key "o"} {
		    $main mini-input-end;
		    debug-message ["path value is: " . $path ", value is: " $value];
		};
	    };
	};
    };
};

defcommand test
{   | main window |
#    debug-message ["info local: " . [info local]] wait: 3000;
    $main mini-input-start "" prompt: "test prompt: ";
    $main add-mini-input-callback $window {| main window in-key value |
        if {eq? $in-key KEY_ESC} {
	    $main mini-input-end;
	    debug-message ["closure: " . [info closure]];
	};
        if {eq? $in-key CTRL_I} {
	    fname ::= show-files-in-window $main $window $value;
	};
    };
    result ALL;
};

######
}; ### END REMARK
######
