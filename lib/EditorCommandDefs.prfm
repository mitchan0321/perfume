###
### All Pmacs editor command definition.
###

defcommand roll-current-window {
    | main window |
    $main roll-current-window;
    result ALL;
};

defcommand roll-current-window-backward {
    | main window |
    $main roll-current-window-backward;
    result ALL;
};

defcommand full-window {
    | main window |
    name ::= $window get-window-name;
    $main create-full-window window-name: $name;
    result ALL;
};

defcommand split-vertical-window {
    | main window |
    name ::= $window get-window-name;
    $main create-split-vertical-window window-name: $name;
    result ALL;
};

defcommand split-vertical-window-3 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-vertical-window window-name: $name div: 3;
    result ALL;
};

defcommand split-vertical-window-4 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-vertical-window window-name: $name div: 4;
    result ALL;
};

defcommand split-horizontal-window {
    | main window |
    name ::= $window get-window-name;
    $main create-split-horizontal-window window-name: $name;
    result ALL;
};

defcommand split-horizontal-window-3 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-horizontal-window window-name: $name div: 3;
    result ALL;
};

defcommand split-horizontal-window-4 {
    | main window |
    name ::= $window get-window-name;
    $main create-split-horizontal-window window-name: $name div: 4;
    result ALL;
};

defcommand split-cross-window {
    | main window |
    name ::= $window get-window-name;
    $main create-split-cross-window window-name: $name;
    result ALL;
};

defcommand next-buffer {
    | main window |
    $main next-buffer;
    result ALL;
};

defcommand previous-buffer {
    | main window |
    $main previous-buffer;
    result ALL;
};

defcommand next-buffer-anothor-window {
    | main window |
    $main roll-current-window;
    $main next-buffer;
    $main roll-current-window-backward;
    result ALL;
};

defcommand previous-buffer-anothor-window {
    | main window |
    $main roll-current-window;
    $main previous-buffer;
    $main roll-current-window-backward;
    result ALL;
};

defcommand dismiss-current-window {
    | main window |
    $window apply-command $main [$main get-current-window] "" roll-current-window-backward;
    $window apply-command $main [$main get-current-window] "" full-window;
    result ALL;
};

defcommand next-page {
    | main window |
    $window page-down;
    result SELF;
};

defcommand previous-page {
    | main window |
    $window page-up;
    result SELF;
};

defcommand cursor-down {
    | main window |
    $window move-down;
    result SELF;
};

defcommand cursor-up {
    | main window |
    $window move-up;
    result SELF;
};

defcommand cursor-right {
    | main window |
    $window move-right;
    result SELF;
};

defcommand cursor-left {
    | main window |
    $window move-left;
    result SELF;
};

defcommand cursor-down-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-down;
    result SELF;
};

defcommand cursor-up-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-up;
    result SELF;
};

defcommand cursor-right-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-right;
    result SELF;
};

defcommand cursor-left-with-region {
    | main window |

    if {! [$window get-region]} {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (cy cx) ::= $window get-source-index $buff $geom;
        $window start-region $cy $cx;
    };

    $window move-left;
    result SELF;
};

defcommand move-half-up {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-y ::= $geom,ViewLine + [$y / 2];
    if {$new-y > [[$buff get-buffer-length] - $y : + 1]} {
        new-y ::= [$buff get-buffer-length] - $y : + 1;
    };
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;
    
    result SELF;
};

defcommand move-half-down {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-y ::= $geom,ViewLine - [$y / 2];
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;
    
    result SELF;
};

defcommand move-half-right {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn + [$x / 4];
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand move-half-left {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn - [$x / 4];
    if {$new-x < 0} {
        new-x := 0
    };
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand cursor-top-of-line {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    $window set-freecursor <nil>;
    $geom set! ViewColumn 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;
    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;    

    result SELF;
};

defcommand cursor-end-of-line {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $cy;
    if $r {
        cx ::= $r len;
    } {
        cx := 0;
    };
    (line col) ::= $window get-cursor-index $buff $cy $cx;

    $window set-freecursor <nil>;
    $geom set! CursorColumn [$col - $geom,ViewColumn];
    $geom set! IndexColumn.SAVE $col;
    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    
    result SELF;
};

defcommand smooth-scroll-down {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    (y x) ::= $window get-screen-size;
    acc ::= 1 * $KEY_REPEAT_ACCEL;
    new-y ::= $geom,ViewLine + $acc;
    if {$new-y > [[$buff get-buffer-length] - $y : + 1]} {
        new-y ::= [$buff get-buffer-length] - $y : + 1;
    };
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;

    result SELF;
};

defcommand smooth-scroll-up {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    (y x) ::= $window get-screen-size;
    acc ::= 1 * $KEY_REPEAT_ACCEL;
    new-y ::= $geom,ViewLine - $acc;
    if {$new-y < 0} {
        new-y := 0;
    };
    $geom set! ViewLine $new-y;

    result SELF;
};

defcommand smooth-scroll-right {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn + 4;
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand smooth-scroll-left {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <t>;
    new-x ::= $geom,ViewColumn - 4;
    if {$new-x < 0} {
        new-x := 0;
    };
    $geom set! ViewColumn $new-x;

    result SELF;
};

defcommand top-of-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;

    $window set-freecursor <nil>;
    $geom set! ViewLine 0;
    $geom set! ViewColumn 0;
    $geom set! CursorLine 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;

    result SELF;
};

defcommand bottom-of-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-screen-size;
    buff-len ::= $buff get-buffer-length;

    $window set-freecursor <nil>;
    $geom set! ViewLine 0;
    $geom set! ViewColumn 0;
    $geom set! CursorLine 0;
    $geom set! CursorColumn 0;
    $geom set! IndexColumn.SAVE 0;
    if {$buff-len < $y} {
	$geom set! CursorLine $buff-len;
    } {
	$geom set! ViewLine [$buff-len - $y : + 1];
	$geom set! CursorLine [$y - 1];
    };
    
    result SELF;
};

defcommand fit-to-top {
    | main window |
    $window cursor-fit-to-top [$window get-geom];
    result SELF;
};

defcommand fit-to-bottom {
    | main window |
    $window cursor-fit-to-bottom [$window get-geom];
    result SELF;
};

defcommand move-screen-top {
    | main window |
    $window move-screen-top;
    result SELF;
};

defcommand move-screen-bottom {
    | main window |
    $window move-screen-bottom;
    result SELF;
};

defcommand next-page-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : page-down;
    $main roll-current-window-backward;
    result ALL;
};

defcommand previous-page-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : page-up;
    $main roll-current-window-backward;
    result ALL;
};

defcommand smooth-scroll-up-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : apply-command $main [$main get-current-window] "" smooth-scroll-up;
    $main roll-current-window-backward;
    result ALL;
};

defcommand smooth-scroll-down-anothor-window {
    | main window |
    $main roll-current-window;
    $main get-current-window : apply-command $main [$main get-current-window] "" smooth-scroll-down;
    $main roll-current-window-backward;
    result ALL;
};

defcommand show-character-code {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    s ::= $buff get-buffer-line $cy;
    $s ?? {
	show-message "No character.";
	return SELF;
    };
    c ::= $s sub $cx [$cx + 1];
    if {$c != ""} {
	i ::= $c uexport : car;
	show-message ["Code: %v[u+%06x]" fmt $i $i];
    } {
	show-message "No character."
    };
    
    result SELF;
};

defcommand input-character-code {
    | main window |

    mini-input-until-enter $main $window
        prompt: "Input character code: u+"
        enter-proc: {| value |
            try {
                i ::= ["0x" . $value] int;
            } catch: {
                show-message :bell "Bad hexadecimal.";
                return ALL;
            };
            if {or {$i < 0} {$i >= 0x200000}} {
                show-message :bell "Bad range unicode codepoint.";
                return ALL;
            };
            $window insert-string ["" uimport! ($i)];
        }
    ;;

    result SELF;
};

defcommand insert-character {
    | main window key |
    $window insert-string $key;
    result ALL;
};

defcommand insert-tab {
    | main window |
    $window insert-string "\t";
    result ALL;
};

defcommand insert-return {
    | main window |
    $window insert-string "\r";
    result ALL;
};

defcommand insert-new-line {
    | main window |
    $window apply-command $main $window "" cursor-top-of-line;
    $window insert-string "\r";
    $window apply-command $main $window "" cursor-up;
    result ALL;
};

defcommand delete-character {
    | main window |
    $window delete-character;
    result ALL;
};

defcommand delete-word {
    | main window |
    $window apply-command $main $window "" select-region-word;
    [$window in-region?] ?? {
        show-message "Word not found.";
        return ALL;
    };
    $window apply-command $main $window "" cut-region;
    result ALL;
};

defcommand delete-to-end-of-line {
    | main window |
    if {! [$window get-region]} {
        $window apply-command $main $window "" start-region;
    };
    $window apply-command $main $window "" cursor-end-of-line;
    $window apply-command $main $window "" cut-region;
    result ALL;
};

defcommand backdelete-character {
    | main window |
    $window backdelete-character;
    result ALL;
};

defcommand execute-command {
    | main window |
    
    mini-input-until-enter $main $window
        prompt: "Perfume command: "
        enter-proc: {| value |
	    try {
	        result ::= $value eval;
	        show-message ["Command result: " . [$result string]];
            } catch: {| e |
		show-message :bell ["<" . [$e car ] "># " [$e cdr]];
	    };
	}
    ;;

    result ALL;
};

defcommand execute-editor-command {
    | main window |
    if {defvar? EditorCommandList} 
    then: {setvar EditorCommandList ()}
    else: {defvar EditorCommandList ()};

    mini-input-until-enter $main $window
        prompt: "Editor command: "
        enter-proc: {| value |
	    $window apply-command $main $window "" $value; 
	}
        edit-proc: {| value |
            try {
                setvar EditorCommandList [msort [$EditorCommand keys :string : filter {| i | $i =~ [$value rquote]}]];
            } catch: {
                setvar EditorCommandList ();
            };
	    $EditorCommandList ?? {setvar EditorCommandList ()};
	}
        completion-proc: {| value |
	    i ::= $EditorCommandList find $value;
	    if $i {$i ++} {i := 0};
	    c ::= $EditorCommandList get $i;
	    $c ?? {c ::= $EditorCommandList get 0};
	    $c ?? {c := $value};
	    $main mini-input-value-override $c [$c len];
        }
    ;;

    result ALL;
};

defcommand trace-editor-command {
    | main window |
    if {defvar? EditorCommandList} 
    then: {setvar EditorCommandList ()}
    else: {defvar EditorCommandList ()};

    mini-input-until-enter $main $window
        prompt: "Trace editor command: "
        enter-proc: {| value |
            f := `File("pmacs-command-trace.txt" mode: a);
            $f puts  "";
            $f puts  "***";
            $f puts  "***";
            $f puts ["*** Editor command: " . $value];
            err := <nil>;
	    try {
                trace {$window apply-command $main $window "" $value} out: [$f fd?];
            } catch: {| err |};
            if $err {
                $f puts ["ERROR: " $err];
            };
            $f puts  "***";
            $f puts  "";
            $f close;
            show-message ["Wrote tracefile to: " . [pwd] "/" "pmacs-command-trace.txt"];
	}
        edit-proc: {| value |
            try {
                setvar EditorCommandList [msort [$EditorCommand keys :string : filter {| i | $i =~ [$value rquote]}]];
            } catch: {
                setvar EditorCommandList ();
            };
	    $EditorCommandList ?? {setvar EditorCommandList ()};
	}
        completion-proc: {| value |
	    i ::= $EditorCommandList find $value;
	    if $i {$i ++} {i := 0};
	    c ::= $EditorCommandList get $i;
	    $c ?? {c ::= $EditorCommandList get 0};
	    $c ?? {c := $value};
	    $main mini-input-value-override $c [$c len];
	}
    ;;
    
    result ALL;
};

defcommand eval-region {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    $window mark;

    if [$window get-region] {
	### eval region
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $window get-region-string $sy $sx $ey $ex;
    } {
        ### eval this line
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $buff get-buffer-line $ey;
        str ::= $str ?? "";
 #       if {and {[$buff get-buffer-length : - 1] > $ey} {$str != ""}} {
 #           if {[$buff get-buffer-name] = "*Scratch*"} {
 #               $buff append-string $str;
 #           };
 #       };
    };

    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" cursor-down;

    $stdin puts $str;
    $window display-evaluation;
    
    result ALL;
};

defcommand kill-interp {
    | main window |
    
    mini-input-y-or-n $main $window 
        prompt: "kill interpriter OK? [y/n]: "
        yes-proc: {
            if {defvar? PINTERP} {
                try {$PINTERP release} catch: {};
            };
            reset-stdio;
            $stderr puts "Interpriter killed.";
        }
    ;;

    result ALL;
};

defcommand send-eof {
    | main window |
    $stderr puts "Send eof.";
    $stdin close;
    result ALL;
};

defcommand refresh-screen {
    | main window |
    $main refresh-screen;
    result ALL;
};

defcommand flash {
    | main window |
    curs-flash;
    result ALL;
};

defcommand open-file {
    | main window |
    
    mini-input-until-enter $main $window 
        init-value: [get-current-buffer-dir $window : . "/"]
        prompt: "Open file: "
        cancel-proc: {
	    show-message "Canceled.";
            return ALL;
        }
        enter-proc: {| value |
	    if {[$value len] = 0} {
		show-message :bell "No file name specified.";
		return ALL;
	    };
            path ::= path-adjust [
		{[$value sub 0 1] = "/"} ???
		    $value
		    [get-current-buffer-dir $window : . "/" $value]
	    ];
            if {file dir? $path} {
                dired-open $main $window $path;
                return ALL;
            };
	    buff ::= BufferManager get-buffer-by-path $path;
            if $buff {
		$MainWindow bind-buffer [$window get-window-name] $buff;
		return ALL;
            };
	    buff ::= new EditBuffer;
	    (result err) ::= $buff load-content $path;
            if {$buff enc-error?} {
                show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
            };
	    $MainWindow bind-buffer [$window get-window-name] $buff;
	    $result ?? {show-message :bell ["Open Failed, path: " . $value " ("  $err ")"]};
            return ALL;
        }
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            };
        }
    ;;
    
    result ALL;
};

defcommand view-file {
    | main window |

    mini-input-until-enter $main $window 
        init-value: [get-current-buffer-dir $window : . "/"]
        prompt: "View file: "
        cancel-proc: {
            show-message "Canceled.";
            return ALL;
        }
        enter-proc: {| value |
	    if {[$value len] = 0} {
		show-message :bell "No file name specified.";
		return ALL;
	    };
            path ::= path-adjust [
		{[$value sub 0 1] = "/"} ???
		    $value
		    [get-current-buffer-dir $window : . "/" $value]
	    ];
            if {file dir? $path} {
                dired-open $main $window $path;
                return ALL;
            };
	    buff ::= BufferManager get-buffer-by-path $path;
            if $buff {
                $buff set-protect;
		$MainWindow bind-buffer [$window get-window-name] $buff;
		return ALL;
            };
	    buff ::= new EditBuffer;
	    (result err) ::= $buff load-content $path;
            if {$buff enc-error?} {
                show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
            };
            $buff set-protect;
	    $MainWindow bind-buffer [$window get-window-name] $buff;
	    $result ?? {show-message :bell ["Open Failed, path: " . $value " ("  $err ")"]};
            return ALL;
	}
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            };
        }
    ;;
    
    result SELF;
};

defcommand read-file {
    | main window |

    mini-input-until-enter $main $window 
        init-value: [get-current-buffer-dir $window : . "/"]
        prompt: "Read file: "
        cancel-proc: {
	    show-message "Canceled.";
            return ALL;
        }
        enter-proc: {| value |
	    if {[$value len] = 0} {
		show-message :bell "No file name specified.";
		return ALL;
	    };
            path ::= path-adjust [
		{[$value sub 0 1] = "/"} ???
		    $value
		    [get-current-buffer-dir $window : . "/" $value]
	    ];
	    buff ::= $window get-buffer;
            geom ::= $window get-geom;
            $buff ?? {
                show-message :bell "No buffer.";
                return ALL;
            };
            f := <nil>;
            try {
                f ::= new File init: ($path mode: i);
                $f set-ignore-cr $FILE_IGNORE_CR;
                $f set-encoding [$buff get-encoding];
                (line col) ::= $window get-source-index $buff $geom;
                $f each do: {| r |
                    $buff insert-string-at [$r . "\r"] $line 0;
                    $line ++;
                };
                $window cursor-move-to $geom $line 0;
            }
            catch: {| e |
                show-message :bell ["File read error, " . [$e cdr]];
                return ALL;
            }
            fin: {
                if $f {$f close};
            };
        }
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            };
        }
    ;;

    result SELF;
};

defcommand save-buffer {
    | main window |
    __buff_in_clojure__ ::= $window get-buffer;
    path ::= $__buff_in_clojure__ get-path;

    if {or {nil? $path} {$path = ""}} {
        mini-input-until-enter $main $window
            init-value: [get-current-buffer-dir $window : . "/"]
            prompt: "Save file name: "
            cancel-proc: {
		show-message "Canceled.";
                return ALL;
            }
            completion-proc: {| value |
                if {$value = ""} {
                    fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
                } {
                    fname ::= show-files-in-window $main $window $value;
                };
	        $window apply-command $main $window "" top-of-buffer;
		$main mini-input-value-override $fname [$fname len];
		return ALL;
            }
	    enter-proc: {| value |
		path ::= path-adjust [
                    {[$value sub 0 1] = "/"} ???
                        $value
                        [get-current-buffer-dir $window : . "/" $value]
                ];

		if [file exists? $path] {
		    mini-input-fully-yes-or-no $main $window 
                        prompt: "File already exist, overwrite? [yes or ESC]: "
                        no-proc: {
			    show-message "Canceled.";
			    return ALL;
                        }
                        yes-proc: {
			    (result err) ::= $__buff_in_clojure__ save-content path: $path;
			    if $result {
				show-message "Save Done.";
			    } {
				show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
			    };
			    $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
			    return ALL;
			}
                    ;;
		} {
		    (result err) ::= $__buff_in_clojure__ save-content path: $path;
		    if $result {
			show-message "Save Done.";
		    } {
			show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
		    };
		    $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;		    
		    return ALL;
		};
            }
            keyin-proc: {| value in-key |
                if {eq? $in-key KEY_DOWN} {
                    $window apply-command $main $window "" move-half-up;
                    return ALL;
                };
                if {eq? $in-key KEY_UP} {
                    $window apply-command $main $window "" move-half-down;
                    return ALL;
                };
                if {eq? $in-key "/"} {
                    if {[$value at -2] = "/"} {
                        $main mini-input-value-override "/" 1;
                    };
                    return ALL;
                };
                if {eq? $in-key "~"} {
                    if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                        $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                    };
                    return ALL;
                };
            }
        ;;

        return ALL;
    };

    if [$__buff_in_clojure__ modified-by-another-process] {
        show-message "" :bell;
        mini-input-fully-yes-or-no $main $window
            prompt: ["Maybe this file modified by anothor process. Really save file? (" . $path ") [yes or ESC]: "]
            no-proc: {
                show-message "Canceled.";
                return ALL;
            }
            yes-proc: { 
                (result err) ::= $__buff_in_clojure__ save-content;
                if $result {
                    show-message "Save Done.";
                } {
                    show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
                };
                return ALL;
            }
        ;;
        result SELF;
    } {
        mini-input-y-or-n $main $window
            prompt: ["Save file? (" . $path ") [y/n]: "]
            no-proc: {
                show-message "Canceled.";
                return ALL;
            }
            yes-proc: {
                (result err) ::= $__buff_in_clojure__ save-content;
                if $result {
                    show-message "Save Done.";
                } {
                    show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
                };
                return ALL;
            }
        ;;
        
        result ALL;
    };
};

defcommand save-buffer-as {
    | main window |
    __buff_in_clojure__ ::= $window get-buffer;
    path ::= $__buff_in_clojure__ get-path;

    mini-input-until-enter $main $window
        init-value: [get-current-buffer-dir $window : . "/"]
        prompt: "Save file name: "
        cancel-proc: {
	    show-message "Canceled.";
            return ALL;
        }
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
        }
        enter-proc: {| value |
	    path ::= path-adjust [
                {[$value sub 0 1] = "/"} ???
		    $value
                    [get-current-buffer-dir $window : . "/" $value]
            ];

	    if [file exists? $path] {
                mini-input-fully-yes-or-no $main $window
                    prompt: "File already exist, overwrite? [yes or ESC]: "
                    no-proc: {
                        show-message "Canceled.";
                        return ALL;
                    }
		    yes-proc: {
                        (result err) ::= $__buff_in_clojure__ save-content path: $path;
                        if $result {
                            show-message "Save Done.";
                        } {
                            show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
                        };
                        $MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
                        return ALL;
		    }
                ;;
	    } {
		(result err) ::= $__buff_in_clojure__ save-content path: $path;
		if $result {
                    show-message "Save Done.";
                } {
                    show-message :bell ["Save Failed, path: " . $path " (" $err ")"];
		};
		$MainWindow bind-buffer [$window get-window-name] $__buff_in_clojure__;
		return ALL;
	    };
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            };
        }
    ;;
    
    result ALL;
};

defcommand kill-buffer {
    | main window |
    buff ::= $window get-buffer;
    if [$buff modify?] {
        mini-input-fully-yes-or-no $main $window
            prompt: "This buffer is modified, really kill? [yes or ESC]: "
            yes-proc: {
		$main unbind-buffer;
		return ALL;
	    }
        ;;
        return ALL;
    };
    
    $main unbind-buffer;
    result ALL;
};

defcommand key-binding-list {
    | main window |
    mode ::= $window get-mode;
    BufferManager unregist-buffer "*Key Binding*";
    buff ::= new EditBuffer;
    $buff load-content "key binding" :init-only buffer-name: "*Key Binding*";
    $buff set-content [$DEFAULT_PWIKI_DIR . "/"];
    $buff clear-all;

    $buff append-string "<<< Key bindings >>>";
    $buff append-string ["Buffer mode: " . $mode];
    $buff append-string "";
    $buff append-string ["%-15v %21v %-14v %-v" fmt  "Key group"     "Key combinations"  "Key symbol"       "Command"];
    $buff append-string ["%-15v %21v %-14v %-v" fmt ["-" repeat 15] ["-" repeat 21] ["-" repeat 14] ["-" repeat 38]];
    d ::= $window get KeyBinding;
    desc ::= $window get KeyDesc;
    l := ();
    $d each do: {| k v |
	if {nil? $v} {continue};
        if [$desc set? $k] {
            s ::= $desc get $k;
            ls ::= $s split;
            grp ::= $ls get 0;
            modify ::= $ls get 1;
            $l << ["%-18v%19v %-14v [[%-v]]" fmt $grp $modify $k $v];
        } {
            $l << ["%-18v%19v %-14v [[%-v]]" fmt "" (key input) $k $v];
        };
    };
    msort $l : each do: {| i |
	$buff append-string $i;
    };
    
    $buff append-string "";
    $buff append-string "<<< All editor commands >>>";
    msort [$EditorCommand keys :string] : each do: {| i |
        $buff append-string ["[[" . $i "]]"];
    };
    $buff no-modify;
    $buff set-protect;
    
    $main bind-buffer [$window get-window-name] $buff;
    $window set-mode "PWiki";

    result SELF;
};

defcommand buffer-list {
    | main window |
    BufferManager unregist-buffer "*Buffer List*";
    buff ::= new EditBuffer;
    $buff load-content "buffer list" :init-only buffer-name: "*Buffer List*";
    $main bind-buffer [$window get-window-name] $buff;
    $buff set-raise-low;
    $buff clear-all;

    l ::= BufferManager get-buffer-list-order-by-newer;
    maxlen ::= $l map {| _i | $_i display-width : + 2} : max;
    if {$maxlen < ["Buffer name" display-width]} {maxlen ::= "Buffer name" display-width};

    $buff append-string "<<< Buffer list >>>";
    $buff append-string "  * Select buffer - Move cursor to buffer line and press Enter key";
    $buff append-string "                    or press shortcut key(0-9). Press CTRL+B to name completion.";
    $buff append-string "  * Delete buffer - Move cursor to buffer line and press \"d\" key.";
    $buff append-string "";
    $buff append-string ["%1v %1v%1v %1v%1v%1v %-${maxlen}w %6v %-6v %-w" expand : fmt "#" "e" "t" "p" "m" "n" "Buffer name" "Length" "Mode" "Content path"];
    $buff append-string ["%1v %1v%1v %1v%1v%1v %-${maxlen}w %6v %-6v %-w" expand : fmt "-" "-" "-" "-" "-" "-" "-----------" "------" "----" "------------"];
    shortcut-ind := 1;
    $l each do: {| buff-name |
	display-buffer ::= BufferManager get-buffer $buff-name;
	$buff append-string [
	    "%1v %1v%1v %1v%1v%1v %-${maxlen}w %6d %-6v %-w" expand : fmt
            [[$shortcut-ind <= 10] ??? [$shortcut-ind % 10] " "]
            [["" . [$display-buffer get-encoding]] at 0]
	    [[$display-buffer includeCR?] ??? "d" "u"]
	    [[$display-buffer protect?] ??? "%" " "]
	    [[$display-buffer modify?]  ??? "*" " "]
	    [[$display-buffer newfile?] ??? "?" " "]
	    ["<" . $buff-name ">"]
	    [$display-buffer get-buffer-length]
            [$display-buffer get-buffer-mode]
	    [$display-buffer get-content]
        ];
        $shortcut-ind ++;
    };
    $buff no-modify;
    $buff set-protect;
    result SELF;
};

defcommand jump-to-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (line col) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $line;
    $r ?? {
	show-message :bell "No buffer name specified.";
	return SELF;
    };
    l ::= $r =~ '\<[^\>]+\>';
    if {nil? $l} {
	show-message :bell "No buffer name specified.";
	return SELF;
    };

    s ::= $l car : get 2;
    s ::= $s sub 1 [$s len : - 1];
    target-buff ::= BufferManager find-buffer $s;
    $target-buff ?? {
	show-message :bell "No buffer name specified.";
	return SELF;
    };
    $main bind-buffer [$window get-window-name] $target-buff;
    result SELF;
};

defcommand buffer-list-completion {
    | main window |

    set _index -1;
    set _list [BufferManager get-buffer-list];

    mini-input-until-enter $main $window
        prompt: "Buffer name: "
        completion-proc: {| value |
            if {[$_list len] = 0 } {
                $MainWindow set-mini-input-prompt "Buffer name (no match completion): ";
                return ALL;
            };
            setc _index [$_index +  1];
            if {$_index >= [$_list len] } {
                setc _index 0;
            };
            str ::= $_list get $_index;
            $MainWindow set-mini-input-prompt ["Buffer name (" . [$_list len] " match(es) completion): "];
            $main mini-input-value-override $str [$str len];
            return ALL;
        }
        completion-back-proc: {| value |
            if {[$_list len] = 0 } {
                $MainWindow set-mini-input-prompt "Buffer name (no match completion): ";
                return ALL;
            };
            setc _index [$_index -  1];
            if {$_index < 0 } {
                setc _index [$_list len : - 1];
            };
            str ::= $_list get $_index;
            $MainWindow set-mini-input-prompt ["Buffer name (" . [$_list len] " match(es) completion): "];
            $main mini-input-value-override $str [$str len];
            return ALL;
        }
        edit-proc: {| value |
            try {
                if {$value = ""} {
                    setc _list [BufferManager get-buffer-list];
                } {
                    setc _list [[BufferManager get-buffer-list] filter {| n | $n =~ :text :nocase [$value rquote]}];
                };
            } catch: {
                setc _list ();
            };
            setc _index -1;
            if {[$_list len] > 0} {
                $MainWindow set-mini-input-prompt ["Buffer name (" . [$_list len] " match(es) completion): "];
                if {[$_list len] = 1} {
                    setc _index 0;
                };
            } {
                $MainWindow set-mini-input-prompt "Buffer name (no match completion): ";
            };
            return ALL;
        }
        enter-proc: {| value |
            if {or {[$_list len] = 0} {$_index < 0}} {
                show-message :bell "No buffer name specified.";
                return ALL;
            };
            s ::= $_list get $_index;
            target-buff ::= BufferManager find-buffer $s;
            $target-buff ?? {
                show-message :bell "No buffer name specified.";
                return ALL;
            };
            $main bind-buffer [$window get-window-name] $target-buff;
            return ALL;
        }
    ;;
    
    return ALL;
};

defcommand buffer-list-shortcut-1 {
    | main window |
    jump-to-buffer-shortcut '^1 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-2 {
    | main window |
    jump-to-buffer-shortcut '^2 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-3 {
    | main window |
    jump-to-buffer-shortcut '^3 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-4 {
    | main window |
    jump-to-buffer-shortcut '^4 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-5 {
    | main window |
    jump-to-buffer-shortcut '^5 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-6 {
    | main window |
    jump-to-buffer-shortcut '^6 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-7 {
    | main window |
    jump-to-buffer-shortcut '^7 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-8 {
    | main window |
    jump-to-buffer-shortcut '^8 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-9 {
    | main window |
    jump-to-buffer-shortcut '^9 ' $main $window;
    result SELF;
};

defcommand buffer-list-shortcut-0 {
    | main window |
    jump-to-buffer-shortcut '^0 ' $main $window;
    result SELF;
};

defun jump-to-buffer-shortcut (key main window) {
    buff ::= $window get-buffer;
    found := <nil>;
    $buff buffer-select 0 [$buff get-buffer-length : - 1] {| r |
        if {$r =~ $key} {
            found := <t>;
            l ::= $r =~ '\<[^\>]+\>';
            if {nil? $l} {
                show-message :bell "No buffer name specified.";
                return SELF;
            };
            s ::= $l car : get 2;
            s ::= $s sub 1 [$s len : - 1];
            target-buff ::= BufferManager find-buffer $s;
            $target-buff ?? {
                show-message :bell "No buffer name specified.";
                return SELF;
            };
            $main bind-buffer [$window get-window-name] $target-buff;
        };
    };
    if {! $found} {
        show-message :bell "No shortcut line.";
    };
};

defcommand buffer-list-delete {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (line col) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $line;
    $r ?? {
	show-message :bell "No buffer name specified.";
	return SELF;
    };
    l ::= $r =~ '\<[^\>]+\>';
    if {nil? $l} {
	show-message :bell "No buffer name specified.";
	return SELF;
    };

    s ::= $l car : get 2;
    s ::= $s sub 1 [$s len : - 1];
    target-buff ::= BufferManager find-buffer $s;
    $target-buff ?? {
	show-message :bell "No buffer name specified.";
	return SELF;
    };

    if [$target-buff modify?] {
        mini-input-fully-yes-or-no $main $window
            prompt: "This buffer is modified, really kill? [yes or ESC]: "
            yes-proc: {
		$main delete-buffer $target-buff;
                $window apply-command $main $window "" buffer-list;
		return ALL;
            }
        ;;
	return ALL;
    };
    $main delete-buffer $target-buff;
    $window apply-command $main $window "" buffer-list;

    result ALL;
};

defcommand undo-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (new-y new-x) ::= $buff undo;
    if [$buff undo-empty?] {$buff no-modify};
    $new-y ?? {
        ###$buff no-modify;
	show-message :bell "Undo buffer is empty.";
	return SELF;
    };
    (line col) ::= $window get-cursor-index $buff $new-y $new-x;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand redo-buffer {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (new-y new-x) ::= $buff redo;
    $new-y ?? {
	show-message :bell "Redo buffer is empty.";
	return SELF;
    };
    (line col) ::= $window get-cursor-index $buff $new-y $new-x;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand start-region {
    | main window |
    buff ::= $window get-buffer;
    if [$window get-region] {
	show-message "End region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (cy cx) ::= $window get-source-index $buff $geom;
    $window start-region $cy $cx;
    show-message "Start region.";
    result SELF;
};

defcommand copy-region {
    | main window |
    buff ::= $window get-buffer;
    [$window get-region] ?? {
	show-message :bell "Not start region. Press Ctrl+[SPACE] to start region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    $window copy-region $sy $sx $ey $ex;
    show-message "Copied.";
    result SELF;
};

defcommand cut-region {
    | main window |
    buff ::= $window get-buffer;
    [$window get-region] ?? {
	show-message :bell "Not start region. Press Ctrl+[SPACE] to start region.";
	$window end-region;
	return SELF;
    };
    geom ::= $window get-geom;
    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    (line col) ::= $window cut-region $sy $sx $ey $ex;
    (line col) ::= $window get-cursor-index $buff $line $col;
    show-message "Cut.";
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand select-region-all {
    | main window |
    $window mark;
    if {$window get-region} {
        $window apply-command $main $window "" start-region;
    };
    $window apply-command $main $window "" top-of-buffer;
    $window apply-command $main $window "" start-region;
    $window apply-command $main $window "" bottom-of-buffer;
    result ALL;
};

defcommand select-region-paragraph {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    $window mark;
    $window end-region;
    $window apply-command $main $window "" cursor-top-of-line;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    r ::= $r ?? "";
    if {or {[$r at 0] = " "} {[$r at 0] = ""} {[$r at 0] = "\t"}} {
        $window apply-command $main $window "" move-previous-paragraph;
    };
    if {! [$window get-region]} {
        $window apply-command $main $window "" start-region;
    };
    $window apply-command $main $window "" move-next-paragraph;
    $window apply-command $main $window "" cursor-down;
    result SELF;
};

defcommand select-region-word {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $y;

    $window end-region;
    $r ?? {return ALL};
    
    i := 0;
    if {or {[$r at $x] alphanumeric?} {[$r at $x] = "-"}} {
        found := <t>;
        s ::= [$x = 0] ??? $x [$x - 1];
        i := $s;
        $s each to: 0 do: {| i |
            if {! [or {[$r at $i] alphanumeric?} {[$r at $i] = "-"}]} {
                i ::= $i + 1;
                break;
            };
        };
    } {
        found := <nil>;
        s ::= $x + 1;
        i := $s;
        $s each to: [$r len] do: {| i |
            if {or {[$r at $i] alphanumeric?} {[$r at $i] = "-"}} {
                found := <t>;
                break;
            };
        };
    };
    $found ?? {return ALL};
    
    $window cursor-move-to $geom $y $i;
    $window apply-command $main $window "" start-region;

    $i each to: [$r len] do: {| j |
        if {! [or {[$r at $j] alphanumeric?} {[$r at $j] = "-"}]} {
            break;
        };
    };
    $window cursor-move-to $geom $y $j;

    result SELF;
};

defcommand paste-buffer {
    | main window |
    buff ::= $window get-buffer;
    str ::= $window get-copy-buffer;
    if {$str = ""} {
	show-message :bell "Copy buffer is empty.";
	return SELF;
    };
    geom ::= $window get-geom;
    if [$window get-region] {
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        (line col) ::= $window delete-region $sy $sx $ey $ex;
    } {
        (sy sx) ::= $window get-source-index $buff $geom;
    };
    (cy cx) ::= $buff insert-string-at $str $sy $sx;
    $window set-copy-buffer $str;
    show-message "Paste.";
    (line col) ::= $window get-cursor-index $buff $cy $cx;
    $window set-freecursor <nil>;
    $geom set! IndexColumn.SAVE $col;
    $geom set! CursorLine [$line - $geom,ViewLine];
    $geom set! CursorColumn [$col - $geom,ViewColumn];

    (y x) ::= $window get-screen-size;
    $window fit-to-cursor $geom $y $x;
    result ALL;
};

defcommand search-forward {
    | main window |
    return [search-sub $main $window <t>];
};

defcommand search-backward {
    | main window |
    return [search-sub $main $window <nil>];
};

defun search-prompt (dir mode) {
    $dir ??? ["Search " . $mode " [forward]: "] ["Search " . $mode " [backward]: "];
};

defun search-sub (main window dir) {
    __buff_in_clojure__ ::= $window get-buffer;

    str := "";
    if [$window get-region] {
        buff ::= $window get-buffer;
        geom ::= $window get-geom;
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        $window copy-region $sy $sx $ey $ex;
        str ::= $window get-copy-buffer;
        setvar SearchString $str;
    };

    $window start-search;
    $window reset-search;
    $window set-search-result [$__buff_in_clojure__ search $str];
    $window stay-search;
    if {$str != ""} {
        $main send-key-event (KEY_UP);
    };

    mini-input-until-enter $main $window 
        init-value: $str
        prompt: [search-prompt $dir $SEARCH_MODE]
        cancel-proc: {
	    $window cancel-search $value;
	    show-message "Search canceled.";
	    return ALL;
        }
        enter-proc: {| value |
	    $window end-search $value;
	    show-message "Search complite.";
            return ALL;
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window move-to-next-search;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window move-to-previous-search;
                return ALL;
            };
            if {eq? $in-key KEY_SF} {
                buff ::= $window get-buffer;
                geom ::= $window get-geom;
                (sy sx) ::= $window get-source-index $buff $geom;
                $window apply-command $main $window "" smooth-scroll-down;
                (ey ex) ::= $window get-source-index $buff $geom;
                $geom set! CursorLine [$geom,CursorLine - [$ey - $sy]];
                $window stay-search;
                return ALL;
            };
            if {eq? $in-key KEY_SR} {
                buff ::= $window get-buffer;
                geom ::= $window get-geom;
                (sy sx) ::= $window get-source-index $buff $geom;
                $window apply-command $main $window "" smooth-scroll-up;
                (ey ex) ::= $window get-source-index $buff $geom;
                $geom set! CursorLine [$geom,CursorLine - [$ey - $sy]];
                $window stay-search;
                return ALL;
            };
            if {eq? $in-key KEY_SRIGHT} {
                buff ::= $window get-buffer;
                geom ::= $window get-geom;
                (sy sx) ::= $window get-source-index $buff $geom;
                $window apply-command $main $window "" smooth-scroll-right;
                (ey ex) ::= $window get-source-index $buff $geom;
                $geom set! CursorColumn [$geom,CursorColumn - [$ex - $sx]];
                $window stay-search;
                return ALL;
            };
            if {eq? $in-key KEY_SLEFT} {
                buff ::= $window get-buffer;
                geom ::= $window get-geom;
                (sy sx) ::= $window get-source-index $buff $geom;
                $window apply-command $main $window "" smooth-scroll-left;
                (ey ex) ::= $window get-source-index $buff $geom;
                $geom set! CursorColumn [$geom,CursorColumn - [$ex - $sx]];
                $window stay-search;
                return ALL;
            };
            if {eq? $in-key CTRL_F} {
                str ::= $window get-search-string;
                if [$value = ""] {
                    $main mini-input-value-override $str [$str len];
                    $window set-search-result [$__buff_in_clojure__ search $str];
                } {
                    $window set-search-result [$__buff_in_clojure__ search $value];
                };
                $window stay-search;
                $main send-key-event (KEY_DOWN);
                return ALL;
            };
            if {eq? $in-key CTRL_R} {
                str ::= $window get-search-string;
                if [$value = ""] {
                    $main mini-input-value-override $str [$str len];
                    $window set-search-result [$__buff_in_clojure__ search $str];
                } {
                    $window set-search-result [$__buff_in_clojure__ search $value];
                };
                $window stay-search;
                $main send-key-event (KEY_UP);
                return ALL;
            };
            if {eq? $in-key CTRL_V} {
                $window set-search-result [$__buff_in_clojure__ search $value];
                $window move-to-next-search;
                return ALL;
            };
            if {eq? $in-key CTRL_T} {
                case $SEARCH_MODE
                    regex {setvar SEARCH_MODE text}
                    text  {setvar SEARCH_MODE regex}
                ;;
                $MainWindow set-mini-input-prompt [search-prompt $dir $SEARCH_MODE];
                $window reset-search;
                $window set-search-result [$__buff_in_clojure__ search $value];
                $window stay-search;
                if $dir {
                    $main send-key-event (KEY_DOWN);
                } {
                    $main send-key-event (KEY_UP);
                };
                return ALL;
            };
            if {or {eq? $in-key CTRL_H} {eq? $in-key KEY_DC}
	           {eq? $in-key KEY_BACKSPACE} {eq? $in-key kDC5}} {
                $window reset-search;
                $window set-search-result [$__buff_in_clojure__ search $value];
                $window move-to-next-search;
                return ALL;
            };
            if {string? $in-key} {
                $window reset-search;
                $window set-search-result [$__buff_in_clojure__ search $value];
                $window stay-search;
                if $dir {
                    $main send-key-event (KEY_DOWN);
                } {
                    $main send-key-event (KEY_UP);
                };
                return ALL;
            };
        }
    ;;

    return SELF;
};

defcommand search-next {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $window get-search-string;
    if {$str = ""} {
        show-message :bell "No set search string, execute 'search' command first.";
        return SELF;
    };
    $window mark;
    (y x) ::= case $SEARCH_MODE
        regex    {get-next-search      $ey $ex [$str rquote] $buff;}
        default: {get-next-search-text $ey $ex [$str rquote] $buff;}
    ;

    $window cursor-move-to-fit-center $geom $y $x;
    return SELF;
};

defcommand search-previous {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $window get-search-string;
    if {$str = ""} {
        show-message :bell "No set search string, execute 'search' command first.";
        return SELF;
    };
    $window mark;
    (y x) ::= case $SEARCH_MODE
        regex    {get-previous-search      $ey $ex [$str rquote] $buff;}
        default: {get-previous-search-text $ey $ex [$str rquote] $buff;}
    ;

    $window cursor-move-to-fit-center $geom $y $x;
    return SELF;
};

defun get-next-search (y x str buff) {
    r ::= $buff get-buffer-line $y;
    $r ?? {return ($y $x)};

    sl ::= $r =~ :all $str;
    if $sl {
        sl ::= $sl filter {| el | [$el get 0] > $x};
        if {$sl null?} else: {
            return ($y [$sl car : car]);
        };
    };
    
    result := <nil>;
    $buff buffer-select [$y + 1] [$buff get-buffer-length] {
        | src l |
        sl ::= $src =~ :all $str;
        if $sl {
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defun get-next-search-text (y x str buff) {
    r ::= $buff get-buffer-line $y;
    $r ?? {return ($y $x)};

    sl ::= $r =~ :all :text :nocase $str;
    if $sl {
        sl ::= $sl filter {| el | [$el get 0] > $x};
        if {$sl null?} else: {
            return ($y [$sl car : car]);
        };
    };
    
    result := <nil>;
    $buff buffer-select [$y + 1] [$buff get-buffer-length] {
        | src l |
        sl ::= $src =~ :all :text :nocase $str;
        if $sl {
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defun get-previous-search (y x str buff) {
    if {and {$y = 0} {$x = 0}} {return ($y $x)};
        
    r ::= $buff get-buffer-line $y;
    if $r {
        sl ::= $r =~ :all $str;
        if $sl {
            sl ::= $sl reverse;
            sl ::= $sl filter {| el | [$el get 0] < $x};
            if {$sl null?} else: {
                return ($y [$sl car : car]);
            };
        };
    };
    
    if {$y = 0} {return ($y $x)};
    result := <nil>;
    $buff buffer-select [$y - 1] 0 {
        | src l |
        sl ::= $src =~ :all $str;
        if $sl {
            sl ::= $sl reverse;
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defun get-previous-search-text (y x str buff) {
    if {and {$y = 0} {$x = 0}} {return ($y $x)};
        
    r ::= $buff get-buffer-line $y;
    if $r {
        sl ::= $r =~ :all :text :nocase $str;
        if $sl {
            sl ::= $sl reverse;
            sl ::= $sl filter {| el | [$el get 0] < $x};
            if {$sl null?} else: {
                return ($y [$sl car : car]);
            };
        };
    };
    
    if {$y = 0} {return ($y $x)};
    result := <nil>;
    $buff buffer-select [$y - 1] 0 {
        | src l |
        sl ::= $src =~ :all :text :nocase $str;
        if $sl {
            sl ::= $sl reverse;
            result := ($l [$sl car : car]);
        };
        if $result {break};
    };
    if $result {
        return $result;
    };
    return ($y $x);
};

defcommand pwiki-next-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-next-search $ey $ex $PWIKI_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand pwiki-previous-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-previous-search $ey $ex $PWIKI_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand pwiki-click-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= cursor-on-search-regex $ey $ex $PWIKI_LINK $buff;
    $str ?? {
        $window apply-command $main $window "\r" insert-character;
        return ALL;
    };

    link ::= $str sub 2 [$str len : - 2];
    if {[$link at 0] = "&"} {
        ### if pwiki link form is [[&command]], execute command.
        command ::= $link sub 1;
        $window apply-command $main $window "" $command;
        return ALL;
    };
    path ::= $buff get-content;
    if {[$link at 0] = "/"} {
        dir := "";
    } {
        if $path {
            dir ::= get-dir $path;
        } {
            dir := $DEFAULT_PWIKI_DIR;
        };
    };
    
    new-path ::= [$dir = ""] ??? [$link . ".pwiki"] [path-adjust [$dir . "/" $link ".pwiki"]];
    next-buff ::= BufferManager get-buffer-by-path $new-path;
    $next-buff ?? {
        next-buff ::= new EditBuffer;
        create-directory-if-not-exists $new-path;
        (result err) ::= $next-buff load-content $new-path;
        if {$next-buff enc-error?} {
            show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
        };
        $result ?? {
            show-message :bell ["Open Failed, path: " . $new-path " ("  $err ")"];
            return SELF;
            if {$buff enc-error?} {
                show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
            };
        };
    };
    $main bind-buffer [$window get-window-name] $next-buff;
    $next-buff set-previous-buffer [$buff get-buffer-name];
    
    return ALL;
};

defun create-directory-if-not-exists (path) {
    l ::= $path split sep: "/";
    $l ->>;
    if {[$path at 0] = "/"} {$l >>};
    dir := "";
    $l each do: {| e |
        $dir append! "/";
        $dir append! $e;
        if {file dir? $dir} {continue};
        try {
            file mkdir $dir $DEFAULT_DIR_MODE;
        } catch: {| err |
            throw ErrFileAccess ["Can\'t create directory \'" . $dir "\'."]; #'
        };
    };
};

defcommand pwiki-link-back {
    | main window |
    buff ::= $window get-buffer;
    prev-buff-name ::= $buff get-previous-buffer;
    if $prev-buff-name {
        prev-buff ::= BufferManager find-buffer $prev-buff-name;
        if $prev-buff {
            $main bind-buffer [$window get-window-name] $prev-buff;
        } {
            show-message :bell ["No found previous buffer, \'" . $prev-buff-name "\'."];
        };
    } {
        show-message :bell "No set previous buffer.";
    };
    result ALL;
};

defun cursor-on-search-regex (y x str buff) {
    r ::= $buff get-buffer-line $y;
    $r ?? {return <nil>};
    sl ::= $r =~ :all $str;
    $sl ?? {return <nil>};
    $sl each do: {| el |
        if {and {$x >= [$el get 0]} {$x < [$el get 1]}} {
            return [$el get 2];
        };
    };
    return <nil>;
};

defcommand replace-buffer {
    | main window |

    mini-input-until-enter $main $window
        prompt: "Replace string: "
        enter-proc: {| value |
	    froms := $value;
            mini-input-until-enter $main $window
                prompt: ["Replace string [" . $froms "] to: "]
                enter-proc: {| value |
                    count ::= [$window get-buffer] replace-buffer $froms $value;
                    show-message ["Replace [" . $froms "] to [" $value "] " $count " times completed."];
                    return ALL;
	        }
                cancel-proc: {
                    show-message "Replace canceled.";
                    return ALL;
                }
            ;;
        }
        cancel-proc: {
            show-message "Replace canceled.";
            return ALL;
        }
    ;;
    
    result SELF;
};

defcommand replace-region {
    | main window |
    [$window get-region] ?? {
        show-message "Please select a region first.";
        return SELF;
    };

    mini-input-until-enter $main $window 
        prompt: "Region replace string: "
        enter-proc: {| value |
	    froms := $value;
            mini-input-until-enter $main $window
                prompt: ["Region replace string [" . $froms "] to: "]
                enter-proc: {| value |
                    if [$window get-region] {
                        buff ::= $window get-buffer;
                        geom ::= $window get-geom;
                        (sy sx) ::= $window end-region;
                        (ey ex) ::= $window get-source-index $buff $geom;
                    };
                    if {$sy > $ey} {(sy ey) := ($ey $sy)};
                    count ::= [$window get-buffer] replace-region $froms $value $sy $ey;
                    show-message ["Region replace [" . $froms "] to [" $value "] " $count " times completed in region (" $sy "," $ey ")."];
                    return ALL;
	        }
                cancel-proc: {
                    show-message "Region replace canceled.";
                    return ALL;
                }
            ;;
        }
        cancel-proc: {
            show-message "Region replace canceled.";
            return ALL;
        }
    ;;

    result ALL;
};

defcommand exit {
    | main window |
    l ::= BufferManager get-buffer-list : filter {| i | "*" != [$i at 0]};
    do_exit := <t>;
    $l each do: {| buff-name |
	buffer ::= BufferManager get-buffer $buff-name;
        if {$buffer modify?} {
	    do_exit := <nil>;
        };
    };
    if $do_exit {
        exit
    } {
        show-message :bell "CAUTION: Modified buffer is exists!! Try again after save the buffer or kill.";
    };
    
    result SELF;
};

defcommand smart-newline {
    | main window |
    $window set-freecursor <nil>;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str-cur ::= $buff get-buffer-line $ey;
    if {and $str-cur {$ex >= [$str-cur len]}} {
        ### current line smart indent
        str-prev := "";
        if {$ey > 0} {
            idx-y := 1;
            loop do: {
                str-prev ::= $buff get-buffer-line [$ey - $idx-y];
                if $str-prev else: {
                    str-prev := "";
                    break;
                };
                if {[$str-prev len] > 0} {break};
                $idx-y ++;
            };
        };
        cur-level ::= get-next-indent-count-backward $str-cur;
        if {$cur-level < 0} {
            prev-level ::= get-indent-level $str-prev;
            prev-indent ::= get-next-indent-count $str-prev;
            cur-level-count ::= $cur-level + $prev-indent;
            if [$cur-level-count < 0] {cur-level-count := -1};
            if {or {$cur-level-count < 0}
                   {and {$cur-level-count = 0} {$prev-indent > 0}}} {
                cur-indent ::= $prev-level + [$cur-level-count * $INDENT_WIDTH];
                cur-indent ::= [$cur-indent < 0] ??? 0 $cur-indent;
                new-str ::= [" " repeat $cur-indent] . [$str-cur clean];
                $buff line-update $new-str $ey;
                $geom set! IndexColumn.SAVE [$new-str len];
            };
        };
    };
    
    ### insert newline
    $window apply-command $main $window "\r" insert-character;
    
    ### next line smart indent
    (ey ex) ::= $window get-source-index $buff $geom;
    str-prev := "";
    if {$ey > 0} {
        idx-y := 1;
        loop do: {
            str-prev ::= $buff get-buffer-line [$ey - $idx-y];
            if $str-prev else: {
                str-prev := "";
                break;
            };
            if {[$str-prev len] > 0} {break};
            $idx-y ++;
        };
    };
    cur-level ::= get-indent-level $str-prev;
    next-level-count ::= get-next-indent-count $str-prev;

    if {$cur-level > 0} {
        $window apply-command $main $window "" smart-indent;
    } {
        if {$next-level-count > 0} {
            $window apply-command $main $window "" smart-indent;
        };
    };
    
    result ALL;
};

defcommand smart-indent {
    | main window |
    $window set-freecursor <nil>;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    str-prev := "";
    if {$ey > 0} {
        idx-y := 1;
        loop do: {
            str-prev ::= $buff get-buffer-line [$ey - $idx-y];
            if $str-prev else: {
                str-prev := "";
                break;
            };
            if {[$str-prev len] > 0} {break};
            $idx-y ++;
        };
    };
    cur-level ::= get-indent-level $str-prev;
    next-level-count ::= get-next-indent-count $str-prev;
    next-level-count ::= [$next-level-count > 0] ??? 1 0;
    next-indent ::= $cur-level + [$next-level-count * $INDENT_WIDTH];
    next-level-count ::= get-next-indent-count-backward $str;
    if {$next-level-count < 0} {
        next-indent ::= $next-indent - $INDENT_WIDTH;
    };

    cur-pos ::= curs-index-to-pos $str $ex $DEFAULT_TAB_WIDTH;
    if {$cur-pos < $next-indent} {
	# smart indent
	new-str ::= [" " repeat $next-indent] . [$str clean];
        $buff line-update $new-str $ey;
        $geom set! IndexColumn.SAVE $next-indent;
    } {
	# insert indent
	in ::= $INDENT_WIDTH - [$cur-pos % $INDENT_WIDTH];
	$buff insert-string-at [" " repeat $in] $ey $ex;
        $geom set! IndexColumn.SAVE [$geom get IndexColumn.SAVE : + $in];
    };
    
    result ALL;
};

defun get-indent-level (str) {
    if {$str = ""} {return 0};

    str ::= $str . "x";
    0 each to: [$str len : - 1] do: {| i |
	c ::= $str at $i;
	if {! [or [$c = " "] [$c = "\t"]]} {break};
    };
    return [curs-index-to-pos $str $i $DEFAULT_TAB_WIDTH];
};

defun get-next-indent-count (str) {
    kakko-maru := 0; ### '(' ')' balance count
    kakko-nami := 0; ### '{' '}' balance count
    kakko-kaku := 0; ### '[' ']' balance count

    if {[[$str clean] at -1] = ":"} {return 1};
    
    [$str len : - 1] each to: 0 do: {| i |
	c ::= $str at $i;
	case $c
	  "(" {$kakko-maru ++}
	  "{" {$kakko-nami ++}
	  "[" {$kakko-kaku ++}
	  ")" {$kakko-maru --}
	  "}" {$kakko-nami --}
	  "]" {$kakko-kaku --}
	;
        if {or {$kakko-maru > 0} {$kakko-nami > 0} {$kakko-kaku > 0 }} {break};
    };

    i ::= $kakko-maru + $kakko-nami : + $kakko-kaku;
    return [cond
        {$i = 0} {break  0}
        {$i > 0} {break  1}
        {$i < 0} {break -1}
    ];
};

defun get-next-indent-count-backward (str) {
    kakko-maru := 0; ### '(' ')' balance count
    kakko-nami := 0; ### '{' '}' balance count
    kakko-kaku := 0; ### '[' ']' balance count
    
    0 each to: [$str len : - 1] do: {| i |
	c ::= $str at $i;
	case $c
	  "(" {$kakko-maru ++}
	  "{" {$kakko-nami ++}
	  "[" {$kakko-kaku ++}
	  ")" {$kakko-maru --}
	  "}" {$kakko-nami --}
	  "]" {$kakko-kaku --}
	;
        if {or {$kakko-maru < 0} {$kakko-nami < 0} {$kakko-kaku < 0 }} {break};
    };

    i ::= $kakko-maru + $kakko-nami : + $kakko-kaku;
    return [cond
        {$i = 0} {break  0}
        {$i > 0} {break  1}
        {$i < 0} {break -1}
    ];
};

defcommand smart-dedent {
    | main window |
    $window set-freecursor <nil>;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    cur-level ::= get-indent-level $str;
    next-indent ::= [$cur-level / $INDENT_WIDTH] - 1 : * $INDENT_WIDTH;
    if {$next-indent < 0} {return ALL};
    new-str ::= [" " repeat $next-indent] . [$str clean];
    $buff line-update $new-str $ey;
    $geom set! IndexColumn.SAVE $next-indent;
    
    result ALL;
};

defcommand smart-move-forward {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    vec ::= $buff get-vector;
    $vec ?? {return SELF};

    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    $str ?? {return ALL};
    cur-char ::= $str at $ex;
    if {or [$cur-char = ")"] [$cur-char = "]"] [$cur-char = "}"]} {
        show-message "Bracket directions are opposite.";
        $window cursor-move-to $geom $ey [$ex + 1];
        $window apply-command $main $window "" smart-move-forward;
        return SELF;
    };
    if {or [$cur-char = "("] [$cur-char = "["] [$cur-char = "{"]} {
        level-maru-kakko := 0;
        level-kaku-kakko := 0;
        level-nami-kakko := 0;
        case $cur-char
            "(" {fin-char := ")"; level-maru-kakko := 1}
            "[" {fin-char := "]"; level-kaku-kakko := 1}
            "{" {fin-char := "}"; level-nami-kakko := 1}
        ;
        fin := <nil>;
        dquote := <nil>;
        squote := <nil>;
        $vec each-forward-char $ey [$ex + 1] {| last-y last-x c |
            case $c
                "\"" {dquote ::= $dquote ??? <nil> <t>} ### " balanced for smart-move-*
                "\'" {squote ::= $squote ??? <nil> <t>} ### ' balanced for smart-move-*
            ;
            if {! [or $dquote $squote]} {
                case $c
                    "(" {$level-maru-kakko ++}
                    "[" {$level-kaku-kakko ++}
                    "{" {$level-nami-kakko ++}
                    ")" {
                        $level-maru-kakko --;
                        if {and [$fin-char = $c] [$level-maru-kakko = 0]} {fin := <t>};
                    }
                    "]" {
                        $level-kaku-kakko --;
                        if {and [$fin-char = $c] [$level-kaku-kakko = 0]} {fin := <t>};
                    }
                    "}" {
                        $level-nami-kakko --;
                        if {and [$fin-char = $c] [$level-nami-kakko = 0]} {fin := <t>};
                    }
                ;
            };
            if $fin {break};
        };
        if $fin {$window cursor-move-to $geom $last-y $last-x};
        if {or [$level-maru-kakko != 0] [$level-kaku-kakko != 0] [$level-nami-kakko != 0]} {
            show-message :bell ["Unbalanced brackets? " . "hint:"
                [if [$level-maru-kakko != 0] " '(' or ')', " ""]
                [if [$level-kaku-kakko != 0] " '[' or ']', " ""]
                [if [$level-nami-kakko != 0] " '{' or '}', " ""]
                " check their.";
            ];
        };
        return SELF;
    };
    
    ### otherwise
    ### move word forward
    last-y := $ey;
    last-x := $ex;
    $vec each-forward-char $ey $ex {| last-y last-x c |
        if {or 
            {$c alphanumeric?}
            {$c = "("} {$c = "["} {$c = "{"}
            {$c = ")"} {$c = "]"} {$c = "}"}
        } {break};
    };
    if {or 
        {$c = "("} {$c = "["} {$c = "{"}
        {$c = ")"} {$c = "]"} {$c = "}"}
    } {
        $window cursor-move-to $geom $last-y $last-x;
        return SELF;
    };
    
    $vec each-forward-char $last-y [$last-x + 1] {| last-y last-x c |
        if {! [or {$c alphanumeric?} {$c = "-"}] } {break};
    };
    $window cursor-move-to $geom $last-y $last-x;

    result SELF;
};

defcommand smart-move-backward {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    vec ::= $buff get-vector;
    $vec ?? {return SELF};

    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    cur-char ::= $str at $ex;

    if {or [$cur-char = "("] [$cur-char = "["] [$cur-char = "{"]} {
        show-message "Bracket directions are opposite.";
        (ey ex) ::= $vec get-prev-pos $ey $ex;
        $window cursor-move-to $geom $ey $ex;
        (ey ex) ::= $vec get-prev-pos $ey $ex;
        prev-char ::= $vec at $ey $ex;
        if {or {$prev-char alphanumeric?} {$prev-char = "-"}} {
            $window apply-command $main $window "" smart-move-backward;
        };
        return SELF;
    };
    if {or [$cur-char = ")"] [$cur-char = "]"] [$cur-char = "}"]} {
        level-maru-kakko := 0;
        level-kaku-kakko := 0;
        level-nami-kakko := 0;
        case $cur-char
            ")" {fin-char := "("; level-maru-kakko := 1}
            "]" {fin-char := "["; level-kaku-kakko := 1}
            "}" {fin-char := "{"; level-nami-kakko := 1}
        ;
        fin := <nil>;
        dquote := <nil>;
        squote := <nil>;
        (ey ex) ::= $vec get-prev-pos $ey $ex;
        $vec each-backward-char $ey $ex {| last-y last-x c |
            case $c
                "\"" {dquote ::= $dquote ??? <nil> <t>} ### " balanced for smart-move-*
                "\'" {squote ::= $squote ??? <nil> <t>} ### ' balanced for smart-move-*
            ;
            if {! [or $dquote $squote]} {
                case $c
                    ")" {$level-maru-kakko ++}
                    "]" {$level-kaku-kakko ++}
                    "}" {$level-nami-kakko ++}
                    "(" {
                        $level-maru-kakko --;
                        if {and [$fin-char = $c] [$level-maru-kakko = 0]} {fin := <t>};
                    }
                    "[" {
                        $level-kaku-kakko --;
                        if {and [$fin-char = $c] [$level-kaku-kakko = 0]} {fin := <t>};
                    }
                    "{" {
                        $level-nami-kakko --;
                        if {and [$fin-char = $c] [$level-nami-kakko = 0]} {fin := <t>};
                    }
                ;
            };
            if $fin {break};
        };
        if $fin {$window cursor-move-to $geom $last-y $last-x};
        if {or [$level-maru-kakko != 0] [$level-kaku-kakko != 0] [$level-nami-kakko != 0]} {
            show-message :bell ["Unbalanced brackets? " . "hint:"
                [if [$level-maru-kakko != 0] " '(' or ')', " ""]
                [if [$level-kaku-kakko != 0] " '[' or ']', " ""]
                [if [$level-nami-kakko != 0] " '{' or '}', " ""]
                " check their.";
            ];
        };
        return SELF;
    };
    
    ### otherwise
    ### move word backward
    (ey ex) ::= $vec get-prev-pos $ey $ex;
    $vec each-backward-char $ey $ex {| last-y last-x c |
        if {or 
            {$c alphanumeric?}
            {$c = "("} {$c = "["} {$c = "{"}
            {$c = ")"} {$c = "]"} {$c = "}"}
        } {break};
    };
    if {or 
        {$c = "("} {$c = "["} {$c = "{"}
        {$c = ")"} {$c = "]"} {$c = "}"}
    } {
        $window cursor-move-to $geom $last-y $last-x;
        return SELF;
    };
    
    (ey ex) ::= $vec get-prev-pos $last-y $last-x;
    $vec each-backward-char $ey $ex {| last-y last-x c |
        if {! [or {$c alphanumeric?} {$c = "-"}] } {break};
    };
    if {! [and {$last-y = 0} {$last-x = 0}]} {
        (last-y last-x) ::= $vec get-next-pos $last-y $last-x;
    };
    if {$last-y < 0} {last-y := 0};
    if {$last-x < 0} {last-x := 0};
    $window cursor-move-to $geom $last-y $last-x;

    result SELF;
};

defcommand move-next-paragraph {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (line col) ::= $window get-cursor-index $buff $ey $ex;
    if {[$ey + 1] >= [$buff get-buffer-length]} {return SELF};
    find := <nil>;
    $buff buffer-select [$ey + 1] [$buff get-buffer-length : - 1] {
        | src l |
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        if {and [[$src len] > 0] [[$src at $p] != " "] [[$src at $p] != "\t"] [[$src at $p] != ""]} {
            find := <t>;
	    break;
	};
    };
    if $find {
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        $window cursor-move-to $geom $l $p;
    };
    result SELF;
};

defcommand move-previous-paragraph {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (line col) ::= $window get-cursor-index $buff $ey $ex;
    if {$ey < 1} {return SELF};
    find := <nil>;
    $buff buffer-select [$ey - 1] 0 {
        | src l |
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        if {and [[$src len] > 0] [[$src at $p] != " "] [[$src at $p] != "\t"] [[$src at $p] != ""]} {
            find := <t>;
	    break;
	};
    };
    if $find {
        p ::= curs-pos-to-index $src $col $DEFAULT_TAB_WIDTH;
        $window cursor-move-to $geom $l $p;
    };
    result SELF;
};

defcommand move-next-paragraph-fit-to-top {
    | main window |
    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" move-next-paragraph;
    $window apply-command $main $window "" fit-to-top;
    result SELF;
};

defcommand move-previous-paragraph-fit-to-top {
    | main window |
    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" move-previous-paragraph;
    $window apply-command $main $window "" fit-to-top;
    result SELF;
};

defcommand mark {
    | main window |
    $window mark;
    result SELF;
};

defcommand goto-mark {
    | main window |
    $window goto-mark;
    result SELF;
};

defcommand goto-unmark {
    | main window |
    $window unmark;
    result SELF;
};

defcommand grep {
    | main window |
    buff ::= $window get-buffer;
    dir ::= [$buff get-content-dir] . "/";

    mini-input-until-enter $main $window 
        init-value: $dir
        prompt: "Directory: "
        enter-proc: {| value |
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return ALL;
            };
            directory := $value;
            if {file dir? $directory} else: {
                show-message :bell ["Not directory: " . $directory];
                return ALL;
            };

            str := "";
            buff ::= $window get-buffer;
            geom ::= $window get-geom;
            if [$window get-region] {
                ### eval region
                (sy sx) ::= $window end-region;
                (ey ex) ::= $window get-source-index $buff $geom;
                str ::= $window get-region-string $sy $sx $ey $ex;
            };
            
            mini-input-until-enter $main $window
                init-value: ["grep -rnHe '" . $str "' *"]
                prompt: "grep command line: "
                index: 12
                enter-proc: {| value |
                    if {[$value len] = 0} {
                        show-message :bell "No grep command line specified.";
                        return ALL;
                    };
                    cmd := $value;
                    
                    ###
                    ### do grep
                    ###
                    orig-dir ::= pwd;
                    cd $directory;
                    fout ::= new Stream;
                    $fout set-nolimit;
                    ### sts ::= {exec "/bin/sh" "-c" $cmd} redirect-out $fout $ferr;
                    sts := 0;
                    try {
                        pipe out: $fout {exec :err-to-stdout "/bin/sh" "-c" $cmd};
                    } catch: {| e |
                        sts ::= "<" . [$e car] "> #" [$e cdr];
                    };
                    $fout close;
                    buff ::= new EditBuffer;
                    BufferManager unregist-buffer "*Grep*";
                    (result err) ::= $buff load-content  :init-only "grep buffer" buffer-name: "*Grep*";
                    $buff set-content $directory;
                    $buff clear-all;
                    $buff append-string ["CWD:  " . $directory];
                    $buff append-string ["EXEC: " . $cmd];
                    $buff append-string "";
                    $fout each do: {| r |
                        $buff append-string $r;
                    };
                    fout := <nil>;
                    $buff append-string "";
                    $buff append-string ["exit(" . $sts ")"];
                    
                    w1 ::= $main get-window-by-name "Window#1";
                    if $w1 else: {
                        $main create-split-vertical-window;
                    };
                    $main bind-buffer "Window#1" $buff;
                    window ::= $main get-window-by-name "Window#1";
                    geom ::= $window get-geom;
                    $geom set! ViewLine 0;
                    $geom set! ViewColumn 0;
                    $window cursor-move-to $geom 0 0;
                    $buff set-protect;
                    $buff no-modify;
                    cd $orig-dir;
                    return ALL;
                }
            ;;
            return ALL;
        }
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            };
        }
    ;;
    
    result ALL;
};

defcommand grep-current-word {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    dir ::= [$buff get-content-dir] . "/";

    orig_geom ::= $geom clone;
    $window apply-command $main $window "" select-region-word;

    [$window in-region?] ?? {
        show-message "Word not found.";
        return ALL;
    };
    
    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $window get-region-string $sy $sx $ey $ex;
    $geom restore-geom $orig_geom;
    command ::= "grep -nHe '" . $str "' *";
    
    ###
    ### do grep
    ###
    show-message ["Doing - " . $command];
    orig-dir ::= pwd;
    cd $dir;
    
    fout ::= new Stream;
    $fout set-nolimit;
    sts := 0;
    try {
        pipe out: $fout {exec :err-to-stdout "/bin/sh" "-c" $command};
    } catch: {| e |
        sts ::= "<" . [$e car] "> #" [$e cdr];
    };
    $fout close;
    buff ::= new EditBuffer;
    BufferManager unregist-buffer "*Grep*";
    (result err) ::= $buff load-content  :init-only "grep buffer" buffer-name: "*Grep*";
    $buff set-content $dir;
    $buff clear-all;
    $buff append-string ["CWD:  " . $dir];
    $buff append-string ["EXEC: " . $command];
    $buff append-string "";
    $fout each do: {| r |
        $buff append-string $r;
    };
    fout := <nil>;
    $buff append-string "";
    $buff append-string ["exit(" . $sts ")"];
    
    w1 ::= $main get-window-by-name "Window#1";
    if $w1 else: {
        $main create-split-vertical-window;
    };
    $main bind-buffer "Window#1" $buff;
    window ::= $main get-window-by-name "Window#1";
    geom ::= $window get-geom;
    $geom set! ViewLine 0;
    $geom set! ViewColumn 0;
    $window cursor-move-to $geom 0 0;
    $buff set-protect;
    $buff no-modify;
    cd $orig-dir;
    show-message "Done.";

    return SELF;
};

defcommand grep-next {
    | main window |
    grep-buff ::= BufferManager find-buffer "*Grep*";
    $grep-buff ?? {
        show-message :bell "No *Grep* buffer, execute 'grep' command first.";
        return ALL;
    };
    dir ::= chdir-cwd $grep-buff;
    
    w1 ::= $main get-window-by-name "Window#1";
    w2 ::= $main get-window-by-name "Window#2";
    if {and $w1 $w2} else: {
        $main create-split-vertical-window;
    };
    $main bind-buffer "Window#1" $grep-buff;
    grep-window ::= $main get-window-by-name "Window#1";
    grep-geom ::= $grep-window get-geom;
    (ey ex) ::= $grep-window get-source-index $grep-buff $grep-geom;
    str := <nil>;
    while {true} do: {
        $ey ++;
        str ::= $grep-buff get-buffer-line $ey;
        if {nil? $str} {
            break;
        };
        l ::= $str split sep: ":";
        f ::= $l >>;
        $f ?? {continue};
        n ::= $l >>;
        $n ?? {continue};

        if {and {$f != ""} {$n != ""} {$n numeric?}} {break};
    };
    if {$ey >= [$grep-buff get-buffer-length]} {ey ::= $grep-buff get-buffer-length : - 1};
    $window cursor-move-to-fit-center $grep-geom $ey 0;
    $window cursor-fit-to-top $grep-geom;
    $str ?? {
        show-message :bell "Bottom of *Grep* buffer.";
        return ALL;
    };

    ### show-message ["File: " . $f ", line: " $n];
    f ::= $f split : last : car;
    f ::= $f ?? "";
    if {[$f at 0] = "/"} {
        show-file-at "Window#2" [path-adjust $f] $n;
    } {
        show-file-at "Window#2" [path-adjust [$dir . $f]] $n;
    };

    return ALL;
};

defcommand grep-previous {
    | main window |
    grep-buff ::= BufferManager find-buffer "*Grep*";
    $grep-buff ?? {
        show-message :bell "No *Grep* buffer, execute 'grep' command first.";
        return ALL;
    };
    dir ::= chdir-cwd $grep-buff;
    
    w1 ::= $main get-window-by-name "Window#1";
    w2 ::= $main get-window-by-name "Window#2";
    if {and $w1 $w2} else: {
        $main create-split-vertical-window;
    };
    $main bind-buffer "Window#1" $grep-buff;
    grep-window ::= $main get-window-by-name "Window#1";
    grep-geom ::= $grep-window get-geom;
    (ey ex) ::= $grep-window get-source-index $grep-buff $grep-geom;
    str := <nil>;
    while {true} do: {
        $ey --;
        str ::= $grep-buff get-buffer-line $ey;
        if {$ey < 0} {
            str := <nil>; 
            break;
        };
        if {nil? $str} {
            str := <nil>; 
            break;
        };
        l ::= $str split sep: ":";
        f ::= $l >>;
        $f ?? {continue};
        n ::= $l >>;
        $n ?? {continue};

        if {and {$f != ""} {$n != ""} {$n numeric?}} {break};
    };
    if {$ey < 0} {ey := 0};
    $window cursor-move-to-fit-center $grep-geom $ey 0;
    $window cursor-fit-to-top $grep-geom;
    $str ?? {
        show-message :bell "Top of *Grep* buffer.";
        return ALL;
    };

    ### show-message ["File: " . $f ", line: " $n];
    f ::= $f split : last : car;
    f ::= $f ?? "";
    if {[$f at 0] = "/"} {
        show-file-at "Window#2" [path-adjust $f] $n;
    } {
        show-file-at "Window#2" [path-adjust [$dir . $f]] $n;
    };
    
    return ALL;
};

defun show-file-at (window-name path line) {
    buff ::= BufferManager get-buffer-by-path $path;
    $buff ?? {
        buff ::= new EditBuffer;
        (result err) ::= $buff load-content $path;
        $result ?? {
            show-message :bell ["Open Failed, path: " . $path " ("  $err ")"];
            return;
        };
        if {$buff enc-error?} {
            show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
        };
    };
    $MainWindow bind-buffer $window-name $buff;
    $MainWindow roll-to-window $window-name;
    win ::= $MainWindow get-current-window;
    geom ::= $win get-geom;
    $win cursor-move-to-fit-center $geom [$line - 1] 0;
};

defun chdir-cwd (buff) {
    r ::= $buff get-buffer-line 0;
    if $r {
        l ::= $r split sep: ":";
        if {[$l len] < 2} {return "./"};
        if {[$l get 0] = "CWD"} {
            cwd ::= $l get 1;
            if $cwd {
                try {
                    result ::= $cwd clean;
                    if {[$result at -1] != "/"} {
                        $result append! "/";
                    };
                    return $result;
                } catch: {| e |
                    show-message :bell ["Bad CWD line: " . $r];
                };
            };
        };
    };
    return "./";
};

defcommand read-grep-file {
    | main window |
    
    mini-input-until-enter $main $window
        init-value: [pwd : . "/"]
        prompt: "Read grep file: "
        enter-proc: {| value |
            if {[$value len] = 0} {
                show-message :bell "No grep file specified.";
                return ALL;
            };
            file := $value;
            if {file read? $file} else: {
                show-message :bell ["Not readable file: " . $file];
                return ALL;
            };
            ###
            ### do read grep file
            ###
            BufferManager unregist-buffer "*Grep*";
            buff ::= new EditBuffer;
            (result err) ::= $buff load-content $file buffer-name: "*Grep*";
            $result ?? {
                show-message :bell ["Open Failed, path: " . $file " ("  $err ")"];
                return ALL;
            };
            $main create-split-vertical-window;
            $main bind-buffer "Window#1" $buff;
            window ::= $main get-window-by-name "Window#1";
            geom ::= $window get-geom;
            $geom set! ViewLine 0;
            $geom set! ViewColumn 0;
            $window cursor-move-to $geom 0 0;
            return ALL;
        }
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            };
        }
    ;;
    
    result ALL;
};

defcommand cd {
    | main window |
    
    mini-input-until-enter $main $window
        init-value: [pwd : . "/"] 
        prompt: "Directory: "
        enter-proc: {| value |
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return ALL;
            };
            directory := $value;
            cd $directory;
            show-message ["Current directory is: " . $directory];
            return ALL;
        }
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
	}
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            };
        }
    ;;

    result SELF;
};

defcommand set-theme {
    | main window |
    
    mini-input-until-enter $main $window
        prompt: "Theme: "
        enter-proc: {| value |
            t := $THEME;
            setvar THEME $value;
            try {
                init-color-DB;
                $window apply-command $main $window "" refresh-screen;
            } catch: {| e |
                show-message :bell [$e cdr];
                setvar THEME $t;
            };
            return ALL;
        }
    ;;
    
    result ALL;
};

defcommand set-mode {
    | main window |

    mini-input-until-enter $main $window 
        prompt: "Mode: "
        enter-proc: {| value |
            $window set-mode $value;
            $window apply-command $main $window "" refresh-screen;
            return ALL;
        }
    ;;

    result ALL;
};

defcommand goto {
    | main window |

    mini-input-until-enter $main $window
        prompt: "Goto line: "
        enter-proc: {| value |
            if [$value numeric?] else: {
                show-message "Enter line number.";
                return ALL;
            };
            $window mark;
            geom ::= $window get-geom;
            buff ::= $window get-buffer;
            line ::= $value int;
            if {$line > [$buff get-buffer-length]} {
                line ::= $buff get-buffer-length
            };
            $window cursor-move-to $geom $line 0;
            return ALL;
        }
    ;;
    
    result ALL;
};

defcommand set-line-limit {
    | main window |

    mini-input-until-enter $main $window
        prompt: [
            "Line length limit (current=" .
                [[true? INTERP_LIMIT_LEN] ??? $INTERP_LIMIT_LEN "none"] "): "
        ]
        enter-proc: {| value |
            if {$value = ""} {
                show-message "Enter line length limit.";
                return ALL;
            };
            if [$value numeric?] else: {
                if {eq? "auto" $value} {
                    if {defvar? INTERP_LIMIT_LEN} {
                        setvar INTERP_LIMIT_LEN $value;
                    } {
                        defvar INTERP_LIMIT_LEN $value;
                    };
                } {
                    show-message "Enter line length limit.";
                };
                return ALL;
            };
            if {defvar? INTERP_LIMIT_LEN} {
                setvar INTERP_LIMIT_LEN [$value int];
            } {
                defvar INTERP_LIMIT_LEN [$value int];
            };
            return ALL;
        }
    ;;
    
    result SELF;
};

defcommand set-protect {
    | main window |
    buff ::= $window get-buffer;
    $buff set-protect;
    show-message "Buffer is protected.";
    result ALL;
};

defcommand set-noprotect {
    | main window |
    buff ::= $window get-buffer;
    $buff no-protect;
    show-message "Buffer is unprotected.";
    result ALL;
};

defcommand set-dos {
    | main window |
    buff ::= $window get-buffer;
    $buff set-includeCR <t>;
    show-message "Set buffer type to DOS.";
    result ALL;
};

defcommand set-nodos {
    | main window |
    buff ::= $window get-buffer;
    $buff set-includeCR <nil>;
    show-message "Set buffer type to non-DOS.";
    result ALL;
};

defcommand man {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    str := "";
    if [$window get-region] {
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $window get-region-string $sy $sx $ey $ex;
    };

    mini-input-until-enter $main $window
        init-value: $str
        prompt: "Man topic: "
        enter-proc: {| value |
            if {$value = ""} {
                show-message :bell "Enter man topic name.";
                return ALL;
            };
            exec-man $main $window $buff $value;
            return ALL;
        }
    ;;
    
    return ALL;
};

defcommand man-current-word {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;

    orig_geom ::= $geom clone;
    $window apply-command $main $window "" select-region-word;

    [$window in-region?] ?? {
        show-message "Word not found.";
        return ALL;
    };

    (sy sx) ::= $window end-region;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $window get-region-string $sy $sx $ey $ex;
    $geom restore-geom $orig_geom;
    exec-man $main $window $buff $str;
    return ALL;
};

defun exec-man (main window cur-buff topic) {
    ltopic ::= $topic split;
    buff-name ::= if {$ltopic len : >= 2} {"Man=" . $ltopic,1 "(" $ltopic,0 ")"} {"Man=" . $topic};
    man-buff ::= BufferManager find-buffer $buff-name;
    if $man-buff else: {
        os ::= new Stream;
        $os set-nolimit;
        ### sts ::= {exec proc-enc: $MAN_ENCODING "/bin/sh" "-c" [$MAN_PREFIX expand]} redirect-out $os $os;
        sts ::= pipe out: $os {exec :err-to-stdout proc-enc: $MAN_ENCODING "/bin/sh" "-c" [$MAN_PREFIX expand]};
        $os close;
        
        man-buff ::= new EditBuffer;
        (result err) ::= $man-buff load-content
            :init-only
            ["man " . $topic]
            buffer-name: $buff-name
        ;
        $man-buff clear-all;
        $man-buff set-content [$DEFAULT_PWIKI_DIR . "/"];
        
        $os each do: {| r |
            $man-buff append-string [curs-col $r];
        };
        os := <nil>;
        $man-buff set-protect;
        $man-buff no-modify;
    };
    $main bind-buffer [$window get-window-name] $man-buff;
    geom ::= $window get-geom;
    $window cursor-move-to $geom 0 0;
    $man-buff set-previous-buffer [$cur-buff get-buffer-name];

};

defcommand man-click-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= cursor-on-search-regex $ey $ex $MAN_LINK $buff;
    $str ?? {
        show-message :bell "No man topic.";
        return ALL;
    };

    buff ::= $window get-buffer;
    buff-name ::= $buff get-buffer-name;
    
    topic ::= $str split sep: "(" : get 0 : lower;
    section ::= $str split sep: "(" : get 1 : at 0;
    show-message ["Man topic: " . $section " " $topic];
    exec-man $main $window $buff [$section . " " $topic];

    next-buff ::= $window get-buffer;
    $next-buff set-previous-buffer $buff-name;

    return ALL;
};

defcommand man-link-back {
    | main window |
    buff ::= $window get-buffer;
    prev-buff-name ::= $buff get-previous-buffer;
    if $prev-buff-name {
        prev-buff ::= BufferManager find-buffer $prev-buff-name;
        if $prev-buff {
            $main bind-buffer [$window get-window-name] $prev-buff;
        } {
            show-message :bell ["No found previous buffer, \'" . $prev-buff-name "\'."];
        };
    } {
        show-message :bell "No set previous buffer.";
    };
    result ALL;
};

defcommand man-next-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-next-search $ey $ex $MAN_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand man-previous-link {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    (y x) ::= get-previous-search $ey $ex $MAN_LINK $buff;
    $window cursor-move-to $geom $y $x;
    return SELF;
};

defcommand compile {
    | main window |
    
    mini-input-until-enter $main $window
        init-value: [pwd : . "/"]
        prompt: "Directory: "
        enter-proc: {| value |
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return ALL;
            };
            directory := $value;
            if {file dir? $directory} else: {
                show-message :bell ["Not directory: " . $directory];
                return ALL;
            };

            mini-input-until-enter $main $window
                init-value: "make -f Makefile "
                prompt: "Compile: "
                index: 17
                enter-proc: {| value |
                    if {[$value len] = 0} {
                        show-message :bell "No compile command specified.";
                        return ALL;
                    };
                    cmd := $value;
                    
                    ###
                    ### do compile
                    ###
                    cd $directory;
                    fout ::= new Stream;
                    ### sts ::= {exec "/bin/sh" "-c" $cmd} redirect-out $fout $fout;
                    sts := 0;
                    try {
                        pipe out: $fout {exec :err-to-stdout "/bin/sh" "-c" $cmd};
                    } catch: {| e |
                        sts ::= "<" . [$e car] "> #" [$e cdr];
                    };
                    $fout close;
                    buff ::= new EditBuffer;
                    BufferManager unregist-buffer "*Grep*";
                    (result err) ::= $buff load-content  :init-only "grep buffer" buffer-name: "*Grep*";
                    $buff clear-all;
                    $buff append-string ["CWD:  " . $directory];
                    $buff append-string ["EXEC: " . $cmd];
                    $buff append-string "";
                    $fout each do: {| r |
                        $buff append-string $r;
                    };
                    fout := <nil>;
                    $buff append-string "";
                    $buff append-string ["exit(" . $sts ")"];
                    
                    w1 ::= $main get-window-by-name "Window#1";
                    if $w1 else: {
                        $main create-split-vertical-window;
                    };
                    $main bind-buffer "Window#1" $buff;
                    window ::= $main get-window-by-name "Window#1";
                    geom ::= $window get-geom;
                    $geom set! ViewLine 0;
                    $geom set! ViewColumn 0;
                    $window cursor-move-to $geom 0 0;
                    return ALL;
                }
            ;;
            return ALL;
        }
        completion-proc: {| value |
            if {$value = ""} {
                fname ::= show-files-in-window $main $window [get-current-buffer-dir $window];
            } {
                fname ::= show-files-in-window $main $window $value;
            };
	    $window apply-command $main $window "" top-of-buffer;
	    $main mini-input-value-override $fname [$fname len];
	    return ALL;
        }
        keyin-proc: {| value in-key |
            if {eq? $in-key KEY_DOWN} {
                $window apply-command $main $window "" move-half-up;
                return ALL;
            };
            if {eq? $in-key KEY_UP} {
                $window apply-command $main $window "" move-half-down;
                return ALL;
            };
            if {eq? $in-key "/"} {
                if {[$value at -2] = "/"} {
                    $main mini-input-value-override "/" 1;
                };
                return ALL;
            };
            if {eq? $in-key "~"} {
                if {or {[$value len] <= 1} {[$value at -2] = "/"}} {
                    $main mini-input-value-override [$ENV,HOME . "/"] [[$ENV,HOME . "/"] len];
                };
                return ALL;
            }
        }
    ;;
    
    result All;
};

defcommand help {
    | main window |
    help-path ::= $DEFAULT_PWIKI_DIR . $DEFAULT_PWIKI_HOME_FILE;
    buff ::= BufferManager get-buffer-by-path $help-path;
    $buff ?? {
        buff ::= new EditBuffer;
        create-directory-if-not-exists $help-path;
        (result err) ::= $buff load-content $help-path;
        $result ?? {
            show-message :bell ["Open Failed, path: " . $help-path " ("  $err ")"];
            return SELF;
        };
    };
    $main bind-buffer [$window get-window-name] $buff;
    
    return ALL;
};

defun get-shell () {
    if [and [file exec? $DEFAULT_SHELL] [! [file dir? $DEFAULT_SHELL]]] {
        return $DEFAULT_SHELL;
    };
    return $EMERGENCY_SHELL;
};

defcommand shell {
    | main window |
    $main suspend [get-shell];
    result ALL;
};

defcommand git-pull {
    | main window |
    $main suspend [get-shell] "-c" "git pull; echo '--- Press enter key to continue ---'; read";
    result ALL;
};

defcommand git-commit {
    | main window |
    $main suspend [get-shell] "-c" "git commit .; echo '--- Press enter key to continue ---'; read";
    result ALL;
};

defcommand git-push {
    | main window |
    $main suspend [get-shell] "-c" "git push; echo '--- Press enter key to continue ---'; read";
    result ALL;
};

defcommand show-font {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    curs-print [$main get-minibuffer-window : get-curs] $str $DISPLAY_ENCODING 0 0;
    result SELF;
};

defcommand show-keycode {
    | main window |
    show-message "Input key: ";
    i := ();
    while {$i null?} do: {
        (rtime i) ::= curs-keyin [$window get-curs] 1000 $INPUT_ENCODING 
            blink: $BLINK
            blink-fact: $BLINK_FACT
        ;;
    };
    m ::= "" . $i;
    k ::= $main get-keymap $i;
    if $k {
        $m append! " -> ";
        $m append! $k;
    } {
        k := $i;
    };
    $m append! " -> ";
    $m append! [$window get-keybind [$k car]];
    
    show-message $m;
    result SELF;
};

defcommand mini-move-message {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    if {and $str {[$str len] > 0}} {
        (y x) ::= $window get-screen-size;
        message ::= [" " repeat $x] . $str;
        body := {
            set message [$message sub 1];
            if {[$message len] > 0} {
                show-message $message;
                $main add-background $body after: 100;
            } {
                show-message "Done.";
            };
            return ALL;
        };
        $main add-background $body after: 100;
    };
    result SELF;
};

defcommand window-split-ratio-reset {
    | main window |
    setvar VERTICAL_DIV_RATIO 1.0;
    setvar HORIZONTAL_DIV_RATIO 1.0;
    $main refresh-screen;
    result ALL;
};

defcommand window-grow-right {
    | main window |
    if {$VERTICAL_DIV_RATIO > $DIV_RATIO_MIN} {
        setvar VERTICAL_DIV_RATIO [$VERTICAL_DIV_RATIO - $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand window-grow-left {
    | main window |
    if {$VERTICAL_DIV_RATIO < $DIV_RATIO_MAX} {
        setvar VERTICAL_DIV_RATIO [$VERTICAL_DIV_RATIO + $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand window-grow-lower {
    | main window |
    if {$HORIZONTAL_DIV_RATIO > $DIV_RATIO_MIN} {
        setvar HORIZONTAL_DIV_RATIO [$HORIZONTAL_DIV_RATIO - $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand window-grow-upper {
    | main window |
    if {$HORIZONTAL_DIV_RATIO < $DIV_RATIO_MAX} {
        setvar HORIZONTAL_DIV_RATIO [$HORIZONTAL_DIV_RATIO + $DIV_RATIO_RES];
        $main refresh-screen;
    };
    result ALL;
};

defcommand dired {
    | main window |
    dired-open $main $window [pwd];
    return ALL;
};

defun dired-open (main window dir) {
    buff ::= BufferManager get-buffer-by-path $dir;
    if $buff {
        $buff update;
        $main bind-buffer [$window get-window-name] $buff;
        return $buff;
    };
    buff ::= new DiredBuffer;
    $buff load-content $dir;
    $main bind-buffer [$window get-window-name] $buff;
    return $buff;
};

defcommand dired-open {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    if $r {
        l ::= $r split sep: "|";
        if {[$l len] >= 2} {
            name ::= $l get 1;
            path ::= $buff get-path;
            path ::= $path ?? [pwd];
            if {$path = "/"} {
                path ::= path-adjust ["/" . $name];
            } {
                path ::= path-adjust [$path . "/" $name];
            };
            if {file dir? $path} {
                new-buff ::= dired-open $main $window $path;
                $new-buff set-previous-buffer [$buff get-buffer-name];
            } {
                if {file read? $path} {
                    buff ::= BufferManager get-buffer-by-path $path;
                    if $buff {
                        $main bind-buffer [$window get-window-name] $buff;
                        return SELF;
                    };
                    buff ::= new EditBuffer;
                    (result err) ::= $buff load-content $path;
                    if {$buff enc-error?} {
                        show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
                    };
                    $main bind-buffer [$window get-window-name] $buff;
                    $result ?? {show-message :bell ["Open Failed, path: " . $value " ("  $err ")"]};
                } {
                    show-message :bell "File not readable.";
                };
            };
        };
    };
    return ALL;
};

defcommand dired-link-back {
    | main window |
    buff ::= $window get-buffer;
    prev-buff-name ::= $buff get-previous-buffer;
    if $prev-buff-name {
        prev-buff ::= BufferManager find-buffer $prev-buff-name;
        if $prev-buff {
            $main bind-buffer [$window get-window-name] $prev-buff;
        } {
            show-message :bell ["No found previous buffer, \'" . $prev-buff-name "\'."];
        };
    } {
        show-message :bell "No set previous buffer.";
    };
    result ALL;
};

defcommand dired-cursor-up {
    | main window |
    $window move-up;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    if $r {
        l ::= $r split sep: "|";
        if {[$l len] >= 2} {
            $geom set! IndexColumn.SAVE [[$l get 0 : len] + 1];
            $window set-freecursor <nil>;
        };
    };
    return ALL;
};

defcommand dired-cursor-down {
    | main window |
    $window move-down;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    if $r {
        l ::= $r split sep: "|";
        if {[$l len] >= 2} {
            $geom set! IndexColumn.SAVE [[$l get 0 : len] + 1];
            $window set-freecursor <nil>;
        };
    };
    return ALL;
};

defcommand dired-sort-by-name-ascending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "n";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-name-descending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "N";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-time-ascending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "t";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-time-descending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "T";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-size-ascending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "s";
    $buff update;
    return ALL;
};

defcommand dired-sort-by-size-descending {
    | main window |
    buff ::= $window get-buffer;
    $buff set-sort-order "S";
    $buff update;
    return ALL;
};

defcommand dired-filter {
    | main window |
    buff ::= $window get-buffer;
    
    mini-input-until-enter $main $window 
        init-value: [$buff get-filter : string]
        prompt: "Filter: "
        enter-proc: {| value |
            $buff set-filter [$value rquote];
            $buff update;
            return ALL;
        }
    ;;
    
    return ALL;
};

defcommand set-encoder {
    | main window |
    buff ::= $window get-buffer;
    if {$buff modify?} {
        show-message :bell "Buffer is modified. Try again after re-open this file.";
        return SELF;
    };

    mini-input-until-enter $main $window
        prompt: ["Encoding UTF-8(u)/EUC-JP(e)/Shift-JIS(s)/RAW(r) [current is " .
            ["" . [$buff get-encoding]] "]: "]
        keyin-proc: {| value in-key |
            enc := <nil>;
            case  $in-key
                "u" {enc := "UTF-8F"}
                "U" {enc := "UTF-8F"}
                "e" {enc := "EUC-JP"}
                "E" {enc := "EUC-JP"}
                "s" {enc := "Shift-JIS"}
                "S" {enc := "Shift-JIS"}
                "r" {enc := "RAW"}
                "R" {enc := "RAW"}
            ;;
            if $enc {
                $main mini-input-end;
                $buff set-encoding $enc;
                $buff reload-content;
                if {$buff enc-error?} {
                    show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
                    return ALL;
                };
                show-message ["Set encoding to: " . $enc];
                return ALL;
            };
        }
    ;;
    
    result ALL;
};

defcommand set-tab-width {
    | main window |
    tab := 8;
    if {defvar? DEFAULT_TAB_WIDTH} {
        tab := $DEFAULT_TAB_WIDTH;
    };
    
    mini-input-until-enter $main $window
        prompt: ["Set TAB width [current is " . $tab "]: "]
        enter-proc: {| value |
            try {
                if {$value = ""} {
                    tab := $tab; # set closure value to local value.
                } {
                    tab ::= $value int;
                };
            } catch: {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            if {or [$tab <= 0] [$tab >= 256]} {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            if {defvar? DEFAULT_TAB_WIDTH} {
                setvar DEFAULT_TAB_WIDTH $tab;
            } {
                defvar DEFAULT_TAB_WIDTH $tab;
            };
            show-message ["Set TAB width to " . $tab "."];
            return ALL;
        }
    ;;
    
    result ALL;
};

defcommand set-buffer-tab-width {
    | main window |
    buff ::= $window get-buffer;
    tab ::= [$buff get-buffer-tab-width] ?? $DEFAULT_TAB_WIDTH;

    mini-input-until-enter $main $window
        prompt: ["Set buffer TAB width [current is " . $tab "]: "]
        enter-proc: {| value |
            try {
                if {$value = ""} {
                    tab := $tab; # set closure value to local value.
                } {
                    tab ::= $value int;
                };
            } catch: {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            if {or [$tab < 0] [$tab >= 256]} {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            if {$tab = 0} {
                $buff set-buffer-tab-width <nil>;
                $window set-buffer-tab-width;
                show-message "Unset buffer TAB.";
            } {
                $buff set-buffer-tab-width $tab;
                $window set-buffer-tab-width;
                show-message ["Set buffer TAB width to " . $tab "."];
            };
            return ALL;
        }
    ;;
    
    result ALL;
};

defcommand brackets-pair {
    | main window |
    $window remove-spot-color-item "BRACKETS-PAIR-S";
    $window remove-spot-color-item "BRACKETS-PAIR-D";
    (height width) ::= $window get-window-size;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    v ::= $buff get-vector;
    start := $geom,ViewLine;
    end ::= $geom,ViewLine + $height : - 1;
    cur-char ::= $v at $y $x;
    if {and {$y = 0} {$x = 0}} {
        (py px) := (0 0);
        prev-char := "";
    } {
        (py px) ::= $v get-prev-pos $y $x;
        prev-char ::= $v at $py $px;
    };
    if {or {"(" = $cur-char} {")" = $cur-char} {"[" = $cur-char}
           {"]" = $cur-char} {"{" = $cur-char} {"}" = $cur-char}}
    else: {
        cur-char := $prev-char;
        (y x) := ($py $px);
    };
    case $cur-char
       "(" {
           dir := f;
           cap-dec := ")";
           cap-inc := "(";
       }
       "[" {
           dir := f;
           cap-dec := "]";
           cap-inc := "[";
       }
       "{" {
           dir := f;
           cap-dec := "}";
           cap-inc := "{";
       }
       ")" {
           dir := b;
           cap-dec := ")";
           cap-inc := "(";
       }
       "]" {
           dir := b;
           cap-dec := "]";
           cap-inc := "[";
       }
       "}" {
           dir := b;
           cap-dec := "}";
           cap-inc := "{";
       }
       default: {
           return SELF;
       }
    ;;

    find := <nil>;
    case $dir
        f {
            (start-y start-x) ::= $v get-next-pos $y $x;
            level := 1;
            $v each-forward-char $start-y $start-x {
                | cy cx cc |
                if {$cy > $end} {
                    return SELF;
                };
                if {$cc = $cap-dec} {$level --};
                if {$cc = $cap-inc} {$level ++};
                if {$level = 0} {
                    find := <t>;
                    break;
                };
            };
        }
        b {
            (start-y start-x) ::= $v get-prev-pos $y $x;
            level := -1;
            $v each-backward-char $start-y $start-x {
                | cy cx cc |
                if {$cy < $start} {
                    return SELF;
                };
                if {$cc = $cap-dec} {$level --};
                if {$cc = $cap-inc} {$level ++};
                if {$level = 0} {
                    find := <t>;
                    break
                };
            };
        }
    ;;
    if $find {
        $window set-spot-color-item "BRACKETS-PAIR-D" $cy $cx 1 BRACKETS_PAIR;
        $window set-spot-color-item "BRACKETS-PAIR-S" $y $x 1 BRACKETS_PAIR;
    };
    return SELF;
};

defcommand file-completion {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $y;
    $r ?? {
        $window apply-command $main $window "" smart-indent;
        return ALL;
    };
    if {or {$x = 0} {and {$x > 0} {$r at [$x - 1] : = " "}}} {
        $window apply-command $main $window "" smart-indent;
        return ALL;
    };

    dq := <nil>;    
    start := 0;
    [$x - 1] each to: 0 do: {| i |
        c ::= $r at $i;
        if {or {$c = " "} {$c = "\""}} {
            start ::= $i + 1;
            dq ::= [$c = "\""] ??? <t> <nil>;
            break;
        };
    };

    l ::= $r sub $start $x : split sep: "/";
    f ::= $l ->>;
    f ::= $f ?? "";
    if {$l null?} {
        dir ::= $buff get-content-dir : . "/";
    } {
        if {and {$l len : = 1} {$l get 0 : = ""}} {
            dir := "/";
        } {
            if {$r at $start : = "/"} {
                dir ::= $l join sep: "/" : . "/";
            } {
                dir ::= $buff get-content-dir : . "/" [$l join sep: "/"] : . "/";
            };
        };
    };

    try {  
        list ::= file list $dir;
    } catch: {
        show-message :bell ["Directory not found: \"" . $dir "\"."];
        return ALL;
    };
    
    compl ::= path-match $list $f;
    if {$compl len : = 0} {
        show-message :bell ["No match file: \"" . $f "\", in directory (" $dir ")."];
        return all;
    };
    if {$compl len : = 1} {
        if {file dir? [$dir . $compl,0]} {
            $buff line-update [[$r sub 0 [$x - [$f len]]] . $compl,0 "/" [$r sub $x]] $y;
            dx ::= [$compl,0 len] - [$f len] : + 1;
            $window cursor-move-to $geom $y [$x + $dx];
        } {
            $buff line-update [[$r sub 0 [$x - [$f len]]] . $compl,0 [$dq ??? "\" " " "] [$r sub $x]] $y;
            dx ::= [$compl,0 len] - [$f len] : + [$dq ??? 2 1];
            $window cursor-move-to $geom $y [$x + $dx];
        };
        return ALL;
    };
    comp ::= path-longest-match $compl $f;
    $buff line-update [[$r sub 0 [$x - [$f len]]] . $comp [$r sub $x]] $y;
    dx ::= [$comp len] - [$f len];
    $window cursor-move-to $geom $y [$x + $dx];
    show-message [[$compl len : string] . " files matches: " [msort $compl : filter {| i | ! [$i =~ '^[.]+$']} : join sep: " "]];
    
    return ALL;
};

defcommand internal-stat {
    | main window |
    w :wide;
    println "";
    stack-trace : split sep: "\n" : each do: {| i | $stdout puts $i};
    println ["interp stat: " . [$PINTERP stat]];
    println ["interp busy: " . [$MainWindow is-interp-busy]];
    println "";
    println ["stdin stat:  " . [$stdin stat]];
    println ["stdout stat: " . [$stdout stat]];
    println ["stderr stat: " . [$stderr stat]];
    println "";
    println ["info global: " . [info global]];
    println ["PINTERP value: " . $PINTERP];
    slist;

    result ALL;
};
    
defcommand guru-guru {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    message := "-";
    i := 0;
    (y x) ::= $main get-screen-size;
    body := {
        set message [
            case $message
                "-"  "/"
                "/"  "|"
                "|"  "\\"
                "\\" "-"
            ;;
        ];
        show-message [[$message . " "] repeat [$x / 2]];
        $i ++;
        if {$i < 100} {
            $main add-background $body after: 100;
        };
        return ALL;
    };
    $main add-background $body after: 100;
    result SELF;
};

defcommand guru-wave {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    c := "-";
    i := 0;
    (y x) ::= $main get-screen-size;
    body := {
        set c [
            case $c
                "-"   "\\"
                "\\"  "|"
                "|"   "/"
                "/"   "-"
            ;;
        ];
        message := "";
        c1 := $c;
        1 each to: [$x / 2] do: {
            set c1 [
                case $c1
                    "-"   "\\"
                    "\\"  "|"
                    "|"   "/"
                    "/"   "-"
                ;;
            ];
            $message append! $c1 " ";
        };
        show-message $message;
        $i ++;
        if {$i < 100} {
            $main add-background $body after: 100;
        };
        return ALL;
    };
    $main add-background $body after: 100;
    result SELF;
};

defcommand guru-animal {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    c := "";
    i := 0;
    (y x) ::= $main get-screen-size;
    body := {
        set c [
            case $c
                ""  ""
                ""  ""
                ""  ""
                ""  ""
            ;;
        ];
        message := "";
        c1 := $c;
        1 each to: [$x / 2] do: {
            set c1 [
                case $c1
                    ""  ""
                    ""  ""
                    ""  ""
                    ""  ""
                ;;
            ];
            $message append! $c1 " ";
        };
        show-message $message;
        $i ++;
        if {$i < 100} {
            $main add-background $body after: 100;
        };
        return ALL;
    };
    $main add-background $body after: 100;
    result SELF;
};

defcommand para-alphabet {
    | main window |

    f ::= fun (l) {
        if [$l null?] else: {
            c ::= $l >>;
            show-message $c;
            $main add-background {
                $f $l;
                result ALL;
            } after: 500;
        };

    };
    $f ["abcdefghijklmnopqrstuvwxyz" split sep: ""];
    result ALL;
};

######
###### REMARK, Spare for new editor command making.
######
REM {

defcommand {
    | main window |
};

######
}; ### END REMARK
######
