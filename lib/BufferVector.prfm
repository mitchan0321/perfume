##
## define BufferVector method for EditBuffer operations.
##
class BufferVector Vector;

BufferVector method init (args: elem) {
    sets @primitive [vector];
    $elem each do: {| e |
        append-string ["" . $e];
    };
};

BufferVector method insert-string-at-next (char line at) {
    (command ay ax by bx) ::= insert-string-at $char $line $at;
    return ($command $ay $ax $by $bx);
};

BufferVector method insert-string-at (str line at) {
    self ::= self;
    if {$str = ""} {
        if {$line >= [$self len]} {$self append! ""};
        return (delete-region $line $at $line $at);
    };
    
    l ::= $str split sep: "\r";
    times ::= $l len;
    i := 1;
    result := (delete-region [$line + 0] [$at + 0]);
    $l each do: {| elem |
	if {$line < [$self len]} {
	    s ::= $self get $line;
	    if {$at > [$s len]} {at := [$s len]};
	    s1 ::= $s sub 0 $at;
	    s2 ::= $s sub $at;
	    $self set $line [$s1 . $elem $s2];
	    $at ++ [$elem len];
	} {
	    $self append! $elem;
	    at ::= $elem len;
	    line ::= $self len : - 1;
	};
	if {$i = $times} {break};
        $self insert! $line "";
        s1 ::= $self get [$line + 1] : sub 0 $at;
        s2 ::= $self get [$line + 1] : sub $at;
        $self set [$line + 1] $s2;
        $self set [$line - 0] $s1;
        
        $i ++;
	$line ++;
	at := 0;
    };
    $result <<- [$line + 0];
    $result <<- [$at + 0];
    return $result;
};

BufferVector method delete-character-at (line at) {
    self ::= self;
    if {$line >= [$self len]} {
	if {[$self len] = 0} {return (<nil> "" 0 0)};
	return (<nil> "" [$self len] 0);
    };
    s ::= $self get $line;
    len ::= $s len;
    if {and {[$self len] = 1} {$len = 0}} {
	$self resize 0;
	return (insert-string-at "" 0 0);
    };
    if {$len = 0} {
        if {$line = [$self len : - 1]} {
            $self resize [$self len : - 1];
        } {
            $self set [$line + 0] [$self delete! [$line + 1]];
        };
        if {$line >= [$self len]} {
            return (insert-string-at "" $line 0);
        };
	return (insert-string-at "\r" $line 0);
    };
    if {$at >= $len} {
	if {[$line + 1] = [$self len]} {
	    return (insert-string-at "" $line $len);
	};
	$self set $line [$self,$line . [$self get [$line + 1]]];
	if {$line = [$self len : - 2]} {
            $self resize [$self len : - 1];
            if {$line >= [$self len]} {
                return (insert-string-at "" $line 0);
            };
	    return (insert-string-at "\r" $line $len);
	};
        $self delete! [$line + 1];
        if {$line >= [$self len]} {
            return (insert-string-at "" $line 0);
        };
	return (insert-string-at "\r" $line $len);
    };
    s1 ::= $s sub 0 $at;
    c ::= $s sub $at [$at + 1];
    s2 ::= $s sub [$at + 1];
    $self set $line [$s1 . $s2];
    return (insert-string-at $c $line $at);
};

BufferVector method backdelete-character-at (line at) {
    self ::= self;
    if {and {$line >= 1} {$line >= [$self len]}} {
        if {[$self get [$line - 1]] != ""} {
            return (insert-string-at-next "" [$line - 1] [$self get [$line - 1] : len]);
        };
    };
    if {$at = 0} {
	if {$line = 0} {
	    return (<nil> "" 0 0);
	};
	line ::= $line - 1;
	at ::= [$self get $line] len;
	(command char line at) ::= delete-character-at $line $at;
        if {$line >= [$self len]} {
            return (insert-string-at-next "" $line 0);
        };
	return (insert-string-at-next "\r" $line $at);
    };
    at ::= $at - 1;
    (command char line at) ::= delete-character-at $line $at;
    return (insert-string-at-next $char $line $at);
};

##
## This method (Vector::append-string) same as following this:
## if [$Src len] > 0
## then
##   Vector:: insert-string-at
##	["\r" . $str]
##	[[self] len : - 1]
##	[[self] get [$Src len : -1] : len]
## else
##   Vector:: insert-string-at
##     $str 0 0
##
BufferVector method append-string (str) {
    self ::= self;
    $self append! $str;
    if {[$self len] > 1} {
	return (
	    delete-region
	      [$self len : - 2] [$self get [$self len : - 2] : len]
	      [$self len : - 1] [$self get [$self len : - 1] : len]
	    );
    } {
	return (
	    delete-region
	      0 0 0 [$self get 0 : len]
	    );
    };
};

BufferVector method line-update (str y) {
    self ::= self;
    if {$y >= [$self len]} {return (<nil> 0 0)};
    
    r ::= $self get $y;
    $self set $y $str;
    result := (line-update $r $y);
    return $result;
};

BufferVector method delete-region (start-line start-column end-line end-column) {
    self ::= self;
    if {$start-line > $end-line} {
	(start-line end-line) := ($end-line $start-line);
	(start-column end-column) := ($end-column $start-column);
    };
    if {$start-line = $end-line} {
	if {$start-column > $end-column} {
	    (start-column end-column) := ($end-column $start-column);
	};
    };
    if {$start-line < 0} {
	start-line := 0;
    };
    is-eof := <nil>;
    if {$end-line >= [$self len]} {
	end-line ::= $self len : - 1;
        is-eof := <t>;
	if {$end-line < 0} {
	    end-line := 0;
	};
	end-column ::= $self get [$self len : - 1] : len;
    };
    if {$start-line >= [$self len]} {
	return (<nil> 0 0 0);
    };
    if {$start-column > [$self get $start-line : len]} {
	start-column := [$self get $start-line : len];
    };
    if {$end-column > [$self get $end-line : len]} {
	end-column := [$self get $end-line : len];
    };
    at-last := <nil>;
    if {and {$end-line = [$self len : - 1]} {$end-column = [$self get $end-line : len]}} {
	at-last := <t>;
    };

    result-start-line := $start-line;
    result-start-column := $start-column;
    result-str := "";

    ## Region into same line.
    if {$start-line = $end-line} {
	r ::= $self get $start-line;
	s1 ::= $r sub 0 $start-column;
	str ::= $r sub $start-column $end-column;
	s2 ::= $r sub $end-column;
        $self set $start-line [$s1 . $s2];
	$result-str append! $str;
        if $is-eof {
            $result-str append! "\r";
        };
	if {and $at-last {[$self len] >= 1} {[$self get [$self len : - 1]] = ""}} {
	    $self resize [$self len : - 1];
	};
        return (insert-string-at $result-str $result-start-line $result-start-column);
    };

    ## Regin into 2 lines.
    if {$start-line = [$end-line - 1]} {
	s1 ::= $self get $start-line : sub 0 $start-column;
	$result-str append! [$self get $start-line : sub $start-column];
	$result-str append! "\r";
	$result-str append! [$self get $end-line : sub 0 $end-column];
        if $is-eof {
            $result-str append! "\r";
        };
	s2 ::= $self get $end-line : sub  $end-column;
        $self set $start-line [$s1 . $s2];
	if {[$self len : - 1] <= $end-line} {
	    $self resize [$self len : - 1];
	} {
            $self delete! $end-line;
	};
	if {and $at-last {[$self len] >= 1} {[$self get [$self len : - 1]] = ""}} {
	    $self resize [$self len : - 1];
	};
	return (insert-string-at $result-str $result-start-line $result-start-column);
    };

    ## Regin over 3 lines.
    s1 ::= $self get $start-line : sub 0 $start-column;
    $result-str append! [$self get $start-line : sub $start-column];
    $result-str append! "\r";
    [$start-line + 1] each to: [$end-line - 1] do: {| i |
	$result-str append! [$self get $i];
	$result-str append! "\r";
    };
    $result-str append! [$self get $end-line : sub 0 $end-column];
    if $is-eof {
        $result-str append! "\r";
    };
    s2 ::= $self get $end-line : sub  $end-column;
    $self set $start-line [$s1 . $s2];
    n ::= $end-line - $start-line;
    1 each to: $n do: {
        $self delete! [$start-line + 1];
    };
    
    if {and $at-last {[$self len] >= 1} {[$self get [$self len : - 1]] = ""}} {
        $self resize [$self len : - 1];
    };
    return (insert-string-at $result-str $result-start-line $result-start-column);
};

BufferVector method copy-region (start-line start-column end-line end-column) {
    self ::= self;
    if {$start-line > $end-line} {
	(start-line end-line) := ($end-line $start-line);
	(start-column end-column) := ($end-column $start-column);
    };
    if {$start-line = $end-line} {
	if {$start-column > $end-column} {
	    (start-column end-column) := ($end-column $start-column);
	};
    };
    if {$start-line < 0} {
	start-line := 0;
    };
    is-eof := <nil>;
    if {$end-line >= [$self len]} {
	end-line ::= $self len : - 1;
        is-eof := <t>;
	if {$end-line < 0} {
	    end-line := 0;
	};
	end-column ::= $self get [$self len : - 1] : len;
    };
    if {$start-line >= [$self len]} {
	return (<nil> "" 0 0);
    };
    if {$start-column > [$self get $start-line : len]} {
	start-column := [$self get $start-line : len];
    };
    if {$end-column > [$self get $end-line : len]} {
	end-column := [$self get $end-line : len];
    };

    result-str := "";

    ## Region into same line.
    if {$start-line = $end-line} {
	r ::= $self get $start-line;
	str ::= $r sub $start-column $end-column;
	$result-str append! $str;
        if $is-eof {
            $result-str append! "\r";
        };
	return (insert-string-at $result-str $start-line $start-column);
    };

    ## Regin into 2 lines.
    if {$start-line = [$end-line - 1]} {
	$result-str append! [$self get $start-line : sub $start-column];
	$result-str append! "\r";
	$result-str append! [$self get $end-line : sub 0 $end-column];
        if $is-eof {
            $result-str append! "\r";
        };
	return (insert-string-at $result-str $start-line $start-column);
    };

    ## Regin over 3 lines.
    $result-str append! [$self get $start-line : sub $start-column];
    $result-str append! "\r";
    [$start-line + 1] each to: [$end-line - 1] do: {| i |
	$result-str append! [$self get $i];
	$result-str append! "\r";
    };
    $result-str append! [$self get $end-line : sub 0 $end-column];
    if $is-eof {
	$result-str append! "\r";
    };
    return (insert-string-at $result-str $start-line $start-column);
};

BufferVector method each-forward-char (sl sc body) {
    self ::= self;
    to ::= $self len : - 1;
    if {$sl > $to} {return};
    src ::= [$self get $sl] . "\r";
    if {[$src len] > 0} {
        if {$sc < [$src len]} {
            $sc each to: [$src len : - 1] do: {| j |
                result := ([yield $body $sl $j [$src at $j]]);
                if [control? [$result car]] {return};
            };
        };
    };
    $sl ++;
    if {$sl > $to} {return};
    $sl each to: $to do: {| i |
        src ::= [$self get $i] . "\r";
        if {[$src len] > 0} {
            0 each to: [$src len : - 1] do: {| j |
                result := ([yield $body $i $j [$src at $j]]);
                if [control? [$result car]] {return};
            };
        };
    };
};

BufferVector method each-backward-char (sl sc body) {
    self ::= self;
    to := 0;
    if {[$self len] = 0} {return};
    if {$sl >= [$self len : - 1]} {sl ::= $self len : - 1};
    src ::= [$self get $sl] . "\r";
    if {[$src len] > 0} {
        if {$sc >= [$src len]} {sc ::= $src len : - 1};
        $sc each to: 0 do: {| j |
            result := ([yield $body $sl $j [$src at $j]]);
            if [control? [$result car]] {return};
        };
    };
    $sl --;
    if {$sl < 0} {return};
    $sl each to: $to do: {| i |
        src ::= [$self get $i] . "\r";
        if {[$src len] > 0} {
            [$src len : - 1] each to: 0 do: {| j |
                result := ([yield $body $i $j [$src at $j]]);
                if [control? [$result car]] {return};
            };
        };
    };
};

BufferVector method get-next-pos (y x) {
    self ::= self;
    if {[$self len] <= 0} {return (0 0)};
    
    $x ++;
    if {$y < [len]} {
        if {$y < 0} {
            return (0 0);
        };
        r ::= get $y;
        if {$x <= [$r len]} {return ($y $x)};
        $y ++;
        x := 0;
        return ($y $x);
    };
    
    y ::= len;
    return ($y 0);
};

BufferVector method get-prev-pos (y x) {
    $x --;
    if {$x < 0} {
        $y --;
        if {$y >= 0} {
            x ::= get $y : len;
        } {
            y := 0;
            x := 0;
        };
    };
    return ($y $x);
};

BufferVector method at (y x) {
    self ::= self;
    if {or {$y < 0} {$y >= [$self len]}} {return ""};
    return [get $y : at $x];
};
