###
### Pmacs editor utility command definition.
###

defcommand key-binding-list desc: "Display key binding list and all editor commands." {
    | main window |
    cur-buff ::= $window get-buffer;
    mode ::= $window get-mode;
    BufferManager unregist-buffer "*Key Binding*";
    buff ::= new EditBuffer;
    $buff load-content "key binding" :init-only buffer-name: "*Key Binding*";
    $buff set-content [$DEFAULT_PWIKI_DIR . "/"];
    $buff clear-all;

    $buff append-string  "<<< Key bindings >>>";
    $buff append-string ["  Keybind mode: %v" fmt $KEYBIND_MODE];
    $buff append-string ["  Buffer mode: %v" fmt $mode ];
    $buff append-string "";
    ### $buff append-string "";
    ### $buff append-string ["%-15v %21v %-14v %-v" fmt  "Key group"     "Key combinations"  "Key symbol"       "Command"];
    ### $buff append-string ["%-15v %21v %-14v %-v" fmt ["-" repeat 15] ["-" repeat 21] ["-" repeat 14] ["-" repeat 38]];
    $buff append-string ["%21v %-38v %-v" fmt "Key combination" "Command" "Description"];
    $buff append-string ["%21v %-38v %-v" fmt ["-" repeat 21]   ["-" repeat 38] ["-" repeat 11]];

    d ::= $window get-bind-map DEFAULT;
    desc ::= $window get-key-desc;
    display-key-binding-list $buff "Default key bind" $d $desc;
    $buff append-string "";
    
    $window get-prefix-list : each do: {| i |
        display-key-binding-list $buff ["Prefix key: " . [$window get-prefix-key $i : map {| j | symbol [getkeydesc $j]}] " / Name: " $i] [$window get-bind-map $i] $desc;
        $buff append-string "";
    };
        
    $buff append-string "<<< All editor commands >>>";
    $buff append-string ["%v <- %v" fmt "Command" "Key bindings"];
    $buff append-string "  Description";
    $buff append-string ["%v" fmt ["-" repeat [38 * 2]]];
    msort [$EditorCommand keys :string] : each do: {| i |
        if {"" . $i : at 0 : = "."} {continue};
        binds ::= get-keybind-string $window $i;
        if {$binds != ""} {
            $buff append-string ["%v <- %v" fmt ["[[" . $i "]]"] $binds];
        } {
            $buff append-string ["%v" fmt ["[[" . $i "]]"]];
        };
        $buff append-string ["  " . [get-command-desc $i]];
    };
    $buff no-modify;
    $buff set-protect;
    
    $main bind-buffer [$window get-window-name] $buff;
    $buff set-previous-buffer [$cur-buff get-buffer-name];
    $window set-mode "PWiki";

    result SELF;
};

defun display-key-binding-list (buff name key-map desc) {
    l := ();
    $key-map each do: {| k v |
	if {nil? $v} {continue};
        if {"" . $v : at 0 : = "."} {continue};
        if [$desc set? $k] {
            s ::= $desc get $k;
            ls ::= $s split;
            grp ::= $ls get 0;
            modify ::= $ls get 1;
            $l << ["%-17v%21v %-20v %-38v %-v" fmt $grp $modify $k ["[[" . $v "]]"] [get-command-desc $v]];
        } {
            $l << ["%-17v%21v %-20v %-38v %-v" fmt "" (key input) $k ["[[" . $v "]]"] [get-command-desc $v]];
        };
    };
    $buff append-string $name;
    msort $l : each do: {| i |
	$buff append-string ["" . [$i sub 17 38] [$i sub 59]];
    };
};

defcommand file-completion desc: "File completion and insert file name to current buffer at cursor position." {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $y;
    $r ?? {
        $window apply-command $main $window "" smart-indent;
        return ALL;
    };
    if {or {$x = 0} {and {$x > 0} {$r at [$x - 1] : = " "} {$r at [$x - 1] : = "\t"}}} {
        $window apply-command $main $window "" smart-indent;
        return ALL;
    };

    dq := <nil>;    
    start := 0;
    [$x - 1] each to: 0 do: {| i |
        c ::= $r at $i;
        if {or {$c = " "} {$c = "\t"} {$c = "\""}} {
            start ::= $i + 1;
            dq ::= [$c = "\""] ??? <t> <nil>;
            break;
        };
    };

    l ::= $r sub $start $x : split sep: "/";
    f ::= $l ->>;
    f ::= $f ?? "";
    if {$l null?} {
        dir ::= $buff get-content-dir : . "/";
    } {
        if {and {$l len : = 1} {$l get 0 : = ""}} {
            dir := "/";
        } {
            if {$r at $start : = "/"} {
                dir ::= $l join sep: "/" : . "/";
            } {
                dir ::= $buff get-content-dir : . "/" [$l join sep: "/"] : . "/";
            };
        };
    };

    try {  
        list ::= file list $dir;
    } catch: {
        show-message :bell ["Directory not found: \"" . $dir "\"."];
        return ALL;
    };
    
    compl ::= path-match $list $f;
    if {$compl len : = 0} {
        show-message :bell ["No match file: \"" . $f "\", in directory (" $dir ")."];
        return all;
    };
    if {$compl len : = 1} {
        if {file dir? [$dir . $compl,0]} {
            $buff line-update [[$r sub 0 [$x - [$f len]]] . $compl,0 "/" [$r sub $x]] $y;
            dx ::= [$compl,0 len] - [$f len] : + 1;
            $window cursor-move-to $geom $y [$x + $dx];
        } {
            $buff line-update [[$r sub 0 [$x - [$f len]]] . $compl,0 [$dq ??? "\" " " "] [$r sub $x]] $y;
            dx ::= [$compl,0 len] - [$f len] : + [$dq ??? 2 1];
            $window cursor-move-to $geom $y [$x + $dx];
        };
        return ALL;
    };
    comp ::= path-longest-match $compl $f;
    $buff line-update [[$r sub 0 [$x - [$f len]]] . $comp [$r sub $x]] $y;
    dx ::= [$comp len] - [$f len];
    $window cursor-move-to $geom $y [$x + $dx];
    show-message [[$compl len : string] . " files matches: " [msort $compl : filter {| i | ! [$i =~ '^[.]+$']} : join sep: " "]];
    
    return ALL;
};

defcommand execute-command desc: "Execute Perfume language command next display command result at mini-window." {
    | main window |
    
    mini-input-until-enter $main $window
        prompt: "Perfume command: "
        enter-proc: {| value |
	    try {
	        result ::= $value eval;
	        show-message ["Command result: " . [$result string]];
            } catch: {| e |
		show-message :bell ["<" . [$e car ] "># " [$e cdr]];
	    };
	}
    ;;

    result ALL;
};

defcommand execute-editor-command desc: "Execute editor command." {
    | main window |
    if {defvar? EditorCommandList} 
    then: {setvar EditorCommandList ()}
    else: {defvar EditorCommandList ()};

    mini-input-until-enter $main $window
        prompt: "Editor command: "
        enter-proc: {| value |
            $main set-last-command $value;
	    $window apply-command $main $window "" [symbol $value];
	}
        edit-proc: {| value |
            try {
                setvar EditorCommandList [msort [$EditorCommand keys :string : filter {| i | $i =~ [$value rquote]}]];
            } catch: {
                setvar EditorCommandList ();
            };
	    $EditorCommandList ?? {setvar EditorCommandList ()};
	}
        completion-proc: {| value |
	    i ::= $EditorCommandList find $value;
	    if $i {$i ++} {i := 0};
	    c ::= $EditorCommandList get $i;
	    $c ?? {c ::= $EditorCommandList get 0};
	    $c ?? {c := $value};
	    $main mini-input-value-override $c [$c len];
        }
    ;;

    result ALL;
};

defcommand trace-editor-command desc: "Trace editor command and output trace result file \"pmacs-trace.txt\" at current directory." {
    | main window |
    if {defvar? EditorCommandList} 
    then: {setvar EditorCommandList ()}
    else: {defvar EditorCommandList ()};

    mini-input-until-enter $main $window
        prompt: "Trace editor command: "
        enter-proc: {| value |
            f := `File("pmacs-trace.txt" mode: a);
            $f puts  "";
            $f puts  "***";
            $f puts  "***";
            $f puts ["*** Editor command: " . $value];
            err := <nil>;
	    try {
                trace {$window apply-command $main $window "" [symbol $value]} out: [$f fd?];
            } catch: {| err |};
            if $err {
                $f puts ["ERROR: " $err];
            };
            $f puts  "***";
            $f puts  "";
            $f close;
            show-message ["Wrote tracefile to: " . [pwd] "/" "pmacs-trace.txt"];
	}
        edit-proc: {| value |
            try {
                setvar EditorCommandList [msort [$EditorCommand keys :string : filter {| i | $i =~ [$value rquote]}]];
            } catch: {
                setvar EditorCommandList ();
            };
	    $EditorCommandList ?? {setvar EditorCommandList ()};
	}
        completion-proc: {| value |
	    i ::= $EditorCommandList find $value;
	    if $i {$i ++} {i := 0};
	    c ::= $EditorCommandList get $i;
	    $c ?? {c ::= $EditorCommandList get 0};
	    $c ?? {c := $value};
	    $main mini-input-value-override $c [$c len];
	}
    ;;
    
    result ALL;
};

defcommand eval-region desc: "Eval selected region and output result to *Scratch* buffer." {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    $window mark;

    if [$window get-region] {
	### eval region
        (sy sx) ::= $window end-region;
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $window get-region-string $sy $sx $ey $ex;
    } {
        ### eval this line
        (ey ex) ::= $window get-source-index $buff $geom;
        str ::= $buff get-buffer-line $ey;
        str ::= $str ?? "";
 #       if {and {[$buff get-buffer-length : - 1] > $ey} {$str != ""}} {
 #           if {[$buff get-buffer-name] = "*Scratch*"} {
 #               $buff append-string $str;
 #           };
 #       };
    };

    $window apply-command $main $window "" cursor-top-of-line;
    $window apply-command $main $window "" cursor-down;

    $stdin puts $str;
    $window display-evaluation;
    
    result ALL;
};

defcommand kill-interp desc: "Kill current running process and perfume interpriter under *Scratch* buffer." {
    | main window |
    
    mini-input-y-or-n $main $window 
        prompt: "kill interpriter OK? [y/n]: "
        yes-proc: {
            if {defvar? PINTERP} {
                try {$PINTERP release} catch: {};
            };
            reset-stdio;
            $stderr puts "Interpriter killed.";
        }
    ;;

    result ALL;
};

defcommand send-eof desc: "Send EOF to current running process or perfume interpriter under *Scratch* buffer." {
    | main window |
    $stderr puts "Send eof.";
    $stdin close;
    result ALL;
};

defcommand cd desc: "Change current directory at pmacs globally." {
    | main window |
    
    pwd ::= pwd;
    if {$pwd = "/"} else: {pwd ::= $pwd . "/"};
    mini-input-file-chooser $main $window
        init-value: $pwd
        prompt: "Directory: "
        enter-proc: {| value |
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return ALL;
            };
            directory := $value;
            cd $directory;
            show-message ["Current directory is: " . $directory];
            return ALL;
        }
    ;;

    result SELF;
};

defcommand set-theme desc: "Set theme you specified." {
    | main window |
    
    mini-input-until-enter $main $window
        prompt: "Theme: "
        enter-proc: {| value |
            t := $THEME;
            setconf THEME [symbol $value];
            try {
                init-color-DB;
                $window apply-command $main $window "" refresh-screen;
            } catch: {| e |
                show-message :bell [$e cdr];
                setconf THEME $t;
            };
            return ALL;
        }
    ;;
    
    result ALL;
};

defcommand set-mode desc: "Set current buffer mode you specified." {
    | main window |

    mini-input-until-enter $main $window 
        prompt: "Mode: "
        enter-proc: {| value |
            $window set-mode $value;
            $window apply-command $main $window "" refresh-screen;
            return ALL;
        }
    ;;

    result ALL;
};

defcommand set-line-limit desc: "Set *Scratch* buffer window max line length. if you specified \"auto\", fit to current window width." {
    | main window |

    mini-input-until-enter $main $window
        prompt: [
            "Line length limit (current=" .
                [[true? INTERP_LIMIT_LEN] ??? $INTERP_LIMIT_LEN "none"] "): "
        ]
        enter-proc: {| value |
            if {$value = ""} {
                show-message "Enter line length limit.";
                return ALL;
            };
            if [$value numeric?] else: {
                if {eq? "auto" $value} {
                    unsetconf INTERP_LIMIT_LEN;
                    setconf INTERP_LIMIT_LEN $value;
                } {
                    show-message "Enter line length limit.";
                };
                return ALL;
            };
            unsetconf INTERP_LIMIT_LEN;
            setconf INTERP_LIMIT_LEN [$value int];
            return ALL;
        }
    ;;
    
    result SELF;
};

defcommand set-protect desc: "Set protect mode to current buffer." {
    | main window |
    buff ::= $window get-buffer;
    $buff set-protect;
    show-message "Buffer is protected.";
    result ALL;
};

defcommand set-noprotect desc: "Unset protect mode to current buffer." {
    | main window |
    buff ::= $window get-buffer;
    $buff no-protect;
    show-message "Buffer is unprotected.";
    result ALL;
};

defcommand set-dos desc: "Set DOS line mode to current buffer." {
    | main window |
    buff ::= $window get-buffer;
    $buff set-includeCR <t>;
    show-message "Set buffer type to DOS.";
    result ALL;
};

defcommand set-nodos desc: "Unset DOS line mode (aka set UNIX line mode) to current buffer." {
    | main window |
    buff ::= $window get-buffer;
    $buff set-includeCR <nil>;
    show-message "Set buffer type to non-DOS.";
    result ALL;
};

defcommand compile desc: "Run compile command and output result to *Grep* buffer." {
    | main window |
    
    dir := $COMPILE_COMMAND_DIR;
    mini-input-file-chooser $main $window
        init-value: $dir
        prompt: "Directory: "
        enter-proc: {| value |
            if {[$value len] = 0} {
                show-message :bell "No directory specified.";
                return ALL;
            };
            directory := $value;
            setconf COMPILE_COMMAND_DIR $directory;
            if {file dir? $directory} else: {
                show-message :bell ["Not directory: " . $directory];
                return ALL;
            };

            command := $COMPILE_COMMAND;
            mini-input-until-enter $main $window
                init-value: $command
                index: [$command len]
                prompt: "Compile: "
                enter-proc: {| value |
                    if {[$value len] = 0} {
                        show-message :bell "No compile command specified.";
                        return ALL;
                    };
                    setconf COMPILE_COMMAND $value;
                    
                    do-command-async $window "*Grep*" $directory $value;
                    return ALL;
                }
            ;;
            return ALL;
        }
    ;;
    
    result ALL;
};

defun do-command-async (window buff-name directory command) {
    BufferManager unregist-buffer $buff-name;
    grep-buff ::= new EditStream;
    $grep-buff open $buff-name;
    _puts ::= $grep-buff method? puts;
    $grep-buff method puts (*) {
        r ::= call $_puts $*;
        $MainWindow get-window-list : each do: {| i |
            if {$i get-buffer : get-buffer-name : = $buff-name} {
                $MainWindow set-force-update;
            };
        };
        return $r;
    };
    $grep-buff get-buffer : set-content $directory;
    $grep-buff set-columnlimit 1024;
    $grep-buff puts ["CWD:  " . $directory];
    $grep-buff puts ["EXEC: " . $command];
    $grep-buff puts "";
    w1 ::= $MainWindow get-window-by-name "Window#1";
    if $w1 else: {
        $MainWindow create-split-vertical-window window-name: "Window#1";
    };
    window ::= $MainWindow get-window-by-name "Window#1";
    $MainWindow bind-buffer "Window#1" [$grep-buff get-buffer];
    
    task ::= new Task;
    $task set-stdout $grep-buff;
    $task set-stderr $grep-buff;
    $task set-terminate-proc {
        $MainWindow set-force-update;
    };
    
    ###
    ### do command
    ###
    $task proc [$command split : get 0] {
        (window buff cmd directory) := $ARGS;
        cd $directory;
        sts ::= exec sh -c $cmd;
        println "";
        println "exit(" $sts ")";
        
        SysCall apply-editor {
            $buff set-protect;
            $buff no-modify;
            if {eq? [$window get-buffer] $buff} {
                geom ::= $window get-geom;
                $geom set! ViewLine 0;
                $geom set! ViewColumn 0;
                $window cursor-move-to $geom 0 0;
            };
        };
        
    } $window [$grep-buff get-buffer] $command $directory;

    return;
};

defun get-shell () {
    if [and [file exec? $DEFAULT_SHELL] [! [file dir? $DEFAULT_SHELL]]] {
        return $DEFAULT_SHELL;
    };
    return $EMERGENCY_SHELL;
};

defcommand shell desc: "Suspend pmacs and run shell under pmacs process." {
    | main window |
    $main suspend [get-shell];
    result ALL;
};

defcommand git-pull desc: "Git pull (test)." {
    | main window |
    mini-input-file-chooser $main $window
    init-value: $GIT_DIR
    prompt: "(git pull) directory: "
    enter-proc: {| value |
        if {[$value len] = 0} {
            show-message :bell "No directory specified.";
            return ALL;
        };
        directory := $value;
        setconf GIT_DIR $directory;
        if {file dir? $directory} else: {
            show-message :bell ["Not directory: " . $directory];
            return ALL;
        };

        command := "pull";
        file := "";
        opts := "";
        post_command := "echo '--- Press enter key to continue ---'; read a";
        exec_command ::= $GIT_COMMAND expand;
        $main suspend "env" $GIT_ENV [get-shell] "-c" $exec_command;
    }
    ;;

    result ALL;
};

defcommand git-commit desc: "Git commit (test)." {
    | main window |
    directory := $GIT_DIR;
    cd $directory;
    mini-input-file-chooser $main $window
    init-value: $directory
    prompt: "(git commit) file or directory: "
    enter-proc: {| value |
        if {[$value len] = 0} {
            show-message :bell "No file specified.";
            return ALL;
        };
        if {file dir? $value} {
            directory := $value;
            file := ".";
        } {
            directory ::= get-dir $value;
            if {! [file dir? $directory]} {
                show-message :bell "Bad directory specified.";
                return ALL;
            };
            file ::= $value split sep: "/" : last : car;
            if {$file = ""} {file := "."};
        };
        setconf GIT_DIR $directory;
        command := "commit";
        opts := "";
        post_command := "";
        exec_command ::= $GIT_COMMAND expand;
        t ::= new Task;
        $t set-stdout $stdout;
        $t set-stderr $stderr;
        $t proc git-commit {
            (exec_command) := $ARGS;
            exec "env" $GIT_ENV [get-shell] "-c" $exec_command;
        } $exec_command;
    }
    ;;
    
    result ALL;
};

defcommand git-push desc: "Git push (test)." {
    | main window |
    mini-input-file-chooser $main $window
    init-value: $GIT_DIR
    prompt: "(git push) directory: "
    enter-proc: {| value |
        if {[$value len] = 0} {
            show-message :bell "No directory specified.";
            return ALL;
        };
        directory := $value;
        setconf GIT_DIR $directory;
        if {file dir? $directory} else: {
            show-message :bell ["Not directory: " . $directory];
            return ALL;
        };

        command := "push";
        file := "";
        opts := "";
        post_command := "echo '--- Press enter key to continue ---'; read a";
        exec_command ::= $GIT_COMMAND expand;
        $main suspend "env" $GIT_ENV [get-shell] "-c" $exec_command;
    }
    ;;

    result ALL;
};

defcommand git-diff desc: "Git diff (test)." {
    | main window |
    mini-input-file-chooser $main $window
    init-value: $GIT_DIR
    prompt: "(git diff) directory: "
    enter-proc: {| value |
        if {[$value len] = 0} {
            show-message :bell "No directory specified.";
            return ALL;
        };
        directory := $value;
        setconf GIT_DIR $directory;
        if {file dir? $directory} else: {
            show-message :bell ["Not directory: " . $directory];
            return ALL;
        };

        do-command-async $window "*Git-diff*" $directory "git diff";
        result ALL;
    }
    ;;

    result ALL;
};

defcommand git-status desc: "Git status (test)." {
    | main window |
    mini-input-file-chooser $main $window
    init-value: $GIT_DIR
    prompt: "(git status) directory: "
    enter-proc: {| value |
        if {[$value len] = 0} {
            show-message :bell "No directory specified.";
            return ALL;
        };
        directory := $value;
        setconf GIT_DIR $directory;
        if {file dir? $directory} else: {
            show-message :bell ["Not directory: " . $directory];
            return ALL;
        };

        do-command-async $window "*Git-status*" $directory "git status";
        result ALL;
    }
    ;;

    result ALL;
};

defcommand show-font desc: "Display current cursor buffer line direct to mini-windodw." {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (ey ex) ::= $window get-source-index $buff $geom;
    str ::= $buff get-buffer-line $ey;
    str ::= $str ?? "";
    curs-print [$main get-minibuffer-window : get-curs] $str $DISPLAY_ENCODING 0 0;
    result SELF;
};

defcommand show-keycode desc: "Display input keys key code, key sequence and binding editor command." {
    | main window |
    show-message "Input key: ";
    i := ();
    while {$i null?} do: {
        (rtime i) ::= curs-keyin [$window get-curs] 1000 $INPUT_ENCODING 
            blink: $BLINK
            blink-fact: $BLINK_FACT
        ;;
    };
    m ::= "" . $i;
    k ::= $main get-keymap $i;
    if $k {
        $m append! " -> ";
        $m append! $k;
    } {
        k := $i;
    };
    $m append! " -> ";
    $m append! [$window get-keybind DEFAULT [$k car]];
    
    show-message $m;
    result SELF;
};

defcommand set-encoder desc: "Set encoding to current buffer next reload file. You can specified UTF-8, EUC-JP, Shift-JIS and RAW encoding. This command need the buffer is protected." {
    | main window |
    buff ::= $window get-buffer;
    if {$buff modify?} {
        show-message :bell "Buffer is modified. Try again after re-open this file.";
        return SELF;
    };

    mini-input-until-enter $main $window
        prompt: ["Encoding UTF-8(u)/EUC-JP(e)/Shift-JIS(s)/RAW(r) [current is " .
            ["" . [$buff get-encoding]] "]: "]
        keyin-proc: {| value in-key |
            enc := <nil>;
            case  $in-key
                "u" {enc := "UTF-8F"}
                "U" {enc := "UTF-8F"}
                "e" {enc := "EUC-JP"}
                "E" {enc := "EUC-JP"}
                "s" {enc := "Shift-JIS"}
                "S" {enc := "Shift-JIS"}
                "r" {enc := "RAW"}
                "R" {enc := "RAW"}
            ;;
            if $enc {
                $main mini-input-end;
                $buff set-encoding $enc;
                $buff reload-content;
                if {$buff enc-error?} {
                    show-message :bell "File decode error occured!! Try ALT-e and specify another encoding for re-load.";
                    return ALL;
                };
                show-message ["Set encoding to: " . $enc];
                return ALL;
            };
        }
    ;;
    
    result ALL;
};

defcommand set-buffer-encoder desc: "Set buffer encoding to current buffer." {
    | main window |
    buff ::= $window get-buffer;

    mini-input-until-enter $main $window
        prompt: ["Encoding UTF-8(u)/EUC-JP(e)/Shift-JIS(s)/RAW(r) [current is " .
            ["" . [$buff get-encoding]] "]: "]
        keyin-proc: {| value in-key |
            enc := <nil>;
            case  $in-key
                "u" {enc := "UTF-8F"}
                "U" {enc := "UTF-8F"}
                "e" {enc := "EUC-JP"}
                "E" {enc := "EUC-JP"}
                "s" {enc := "Shift-JIS"}
                "S" {enc := "Shift-JIS"}
                "r" {enc := "RAW"}
                "R" {enc := "RAW"}
            ;;
            if $enc {
                $main mini-input-end;
                $buff set-encoding $enc;
                show-message ["Set encoding to: " . $enc];
                return ALL;
            };
        }
    ;;
    
    result ALL;
};

defcommand set-tab-width desc: "Set TAB width globally. Default is 8." {
    | main window |
    tab := 8;
    if {defvar? DEFAULT_TAB_WIDTH} {
        tab := $DEFAULT_TAB_WIDTH;
    };
    
    mini-input-until-enter $main $window
        prompt: ["Set TAB width [current is " . $tab "]: "]
        enter-proc: {| value |
            try {
                if {$value = ""} {
                    tab := $tab; # set closure value to local value.
                } {
                    tab ::= $value int;
                };
            } catch: {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            if {or [$tab <= 0] [$tab >= 256]} {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            setconf DEFAULT_TAB_WIDTH $tab;
            show-message ["Set TAB width to " . $tab "."];
            return ALL;
        }
    ;;
    
    result ALL;
};

defcommand set-buffer-tab-width desc: "Set TAB width to current buffer locally. If you specified 0, set global TAB width to current buffer." {
    | main window |
    buff ::= $window get-buffer;
    tab ::= [$buff get-buffer-tab-width] ?? $DEFAULT_TAB_WIDTH;

    mini-input-until-enter $main $window
        prompt: ["Set buffer TAB width [current is " . $tab "]: "]
        enter-proc: {| value |
            try {
                if {$value = ""} {
                    tab := $tab; # set closure value to local value.
                } {
                    tab ::= $value int;
                };
            } catch: {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            if {or [$tab < 0] [$tab >= 256]} {
                show-message :bell "Illegal TAB number specified.";
                return ALL;
            };
            if {$tab = 0} {
                $buff set-buffer-tab-width <nil>;
                $window set-buffer-tab-width;
                show-message "Unset buffer TAB.";
            } {
                $buff set-buffer-tab-width $tab;
                $window set-buffer-tab-width;
                show-message ["Set buffer TAB width to " . $tab "."];
            };
            return ALL;
        }
    ;;
    
    result ALL;
};

defcommand brackets-pair desc: "Highlight pair character if current cursor on parentheses, bracket  or braces." {
    | main window |
    if {! [$window instance? CombiWindow]} {return SELF};
    
    $window remove-spot-color-item "BRACKETS-PAIR-S";
    $window remove-spot-color-item "BRACKETS-PAIR-D";
    (height width) ::= $window get-window-size;
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    (y x) ::= $window get-source-index $buff $geom;
    v ::= $buff get-vector;
    if {$y >= [$v len]} {return NONE};
    start := $geom,ViewLine;
    end ::= $geom,ViewLine + $height : - 1;
    cur-char ::= $v at $y $x;
    if {and {$y = 0} {$x = 0}} {
        (py px) := (0 0);
        prev-char := "";
    } {
        (py px) ::= $v get-prev-pos $y $x;
        prev-char ::= $v at $py $px;
    };
    if {or {"(" = $cur-char} {")" = $cur-char} {"[" = $cur-char}
           {"]" = $cur-char} {"{" = $cur-char} {"}" = $cur-char}}
    else: {
        cur-char := $prev-char;
        (y x) := ($py $px);
    };
    case $cur-char
       "(" {
           dir := f;
           cap-dec := ")";
           cap-inc := "(";
       }
       "[" {
           dir := f;
           cap-dec := "]";
           cap-inc := "[";
       }
       "{" {
           dir := f;
           cap-dec := "}";
           cap-inc := "{";
       }
       ")" {
           dir := b;
           cap-dec := ")";
           cap-inc := "(";
       }
       "]" {
           dir := b;
           cap-dec := "]";
           cap-inc := "[";
       }
       "}" {
           dir := b;
           cap-dec := "}";
           cap-inc := "{";
       }
       default: {
           return SELF;
       }
    ;;

    find := <nil>;
    case $dir
        f {
            (start-y start-x) ::= $v get-next-pos $y $x;
            level := 1;
            $v each-forward-char $start-y $start-x {
                | cy cx cc |
                if {$cy > $end} {
                    return SELF;
                };
                if {$cc = $cap-dec} {$level --};
                if {$cc = $cap-inc} {$level ++};
                if {$level = 0} {
                    find := <t>;
                    break;
                };
            };
        }
        b {
            (start-y start-x) ::= $v get-prev-pos $y $x;
            level := -1;
            $v each-backward-char $start-y $start-x {
                | cy cx cc |
                if {$cy < $start} {
                    return SELF;
                };
                if {$cc = $cap-dec} {$level --};
                if {$cc = $cap-inc} {$level ++};
                if {$level = 0} {
                    find := <t>;
                    break;
                };
            };
        }
    ;;
    if $find {
        $window set-spot-color-item "BRACKETS-PAIR-D" $cy $cx 1 BRACKETS_PAIR;
        $window set-spot-color-item "BRACKETS-PAIR-S" $y $x 1 BRACKETS_PAIR;
    };
    return SELF;
};

defcommand list-config desc: "Display configuration list." {
    | main window |
    BufferManager unregist-buffer "*Config List*";
    buff ::= new EditBuffer;
    $buff load-content "config list" :init-only buffer-name: "*Config List*";
    $buff set-content [$DEFAULT_PWIKI_DIR . "/"];
    $buff clear-all;

    kmax ::= $CONFIG keys :string : map {| i | $i len} : max;
    pkmax ::= $kmax - 13;
    
    $buff append-string "<<< Configuration list >>>";
    $buff append-string [["%-${kmax}v %-v" expand] fmt "Key" "Description"];
    $buff append-string [["  %-${pkmax}v %7v %-2v %-v" expand] fmt [" " repeat $pkmax] "Type" "RO" "Value"];
    $buff append-string [["%-${kmax}v %-v" expand] fmt ["-" repeat $kmax] "-----------"];

    msort [$CONFIG keys :string] : each do: {| i |
        sep := "";
        case $CONFIG_TYPE,$i
            "STRING" {sep := "\""}
            "RQUOTE" {sep := "\'"}
        ;;
        
        $buff append-string [["%-${kmax}v %-v" expand] fmt
            $i
            [$CONFIG_DESC,$i ?? ""]
        ];
        $buff append-string [["  %-${pkmax}v %7v %!-2v %-v" expand] fmt
            [" " repeat $pkmax]
            $CONFIG_TYPE,$i
            [$CONFIG_RO,$i ??? "RO" "  "]
            [$sep . [setvar [symbol $i]] $sep]
        ];
        ### $buff append-string "";
        ;;
    };
    $buff no-modify;
    $buff set-protect;
    $main bind-buffer [$window get-window-name] $buff;
    
    result SELF;
};

defcommand set-config desc: "Set configuration value." {
    | main window |

    set _index -1;
    set _list [msort [$CONFIG keys :string]];

    mini-input-until-enter $main $window
        prompt: "Config name: "
        completion-proc: {| value |
            if {[$_list len] = 0} {
                $MainWindow set-mini-input-prompt "Config name (no match completion): ";
                return ALL;
            };
            setc _index [$_index +  1];
            if {$_index >= [$_list len] } {
                setc _index 0;
            };
            str ::= $_list get $_index;
            $MainWindow set-mini-input-prompt ["Config name (" . [$_list len] " match(es) completion): "];
            $main mini-input-value-override $str [$str len];
            return ALL;
        }
        completion-back-proc: {| value |
            if {[$_list len] = 0} {
                $MainWindow set-mini-input-prompt "Config name (no match completion): ";
                return ALL;
            };
            setc _index [$_index -  1];
            if {$_index < 0} {
                setc _index [$_list len : - 1];
            };
            str ::= $_list get $_index;
            $MainWindow set-mini-input-prompt ["Config name (" . [$_list len] " match(es) completion): "];
            $main mini-input-value-override $str [$str len];
            return ALL;
        }
        edit-proc: {| value |
            try {
                if {$value = ""} {
                    setc _list [msort [$CONFIG keys :string]];
                } {
                    setc _list [msort [$CONFIG keys :string] : filter {| n | $n =~ :text :nocase [$value rquote]}];
                };
            } catch: {
                setc _list ();
            };
            setc _index -1;
            if {[$_list len] > 0} {
                $MainWindow set-mini-input-prompt ["Config name (" . [$_list len] " match(es) completion): "];
                if {[$_list len] = 1} {
                    setc _index 0;
                };
            } {
                $MainWindow set-mini-input-prompt "Config name (no match completion): ";
            };
            return ALL;
        }
        enter-proc: {| value |
            if {or {[$_list len] = 0} {$_index < 0}} {
                show-message :bell "No config name specified.";
                return ALL;
            };
            conf-name ::= $_list get $_index;
            mini-input-until-enter $main $window
                prompt: ["Config name [" . $conf-name "] value: "]
                init-value: ["" . [setvar [symbol $conf-name]]]
                index: [["" . [setvar [symbol $conf-name]]] len]
                enter-proc: {| value |
                    if {eq? SYMBOL $CONFIG_TYPE,$conf-name} {
                        result ::= symbol $value;
                    } {
                        case $CONFIG_TYPE,$conf-name
                            INTEGER {t := int}
                            REAL    {t := real}
                            BOOL    {t := bool}
                            STRING  {t := string}
                            RQUOTE  {t := rquote}
                            LIST    {t := list}
                            DICT    {t := dict}
                            VECTOR  {t := vector}
                            default: {t := string}
                        ;;
                        result ::= $value $t;
                    };
                    try {
                        setconf [symbol $conf-name] $result;
                    } catch: {| e |
                        show-message :bell ["Error at setconf, <" . $e,0 "># " $e,1];
                        return ALL;
                    };
                    show-message ["Set config " . $conf-name " to " $result];
                    return ALL;
                }
            ;;
            return ALL;
        }
    ;;
    
    return ALL;
};

defcommand repeat-command desc: "Repeat last command n times." {
    | main window |
    
    times ::= $main get-repeat-times;
    do-repeat $main $window $times;
    return ALL;
};

defun do-repeat (main window times) {
    command ::= $main get-last-command;
    key ::= $main get-last-character;
    
    if {nil? $command} {return SELF};
    key ::= $key ?? "";
    times ::= {$times = 0} ??? 1 $times;
    
    result := <nil>;
    1 each to: $times do: {
        $main key-record $command $key;
        result ::= $window apply-command $main $window $key $command;
    };
    return $result;
};

defcommand set-times desc: "Set repeat time." {
    | main window |
    
    mini-input-until-enter $main $window
        prompt: "Repeat times: "
        enter-proc: {| value |
            try {
                if {$value = ""} {
                    times := 0;
                } {
                    times ::= $value int;
                    if {$times < 0} {throw ErrNegative "Negative value"};
                };
            } catch: {
                show-message :bell "Illegal times.";
                $main set-repeat-times 0;
                return ALL;
            };
            $main set-repeat-times $times;
        };
    ;;
    return ALL;
};

defcommand start-recording desc: "Start keyboard macro recording." {
    | main window |
    
    $main start-recording;
    return SELF;
};

defcommand start-recording-for-append desc: "Start keyboard macro recording for append to recording buffer." {
    | main window |
    
    $main start-recording-for-append;
    return SELF;
};

defcommand end-recording desc: "End keyboard macro recording." {
    | main window |
    
    $main end-recording;
    return SELF;
};

defcommand execute-record desc: "Execute keyboard macro." {
    | __main __window |
    
    __buff ::= $__main get-record-buffer;
    $__buff ?? {return ALL};
    $__buff clear;
    __ins-char-cmd := "insert-character";
    while {__r ::= $__buff gets} do: {
        if {"" = $__r} {continue};
        if {eq? $__ins-char-cmd [$__r sub 0 [$__ins-char-cmd len]]} {
            result ::= $__window apply-command $__main $__window [$__r sub [$__ins-char-cmd len : + 1]] [symbol $__ins-char-cmd];
        } {
            result ::= $__window apply-command $__main $__window "" [symbol $__r];
        };
    };
    return ALL;
};

defcommand terminal desc: "Shell terminal in buffer." {
    | main window |
    buff-name := "*Terminal*";
    buff ::= BufferManager find-buffer $buff-name;
    if $buff {
        $main bind-buffer [$window get-window-name] $buff;
        return ALL;
    };
    
    stream ::= new EditStream;
    $stream open $buff-name;
    _puts ::= $stream method? puts;
    $stream method puts (*) {
        atomic {
            _win := <nil>;
            _buff := <nil>;
            _geom := <nil>;
            $MainWindow get-window-list : each do: {| _i |
                _buff ::= $_i get-buffer;
                if {$_buff get-buffer-name : = $buff-name} {
                    _win := $_i;
                    _geom ::= $_i get-geom;
                    _y ::= $_buff get-buffer-length;
                    break;
                };
            };
            if $_win {
                (_sy _sx) ::= $_win get-screen-size;
                [self] set-columnlimit [[$_sx > 80] ??? [$_sx - 1] 80];
            };

            _r ::= call $_puts $*;

            nl ::= $* find [symbol ":nonewline"];
            if $nl {
                _p ::= $* delete $nl : join sep: "";
            } {
                _p := "";
            };
            set-prompt $_p;
                
            if $_win {
                if {$_y >= 1} {
                    if {$_p = ""} {
                        _x := 0;
                    } {
                        _y ::= $_y - 1;
                        _x ::= $_buff get-buffer-line $_y : len;
                    };
                } {
                    _y := 0;
                    _x ::= $_buff get-buffer-line $_y : len;
                };
                $_i cursor-move-to $_geom $_y $_x;
                $MainWindow set-force-update;
            };
        };
        return $_r;
    };
    buff ::= $stream get-buffer;
    $buff set-content $ENV,HOME;
    $buff set-unregist-proc {try {zap $TERMINAL_TASK} catch: {}};
    $main bind-buffer [$window get-window-name] $buff;
    $buff append-string "--- Start pmacs terminal emulator.";
    $buff append-string "--- Type CTRL+\\ to send process keycode."; 
    $buff append-string "";
    $buff append-string "";
    
    task ::= new Task;
    $task set-stdout $stream;
    $task set-stderr $stream;
    $task set-terminate-proc {
        pid ::= $task get-client;
        try {kill $SIGHUP $pid} catch: {};
        try {wait $pid} catch: {};
    };
    
    ###
    ### do command
    ###
    $task proc $TERMINAL_TASK {
        (window buff directory shell env) := $ARGS;
        cd $directory;
        sts ::= exec 
            :pty  
            pid-proc: {| pid | set-client $pid}
            environ: $env
            verbose: {| m | output-log $m}
            $shell "-i"
        ;;
        
        println "[Terminal exited with status " $sts "]";
        
    } $window [$stream get-buffer] $ENV,HOME $TERMINAL_SHELL $TERMINAL_ENV;

    return ALL;
};

defcommand terminal-enter-command desc: "Shell terminal command enter." {
    | main window |
    buff ::= $window get-buffer;
    geom ::= $window get-geom;
    task ::= get-terminal-task;
    if {! $task} {return ALL};
    
    task_stdin ::= get-terminal-task-stdin;
    stream ::= get-terminal-task-stdout;
    (ey ex) ::= $window get-source-index $buff $geom;
    r ::= $buff get-buffer-line $ey;
    if {! $r} {r := ""};
    prompt ::= $stream get-prompt;
    if {$prompt = [$r sub 0 [$prompt len]]} {
        r ::= $r sub [$prompt len];
    } {
        if {[$r len] <= [$prompt len]} {
            if {$r = [$prompt sub 0 [$r len]]} {
                r := "";
            };
        };
    };
    if {$r != ""} {
        $window apply-command $main $window "" mark;
    };
    $buff append-string "";
    $task_stdin puts $r;
    $window cursor-move-to $geom [$buff get-buffer-length : - 1] 0;
    
    ### cd command emuration
    l ::= $r split;
    if {$l get 0 : = "cd"} {
        if {$l len : = 1} {
            path := $ENV,HOME
        } {
            dir ::= $l get 1;
            if {$dir at 0 : = "~"} {
                path ::= $dir replace '^~' $ENV,HOME;
            } {
                if {$dir at 0 : = "/"} {
                    path ::= path-adjust $dir;
                } {
                    if {$buff get-content-dir : = "/"} {
                        path ::= path-adjust ["/" . $dir];
                    } {
                        path ::= path-adjust [$buff get-content-dir : . "/" $dir];
                    };
                };
            };
            if {neq? [get-path-condition $path : get 0] DIRECTORY} {
                path ::= $buff get-content-dir;
            };
        };
        $buff set-content $path;
        show-message ["(cd) " . $path];
    };
    
    return ALL;
};

defun get-terminal-task () {
    task ::= TaskManager get-task $TERMINAL_TASK;
    return $task;
};

defun get-terminal-task-stdin () {
    task ::= TaskManager get-task $TERMINAL_TASK;
    stream := <nil>;
    if $task {
        stream ::= $task get-stdio : get 0;
    };
    return $stream;
};

defun get-terminal-task-stdout () {
    task ::= TaskManager get-task $TERMINAL_TASK;
    stream := <nil>;
    if $task {
        stream ::= $task get-stdio : get 1;
    };
    return $stream;
};

defun get-terminal-task-stderr () {
    task ::= TaskManager get-task $TERMINAL_TASK;
    stream := <nil>;
    if $task {
        stream ::= $task get-stdio : get 2;
    };
    return $stream;
};

defcommand terminal-send-break desc: "Send BREAK to shell terminal." {
    if {$OSTYPE = "FreeBSD"} {
        t ::= get-terminal-task;
        $t ?? {return ALL};
        pid ::= $t get-client;
        killpg $SIGINT $pid;
        return ALL;
    };

    stream ::= get-terminal-task-stdin;
    if $stream {
        $stream puts :nonewline ["" uimport! (3)];
    };
    return ALL;
};

defcommand terminal-send-eof desc: "Send EOF to shell terminal." {
    stream ::= get-terminal-task-stdin;
    if $stream {
        $stream puts :nonewline ["" uimport! (4)];
    };
    return ALL;
};

defcommand terminal-send-quit desc: "Send QUIT to shell terminal." {
    if {$OSTYPE = "FreeBSD"} {
        t ::= get-terminal-task;
        $t ?? {return ALL};
        pid ::= $t get-client;
        killpg $SIGQUIT $pid;
        return ALL;
    };
    
    stream ::= get-terminal-task-stdin;
    if $stream {
        $stream puts :nonewline ["" uimport! (0x1C)];
    };
    return ALL;
};

defcommand terminal-send-suspend desc: "Send SUSPEND to shell terminal." {
    if {$OSTYPE = "FreeBSD"} {
        show-message :bell "Not supported terminal code ^Z on this platform.";
        return ALL;
    };
    
    stream ::= get-terminal-task-stdin;
    if $stream {
        $stream puts :nonewline ["" uimport! (26)];
    };
    return ALL;
};
