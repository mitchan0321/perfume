class EditBuffer BufferBase;

EditBuffer method init () {
    init-constructor;
};

EditBuffer method init-constructor () {
    sets Src <nil>;
    sets File <nil>;
    sets BufferName <nil>;
    sets Modify <nil>;
    sets NewFile <nil>;
};

EditBuffer method load-content (path init-only: init-flag buffer-name: buff-name) {
    result := <nil>;
    f ::= new File;
    sets NewFile <nil>;
    sets Src [vector];
    sets File $path;
    if {[$path sub 0 1] = "/"} {path ::= path-adjust $path};

    if {! [set? init-flag]} {
	try {
	    $f open $path mode: i;
	    $f each do: {| r |
		$Src append! $r;
	    };
            result := <t>;
	}
	catch: {| e |
	    sets NewFile <t>;
	    result := <nil>;
	}
        fin: {
	    $f close;
	};
    } {
        result := <t>;
	sets NewFile <nil>;
	sets File <nil>;
    };

    if {$path = ""} {sets File "anonymous.pmacs"};
    if {! [set? buff-name]} {
	buff-name ::= $path split sep: "/" : last : car;
	$buff-name ?? {buff-name := "*no named*"};
    };
    BufferManager regist-buffer [self] $buff-name;

    sets Modify <nil>;
    return $result;
};

EditBuffer method save-content (path: path) {
    if {! [set? path]} {
	path ::= get-path;
    };
    if {or {nil? $path} {$path = ""}} {return (<nil> ErrNoPathSpacified)};
    if {[$path sub 0 1] = "/"} {path ::= path-adjust $path};
    sets File $path;
    
    l ::= $path split sep: "/";
    backup-path ::= $l <<- ["%" . [$l ->>] "%"] : join sep: "/";
    mode := $DEFAULT_FILE_MODE;
    if {file exists? $path} {
	try {
	    d ::= dict [file stat $path];
	    mode ::= $d get mode;
	} catch: {| e |
	    return (<nil>
		["<" . [$e car] "># " [$e cdr] ", at file mode get."]);
	};
    } {
	backup-path := <nil>;
    };
    
    f ::= new File;
    try {
	if $backup-path {
	    $f open $backup-path mode: o;
	} {
	    $f open $path mode: o;
	};
    } catch: {| e |
	$f close;
	return (<nil>
	    ["<" . [$e car] "># " [$e cdr] ", at create new file, "
	     [$backup-path ??? $backup-path $path] "."]);
    };

    try {
	if $Src {
	    $Src each do: {| r |
		$f puts $r;
	    }
	};
	$f close;
	if $backup-path {
	    file chmod $backup-path $mode;
        };
    } catch: {| e |
	$f close;
	return (<nil>
	    ["<" . [$e car] "># " [$e cdr] ", at file write."]);
    };

    if $backup-path {
	file rm $path;
	file rename $backup-path $path;
    };

    sets Modify <nil>;
    return (<t> Success);
};

EditBuffer method clear-all () {
    sets Src [vector];
};

EditBuffer method unregist-buffer () {
    BufferManager unregist-buffer $BufferName;
};

EditBuffer method get-path () {
    return $File;
};

EditBuffer method buffer-select (from to block) {
    $from each to: $to do: {| i |
	if {and [$i < [$Src len]] [$i >= 0]}
	then: {
	    yield $block $Src,$i;
	}
	else: {
	    yield $block "";
	};
    };
};

EditBuffer method get-buffer-line (line) {
    $Src ?? {return <nil>};
    if {$line < 0} {return <nil>};
    if {$line >= [$Src len]} {
	return <nil>;
    } {
	if {[$Src len] <= 0} {return <nil>};
	return [$Src get $line];
    };
};

EditBuffer method get-buffer-length () {
    return [$Src ??? [$Src len] 0];
};

EditBuffer method insert-string-at (input y x) {
    sets Modify <t>;
    if {true? Src} {
	return [$Src insert-string-at $input $y $x];
    };
    return (0 0);
};

EditBuffer method delete-character-at (y x) {
    sets Modify <t>;
    if {true? Src} {
	return [$Src delete-character-at $y $x];
    };
    return (0 0 "");
};

EditBuffer method backdelete-character-at (y x) {
    sets Modify <t>;
    if {true? Src} {
	return [$Src backdelete-character-at $y $x];
    };
    return (0 0 "");
};

EditBuffer method append-string (str) {
    sets Modify <t>;
    if {true? Src} {
	return [$Src append-string $str];
    };
    return (0 0 "");
};

EditBuffer method modify? () {
    return $Modify;
};

EditBuffer method no-modify () {
    sets Modify <nil>;
};

EditBuffer method newfile? () {
    return $NewFile;
};
